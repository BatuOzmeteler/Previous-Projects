/* This file was automatically generated by CasADi.
   The CasADi copyright holders make no ownership claim of its contents. */
#ifdef __cplusplus
extern "C" {
#endif

/* How to prefix internal symbols */
#ifdef CASADI_CODEGEN_PREFIX
  #define CASADI_NAMESPACE_CONCAT(NS, ID) _CASADI_NAMESPACE_CONCAT(NS, ID)
  #define _CASADI_NAMESPACE_CONCAT(NS, ID) NS ## ID
  #define CASADI_PREFIX(ID) CASADI_NAMESPACE_CONCAT(CODEGEN_PREFIX, ID)
#else
  #define CASADI_PREFIX(ID) codegen_demo_ ## ID
#endif

#include <math.h>
#include <string.h>
#ifdef MATLAB_MEX_FILE
#include <mex.h>
#endif
#include <stdarg.h>
#include <stdio.h>

#ifndef casadi_real
#define casadi_real double
#endif

#ifndef casadi_int
#define casadi_int long long int
#endif

/* Add prefix to internal symbols */
#define casadi_axpy CASADI_PREFIX(axpy)
#define casadi_bilin CASADI_PREFIX(bilin)
#define casadi_casadi_qp_du_direction CASADI_PREFIX(casadi_qp_du_direction)
#define casadi_casadi_qp_pr_direction CASADI_PREFIX(casadi_qp_pr_direction)
#define casadi_clear CASADI_PREFIX(clear)
#define casadi_copy CASADI_PREFIX(copy)
#define casadi_densify CASADI_PREFIX(densify)
#define casadi_dot CASADI_PREFIX(dot)
#define casadi_f0 CASADI_PREFIX(f0)
#define casadi_f1 CASADI_PREFIX(f1)
#define casadi_f10 CASADI_PREFIX(f10)
#define casadi_f11 CASADI_PREFIX(f11)
#define casadi_f2 CASADI_PREFIX(f2)
#define casadi_f3 CASADI_PREFIX(f3)
#define casadi_f4 CASADI_PREFIX(f4)
#define casadi_f5 CASADI_PREFIX(f5)
#define casadi_f6 CASADI_PREFIX(f6)
#define casadi_f7 CASADI_PREFIX(f7)
#define casadi_f8 CASADI_PREFIX(f8)
#define casadi_f9 CASADI_PREFIX(f9)
#define casadi_fill CASADI_PREFIX(fill)
#define casadi_fmax CASADI_PREFIX(fmax)
#define casadi_fmin CASADI_PREFIX(fmin)
#define casadi_from_mex CASADI_PREFIX(from_mex)
#define casadi_house CASADI_PREFIX(house)
#define casadi_if_else CASADI_PREFIX(if_else)
#define casadi_max_viol CASADI_PREFIX(max_viol)
#define casadi_mv CASADI_PREFIX(mv)
#define casadi_nlpsol_data CASADI_PREFIX(nlpsol_data)
#define casadi_nlpsol_init CASADI_PREFIX(nlpsol_init)
#define casadi_nlpsol_prob CASADI_PREFIX(nlpsol_prob)
#define casadi_nlpsol_work CASADI_PREFIX(nlpsol_work)
#define casadi_norm_inf CASADI_PREFIX(norm_inf)
#define casadi_qp_calc_dependent CASADI_PREFIX(qp_calc_dependent)
#define casadi_qp_calc_sens CASADI_PREFIX(qp_calc_sens)
#define casadi_qp_calc_step CASADI_PREFIX(qp_calc_step)
#define casadi_qp_data CASADI_PREFIX(qp_data)
#define casadi_qp_du CASADI_PREFIX(qp_du)
#define casadi_qp_du_check CASADI_PREFIX(qp_du_check)
#define casadi_qp_du_index CASADI_PREFIX(qp_du_index)
#define casadi_qp_dual_blocking CASADI_PREFIX(qp_dual_blocking)
#define casadi_qp_dual_breakpoints CASADI_PREFIX(qp_dual_breakpoints)
#define casadi_qp_enforceable CASADI_PREFIX(qp_enforceable)
#define casadi_qp_expand_step CASADI_PREFIX(qp_expand_step)
#define casadi_qp_factorize CASADI_PREFIX(qp_factorize)
#define casadi_qp_flag_t CASADI_PREFIX(qp_flag_t)
#define casadi_qp_flip CASADI_PREFIX(qp_flip)
#define casadi_qp_flip_check CASADI_PREFIX(qp_flip_check)
#define casadi_qp_init CASADI_PREFIX(qp_init)
#define casadi_qp_iterate CASADI_PREFIX(qp_iterate)
#define casadi_qp_kkt CASADI_PREFIX(qp_kkt)
#define casadi_qp_kkt_dot CASADI_PREFIX(qp_kkt_dot)
#define casadi_qp_kkt_residual CASADI_PREFIX(qp_kkt_residual)
#define casadi_qp_kkt_vector CASADI_PREFIX(qp_kkt_vector)
#define casadi_qp_linesearch CASADI_PREFIX(qp_linesearch)
#define casadi_qp_pr CASADI_PREFIX(qp_pr)
#define casadi_qp_pr_index CASADI_PREFIX(qp_pr_index)
#define casadi_qp_prepare CASADI_PREFIX(qp_prepare)
#define casadi_qp_primal_blocking CASADI_PREFIX(qp_primal_blocking)
#define casadi_qp_print_colcomb CASADI_PREFIX(qp_print_colcomb)
#define casadi_qp_print_header CASADI_PREFIX(qp_print_header)
#define casadi_qp_print_iteration CASADI_PREFIX(qp_print_iteration)
#define casadi_qp_prob CASADI_PREFIX(qp_prob)
#define casadi_qp_reset CASADI_PREFIX(qp_reset)
#define casadi_qp_setup CASADI_PREFIX(qp_setup)
#define casadi_qp_singular_step CASADI_PREFIX(qp_singular_step)
#define casadi_qp_take_step CASADI_PREFIX(qp_take_step)
#define casadi_qp_work CASADI_PREFIX(qp_work)
#define casadi_qp_zero_blocking CASADI_PREFIX(qp_zero_blocking)
#define casadi_qr CASADI_PREFIX(qr)
#define casadi_qr_colcomb CASADI_PREFIX(qr_colcomb)
#define casadi_qr_mv CASADI_PREFIX(qr_mv)
#define casadi_qr_singular CASADI_PREFIX(qr_singular)
#define casadi_qr_solve CASADI_PREFIX(qr_solve)
#define casadi_qr_trs CASADI_PREFIX(qr_trs)
#define casadi_s0 CASADI_PREFIX(s0)
#define casadi_s1 CASADI_PREFIX(s1)
#define casadi_s10 CASADI_PREFIX(s10)
#define casadi_s11 CASADI_PREFIX(s11)
#define casadi_s12 CASADI_PREFIX(s12)
#define casadi_s13 CASADI_PREFIX(s13)
#define casadi_s14 CASADI_PREFIX(s14)
#define casadi_s2 CASADI_PREFIX(s2)
#define casadi_s3 CASADI_PREFIX(s3)
#define casadi_s4 CASADI_PREFIX(s4)
#define casadi_s5 CASADI_PREFIX(s5)
#define casadi_s6 CASADI_PREFIX(s6)
#define casadi_s7 CASADI_PREFIX(s7)
#define casadi_s8 CASADI_PREFIX(s8)
#define casadi_s9 CASADI_PREFIX(s9)
#define casadi_scal CASADI_PREFIX(scal)
#define casadi_sq CASADI_PREFIX(sq)
#define casadi_sqpmethod_data CASADI_PREFIX(sqpmethod_data)
#define casadi_sqpmethod_init CASADI_PREFIX(sqpmethod_init)
#define casadi_sqpmethod_prob CASADI_PREFIX(sqpmethod_prob)
#define casadi_sqpmethod_work CASADI_PREFIX(sqpmethod_work)
#define casadi_sum_viol CASADI_PREFIX(sum_viol)
#define casadi_to_mex CASADI_PREFIX(to_mex)
#define casadi_trans CASADI_PREFIX(trans)

/* Symbol visibility in DLLs */
#ifndef CASADI_SYMBOL_EXPORT
  #if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
    #if defined(STATIC_LINKED)
      #define CASADI_SYMBOL_EXPORT
    #else
      #define CASADI_SYMBOL_EXPORT __declspec(dllexport)
    #endif
  #elif defined(__GNUC__) && defined(GCC_HASCLASSVISIBILITY)
    #define CASADI_SYMBOL_EXPORT __attribute__ ((visibility ("default")))
  #else
    #define CASADI_SYMBOL_EXPORT
  #endif
#endif

casadi_real casadi_sq(casadi_real x) { return x*x;}

void casadi_copy(const casadi_real* x, casadi_int n, casadi_real* y) {
  casadi_int i;
  if (y) {
    if (x) {
      for (i=0; i<n; ++i) *y++ = *x++;
    } else {
      for (i=0; i<n; ++i) *y++ = 0.;
    }
  }
}

void casadi_clear(casadi_real* x, casadi_int n) {
  casadi_int i;
  if (x) {
    for (i=0; i<n; ++i) *x++ = 0;
  }
}

void casadi_fill(casadi_real* x, casadi_int n, casadi_real alpha) {
  casadi_int i;
  if (x) {
    for (i=0; i<n; ++i) *x++ = alpha;
  }
}

#define CASADI_CAST(x,y) ((x) y)

void casadi_densify(const casadi_real* x, const casadi_int* sp_x, casadi_real* y, casadi_int tr) {
  casadi_int nrow_x, ncol_x, i, el;
  const casadi_int *colind_x, *row_x;
  if (!y) return;
  nrow_x = sp_x[0]; ncol_x = sp_x[1];
  colind_x = sp_x+2; row_x = sp_x+ncol_x+3;
  casadi_clear(y, nrow_x*ncol_x);
  if (!x) return;
  if (tr) {
    for (i=0; i<ncol_x; ++i) {
      for (el=colind_x[i]; el!=colind_x[i+1]; ++el) {
        y[i + row_x[el]*ncol_x] = CASADI_CAST(casadi_real, *x++);
      }
    }
  } else {
    for (i=0; i<ncol_x; ++i) {
      for (el=colind_x[i]; el!=colind_x[i+1]; ++el) {
        y[row_x[el]] = CASADI_CAST(casadi_real, *x++);
      }
      y += nrow_x;
    }
  }
}

void casadi_trans(const casadi_real* x, const casadi_int* sp_x, casadi_real* y,
    const casadi_int* sp_y, casadi_int* tmp) {
  casadi_int ncol_x, nnz_x, ncol_y, k;
  const casadi_int* row_x, *colind_y;
  ncol_x = sp_x[1];
  nnz_x = sp_x[2 + ncol_x];
  row_x = sp_x + 2 + ncol_x+1;
  ncol_y = sp_y[1];
  colind_y = sp_y+2;
  for (k=0; k<ncol_y; ++k) tmp[k] = colind_y[k];
  for (k=0; k<nnz_x; ++k) {
    y[tmp[row_x[k]]++] = x[k];
  }
}

casadi_real casadi_if_else(casadi_real c, casadi_real x, casadi_real y) { return c!=0 ? x : y;}

void casadi_scal(casadi_int n, casadi_real alpha, casadi_real* x) {
  casadi_int i;
  if (!x) return;
  for (i=0; i<n; ++i) *x++ *= alpha;
}

casadi_real casadi_dot(casadi_int n, const casadi_real* x, const casadi_real* y) {
  casadi_int i;
  casadi_real r = 0;
  for (i=0; i<n; ++i) r += *x++ * *y++;
  return r;
}

casadi_real casadi_house(casadi_real* v, casadi_real* beta, casadi_int nv) {
  casadi_int i;
  casadi_real v0, sigma, s, sigma_is_zero, v0_nonpos;
  v0 = v[0];
  sigma=0;
  for (i=1; i<nv; ++i) sigma += v[i]*v[i];
  s = sqrt(v0*v0 + sigma);
  sigma_is_zero = sigma==0;
  v0_nonpos = v0<=0;
  v[0] = casadi_if_else(sigma_is_zero, 1,
                 casadi_if_else(v0_nonpos, v0-s, -sigma/(v0+s)));
  *beta = casadi_if_else(sigma_is_zero, 2*v0_nonpos, -1/(s*v[0]));
  return s;
}
void casadi_qr(const casadi_int* sp_a, const casadi_real* nz_a, casadi_real* x,
               const casadi_int* sp_v, casadi_real* nz_v, const casadi_int* sp_r, casadi_real* nz_r, casadi_real* beta,
               const casadi_int* prinv, const casadi_int* pc) {
   casadi_int ncol, nrow, r, c, k, k1;
   casadi_real alpha;
   const casadi_int *a_colind, *a_row, *v_colind, *v_row, *r_colind, *r_row;
   ncol = sp_a[1];
   a_colind=sp_a+2; a_row=sp_a+2+ncol+1;
   nrow = sp_v[0];
   v_colind=sp_v+2; v_row=sp_v+2+ncol+1;
   r_colind=sp_r+2; r_row=sp_r+2+ncol+1;
   for (r=0; r<nrow; ++r) x[r] = 0;
   for (c=0; c<ncol; ++c) {
     for (k=a_colind[pc[c]]; k<a_colind[pc[c]+1]; ++k) x[prinv[a_row[k]]] = nz_a[k];
     for (k=r_colind[c]; k<r_colind[c+1] && (r=r_row[k])<c; ++k) {
       alpha = 0;
       for (k1=v_colind[r]; k1<v_colind[r+1]; ++k1) alpha += nz_v[k1]*x[v_row[k1]];
       alpha *= beta[r];
       for (k1=v_colind[r]; k1<v_colind[r+1]; ++k1) x[v_row[k1]] -= alpha*nz_v[k1];
       *nz_r++ = x[r];
       x[r] = 0;
     }
     for (k=v_colind[c]; k<v_colind[c+1]; ++k) {
       nz_v[k] = x[v_row[k]];
       x[v_row[k]] = 0;
     }
     *nz_r++ = casadi_house(nz_v + v_colind[c], beta + c, v_colind[c+1] - v_colind[c]);
   }
 }
void casadi_qr_mv(const casadi_int* sp_v, const casadi_real* v, const casadi_real* beta, casadi_real* x,
                  casadi_int tr) {
  casadi_int ncol, c, c1, k;
  casadi_real alpha;
  const casadi_int *colind, *row;
  ncol=sp_v[1];
  colind=sp_v+2; row=sp_v+2+ncol+1;
  for (c1=0; c1<ncol; ++c1) {
    c = tr ? c1 : ncol-1-c1;
    alpha=0;
    for (k=colind[c]; k<colind[c+1]; ++k) alpha += v[k]*x[row[k]];
    alpha *= beta[c];
    for (k=colind[c]; k<colind[c+1]; ++k) x[row[k]] -= alpha*v[k];
  }
}
void casadi_qr_trs(const casadi_int* sp_r, const casadi_real* nz_r, casadi_real* x, casadi_int tr) {
  casadi_int ncol, r, c, k;
  const casadi_int *colind, *row;
  ncol=sp_r[1];
  colind=sp_r+2; row=sp_r+2+ncol+1;
  if (tr) {
    for (c=0; c<ncol; ++c) {
      for (k=colind[c]; k<colind[c+1]; ++k) {
        r = row[k];
        if (r==c) {
          x[c] /= nz_r[k];
        } else {
          x[c] -= nz_r[k]*x[r];
        }
      }
    }
  } else {
    for (c=ncol-1; c>=0; --c) {
      for (k=colind[c+1]-1; k>=colind[c]; --k) {
        r=row[k];
        if (r==c) {
          x[r] /= nz_r[k];
        } else {
          x[r] -= nz_r[k]*x[c];
        }
      }
    }
  }
}
void casadi_qr_solve(casadi_real* x, casadi_int nrhs, casadi_int tr,
                     const casadi_int* sp_v, const casadi_real* v, const casadi_int* sp_r, const casadi_real* r,
                     const casadi_real* beta, const casadi_int* prinv, const casadi_int* pc, casadi_real* w) {
  casadi_int k, c, nrow_ext, ncol;
  nrow_ext = sp_v[0]; ncol = sp_v[1];
  for (k=0; k<nrhs; ++k) {
    if (tr) {
      for (c=0; c<ncol; ++c) w[c] = x[pc[c]];
      casadi_qr_trs(sp_r, r, w, 1);
      casadi_qr_mv(sp_v, v, beta, w, 0);
      for (c=0; c<ncol; ++c) x[c] = w[prinv[c]];
    } else {
      for (c=0; c<nrow_ext; ++c) w[c] = 0;
      for (c=0; c<ncol; ++c) w[prinv[c]] = x[c];
      casadi_qr_mv(sp_v, v, beta, w, 1);
      casadi_qr_trs(sp_r, r, w, 0);
      for (c=0; c<ncol; ++c) x[pc[c]] = w[c];
    }
    x += ncol;
  }
}
casadi_int casadi_qr_singular(casadi_real* rmin, casadi_int* irmin, const casadi_real* nz_r,
                             const casadi_int* sp_r, const casadi_int* pc, casadi_real eps) {
  casadi_real rd, rd_min;
  casadi_int ncol, c, nullity;
  const casadi_int* r_colind;
  nullity = 0;
  ncol = sp_r[1];
  r_colind = sp_r + 2;
  for (c=0; c<ncol; ++c) {
    rd = fabs(nz_r[r_colind[c+1]-1]);
    if (rd<eps) nullity++;
    if (c==0 || rd < rd_min) {
      rd_min = rd;
      if (rmin) *rmin = rd;
      if (irmin) *irmin = pc[c];
    }
  }
  return nullity;
}
void casadi_qr_colcomb(casadi_real* v, const casadi_real* nz_r, const casadi_int* sp_r,
                       const casadi_int* pc, casadi_real eps, casadi_int ind) {
  casadi_int ncol, r, c, k;
  const casadi_int *r_colind, *r_row;
  ncol = sp_r[1];
  r_colind = sp_r + 2;
  r_row = r_colind + ncol + 1;
  for (c=0; c<ncol; ++c) {
    if (fabs(nz_r[r_colind[c+1]-1])<eps && 0==ind--) {
      ind = c;
      break;
    }
  }
  casadi_clear(v, ncol);
  v[pc[ind]] = 1.;
  for (k=r_colind[ind]; k<r_colind[ind+1]-1; ++k) {
    v[pc[r_row[k]]] = -nz_r[k];
  }
  for (c=ind-1; c>=0; --c) {
    for (k=r_colind[c+1]-1; k>=r_colind[c]; --k) {
      r=r_row[k];
      if (r==c) {
        if (fabs(nz_r[k])<eps) {
          v[pc[r]] = 0;
        } else {
          v[pc[r]] /= nz_r[k];
        }
      } else {
        v[pc[r]] -= nz_r[k]*v[pc[c]];
      }
    }
  }
  casadi_scal(ncol, 1./sqrt(casadi_dot(ncol, v, v)), v);
}

casadi_int casadi_max(casadi_int x, casadi_int y) {
  return x>y ? x : y;
}

casadi_real casadi_fmin(casadi_real x, casadi_real y) {
/* Pre-c99 compatibility */
#if __STDC_VERSION__ < 199901L
  return x<y ? x : y;
#else
  return fmin(x, y);
#endif
}

casadi_real casadi_fmax(casadi_real x, casadi_real y) {
/* Pre-c99 compatibility */
#if __STDC_VERSION__ < 199901L
  return x>y ? x : y;
#else
  return fmax(x, y);
#endif
}

void casadi_axpy(casadi_int n, casadi_real alpha, const casadi_real* x, casadi_real* y) {
  casadi_int i;
  if (!x || !y) return;
  for (i=0; i<n; ++i) *y++ += alpha**x++;
}

void casadi_mv(const casadi_real* x, const casadi_int* sp_x, const casadi_real* y, casadi_real* z, casadi_int tr) {
  casadi_int ncol_x, i, el;
  const casadi_int *colind_x, *row_x;
  if (!x || !y || !z) return;
  ncol_x = sp_x[1];
  colind_x = sp_x+2; row_x = sp_x + 2 + ncol_x+1;
  if (tr) {
    for (i=0; i<ncol_x; ++i) {
      for (el=colind_x[i]; el<colind_x[i+1]; ++el) {
        z[i] += x[el] * y[row_x[el]];
      }
    }
  } else {
    for (i=0; i<ncol_x; ++i) {
      for (el=colind_x[i]; el<colind_x[i+1]; ++el) {
        z[row_x[el]] += x[el] * y[i];
      }
    }
  }
}

casadi_real casadi_bilin(const casadi_real* A, const casadi_int* sp_A, const casadi_real* x, const casadi_real* y) {
  casadi_int ncol_A, cc, rr, el;
  const casadi_int *colind_A, *row_A;
  casadi_real ret;
  ncol_A = sp_A[1];
  colind_A = sp_A+2; row_A = sp_A + 2 + ncol_A+1;
  ret=0;
  for (cc=0; cc<ncol_A; ++cc) {
    for (el=colind_A[cc]; el<colind_A[cc+1]; ++el) {
      rr=row_A[el];
      ret += x[rr]*A[el]*y[cc];
    }
  }
  return ret;
}

#ifndef casadi_inf
  #define casadi_inf INFINITY
#endif

#ifndef casadi_real_min
  #define casadi_real_min 2.2250738585072014e-308
#endif

struct casadi_qp_prob {
  const casadi_int *sp_a, *sp_h, *sp_at, *sp_kkt;
  const casadi_int *prinv, *pc, *sp_v, *sp_r;
  casadi_int nx, na, nz;
  casadi_real dmin;
  casadi_real inf;
  casadi_real min_lam;
  casadi_int max_iter;
  casadi_real constr_viol_tol, dual_inf_tol;
};
void casadi_qp_setup(struct casadi_qp_prob* p) {
  p->na = p->sp_a[0];
  p->nx = p->sp_a[1];
  p->nz = p->nx + p->na;
  p->dmin = casadi_real_min;
  p->inf = casadi_inf;
  p->min_lam = 0;
  p->max_iter = 1000;
  p->constr_viol_tol = 1e-8;
  p->dual_inf_tol = 1e-8;
}
void casadi_qp_work(const struct casadi_qp_prob* p, casadi_int* sz_iw, casadi_int* sz_w) {
  casadi_int nnz_a, nnz_kkt, nnz_v, nnz_r;
  nnz_a = p->sp_a[2+p->sp_a[1]];
  nnz_kkt = p->sp_kkt[2+p->sp_kkt[1]];
  nnz_v = p->sp_v[2+p->sp_v[1]];
  nnz_r = p->sp_r[2+p->sp_r[1]];
  *sz_w = *sz_iw = 0;
  *sz_w = casadi_max(*sz_w, p->nz);
  *sz_iw = casadi_max(*sz_iw, p->nz);
  *sz_w = casadi_max(*sz_w, 2*p->nz);
  *sz_w += nnz_kkt;
  *sz_w += p->nz;
  *sz_w += p->nz;
  *sz_w += p->nz;
  *sz_w += p->nz;
  *sz_w += nnz_a;
  *sz_w += p->nz;
  *sz_w += p->nz;
  *sz_w += p->nx;
  *sz_w += p->nx;
  *sz_w += p->nz;
  *sz_iw += p->nz;
  *sz_iw += p->nz;
  *sz_iw += p->nz;
  *sz_iw += p->nz;
  *sz_w += casadi_max(nnz_v+nnz_r, nnz_kkt);
  *sz_w += p->nz;
}
typedef enum {
  QP_SUCCESS,
  QP_MAX_ITER,
  QP_NO_SEARCH_DIR,
  QP_PRINTING_ERROR
} casadi_qp_flag_t;
struct casadi_qp_data {
  const struct casadi_qp_prob* prob;
  casadi_qp_flag_t status;
  casadi_real f;
  const casadi_real *nz_a, *nz_h, *g;
  casadi_real *z, *lbz, *ubz, *infeas, *tinfeas, *sens, *lam, *w, *dz, *dlam;
  casadi_int *iw, *neverzero, *neverlower, *neverupper, *lincomb;
  casadi_real *nz_at, *nz_kkt, *beta, *nz_v, *nz_r;
  const char *msg;
  casadi_int msg_ind;
  casadi_real tau;
  casadi_int sing;
  int has_search_dir;
  casadi_real mina;
  casadi_int imina;
  casadi_real pr, du, epr, edu;
  casadi_int ipr, idu;
  casadi_int index, sign;
  casadi_int r_index, r_sign;
  casadi_int iter;
};
void casadi_qp_init(struct casadi_qp_data* d, casadi_int** iw, casadi_real** w) {
  casadi_int nnz_a, nnz_kkt, nnz_v, nnz_r;
  const struct casadi_qp_prob* p = d->prob;
  nnz_a = p->sp_a[2+p->sp_a[1]];
  nnz_kkt = p->sp_kkt[2+p->sp_kkt[1]];
  nnz_v = p->sp_v[2+p->sp_v[1]];
  nnz_r = p->sp_r[2+p->sp_r[1]];
  d->nz_kkt = *w; *w += nnz_kkt;
  d->z = *w; *w += p->nz;
  d->lbz = *w; *w += p->nz;
  d->ubz = *w; *w += p->nz;
  d->lam = *w; *w += p->nz;
  d->dz = *w; *w += p->nz;
  d->dlam = *w; *w += p->nz;
  d->nz_v = *w; *w += casadi_max(nnz_v+nnz_r, nnz_kkt);
  d->nz_r = d->nz_v + nnz_v;
  d->beta = *w; *w += p->nz;
  d->nz_at = *w; *w += nnz_a;
  d->infeas = *w; *w += p->nx;
  d->tinfeas = *w; *w += p->nx;
  d->sens = *w; *w += p->nz;
  d->neverzero = *iw; *iw += p->nz;
  d->neverupper = *iw; *iw += p->nz;
  d->neverlower = *iw; *iw += p->nz;
  d->lincomb = *iw; *iw += p->nz;
  d->w = *w;
  d->iw = *iw;
}
int casadi_qp_reset(struct casadi_qp_data* d) {
  casadi_int i;
  const struct casadi_qp_prob* p = d->prob;
  d->msg = 0;
  d->tau = 0.;
  d->sing = 0;
  for (i=0; i<p->nz; ++i) {
    d->neverzero[i] = d->lbz[i] == d->ubz[i];
    d->neverupper[i] = d->ubz[i] == p->inf;
    d->neverlower[i] = d->lbz[i] == -p->inf;
    if (d->neverzero[i] && d->neverupper[i] && d->neverlower[i]) return 1;
    if (!d->neverzero[i] && fabs(d->lam[i]) < p->min_lam) d->lam[i] = 0.;
    if (d->neverzero[i] && d->lam[i] == 0.) {
      d->lam[i] = d->neverupper[i]
                || d->z[i]-d->lbz[i] <= d->ubz[i]-d->z[i] ? -p->dmin : p->dmin;
    } else if (d->neverupper[i] && d->lam[i]>0.) {
      d->lam[i] = d->neverzero[i] ? -p->dmin : 0.;
    } else if (d->neverlower[i] && d->lam[i]<0.) {
      d->lam[i] = d->neverzero[i] ? p->dmin : 0.;
    }
  }
  casadi_trans(d->nz_a, p->sp_a, d->nz_at, p->sp_at, d->iw);
  d->index = -2;
  d->sign = 0;
  d->r_index = -2;
  d->r_sign = 0;
  d->iter = 0;
  return 0;
}
void casadi_qp_pr(struct casadi_qp_data* d) {
  casadi_int i;
  const struct casadi_qp_prob* p = d->prob;
  d->pr = 0;
  d->ipr = -1;
  for (i=0; i<p->nz; ++i) {
    if (d->z[i] > d->ubz[i]+d->pr) {
      d->pr = d->z[i]-d->ubz[i];
      d->ipr = i;
    } else if (d->z[i] < d->lbz[i]-d->pr) {
      d->pr = d->lbz[i]-d->z[i];
      d->ipr = i;
    }
  }
}
void casadi_qp_du(struct casadi_qp_data* d) {
  casadi_int i;
  const struct casadi_qp_prob* p = d->prob;
  d->du = 0;
  d->idu = -1;
  for (i=0; i<p->nx; ++i) {
    if (d->infeas[i] > d->du) {
      d->du = d->infeas[i];
      d->idu = i;
    } else if (d->infeas[i] < -d->du) {
      d->du = -d->infeas[i];
      d->idu = i;
    }
  }
}
int casadi_qp_du_check(struct casadi_qp_data* d, casadi_int i) {
  casadi_int k;
  casadi_real new_du;
  const casadi_int *at_colind, *at_row;
  const struct casadi_qp_prob* p = d->prob;
  at_colind = p->sp_at + 2;
  at_row = at_colind + p->na + 1;
  if (i<p->nx) {
    new_du = fabs(d->infeas[i]-d->lam[i]);
  } else {
    new_du = 0.;
    for (k=at_colind[i-p->nx]; k<at_colind[i-p->nx+1]; ++k) {
      new_du = casadi_fmax(new_du, fabs(d->infeas[at_row[k]]-d->nz_at[k]*d->lam[i]));
    }
  }
  return new_du <= d->du;
}
void casadi_qp_du_index(struct casadi_qp_data* d) {
  casadi_int i, s;
  casadi_real best_sens;
  const struct casadi_qp_prob* p = d->prob;
  d->index = -1;
  best_sens = -1;
  for (i = 0; i < p->nz; ++i) {
    if (d->sens[i] == 0.) continue;
    if (d->lam[i] == 0) {
      s = d->sens[i] > 0 ? 1 : -1;
      if (s > 0 ? d->neverupper[i] : d->neverlower[i]) continue;
    } else {
      s = 0;
      if (d->neverzero[i]) continue;
      if (d->lam[i] > 0. ? d->sens[i] > 0. : d->sens[i] < 0.) continue;
      if (!casadi_qp_du_check(d, i)) continue;
    }
    if (fabs(d->sens[i]) > best_sens) {
      best_sens = fabs(d->sens[i]);
      d->index = i;
      d->sign = s;
    }
  }
  if (d->index >= 0) {
    if (d->sign > 0) {
      d->msg = "Enforced ubz to reduce |du|";
    } else if (d->sign < 0) {
      d->msg = "Enforced lbz to reduce |du|";
    } else if (d->lam[d->index] > 0) {
      d->msg = "Dropped ubz to reduce |du|";
    } else {
      d->msg = "Dropped lbz to reduce |du|";
    }
    d->msg_ind = d->index;
  }
}
void casadi_qp_pr_index(struct casadi_qp_data* d) {
  if (d->lam[d->ipr] == 0.) {
    if (d->z[d->ipr] < d->lbz[d->ipr]) {
      d->sign = -1;
      d->msg = "Added lbz to reduce |pr|";
    } else {
      d->sign = 1;
      d->msg = "Added ubz to reduce |pr|";
    }
    d->msg_ind = d->ipr;
    d->index = d->ipr;
  } else {
    d->index = -1;
  }
}
void casadi_qp_kkt(struct casadi_qp_data* d) {
  casadi_int i, k;
  const casadi_int *h_colind, *h_row, *a_colind, *a_row, *at_colind, *at_row,
                   *kkt_colind, *kkt_row;
  const struct casadi_qp_prob* p = d->prob;
  a_row = (a_colind = p->sp_a+2) + p->nx + 1;
  at_row = (at_colind = p->sp_at+2) + p->na + 1;
  h_row = (h_colind = p->sp_h+2) + p->nx + 1;
  kkt_row = (kkt_colind = p->sp_kkt+2) + p->nz + 1;
  casadi_clear(d->w, p->nz);
  for (i=0; i<p->nz; ++i) {
    if (i<p->nx) {
      if (d->lam[i]==0) {
        for (k=h_colind[i]; k<h_colind[i+1]; ++k) d->w[h_row[k]] = d->nz_h[k];
        for (k=a_colind[i]; k<a_colind[i+1]; ++k) d->w[p->nx+a_row[k]] = d->nz_a[k];
      } else {
        d->w[i] = 1.;
      }
    } else {
      if (d->lam[i]==0) {
        d->w[i] = -1.;
      } else {
        for (k=at_colind[i-p->nx]; k<at_colind[i-p->nx+1]; ++k) {
          d->w[at_row[k]] = d->nz_at[k];
        }
      }
    }
    for (k=kkt_colind[i]; k<kkt_colind[i+1]; ++k) {
      d->nz_kkt[k] = d->w[kkt_row[k]];
      d->w[kkt_row[k]] = 0;
    }
  }
}
void casadi_qp_kkt_vector(struct casadi_qp_data* d, casadi_real* kkt_i, casadi_int i) {
  casadi_int k;
  const casadi_int *h_colind, *h_row, *a_colind, *a_row, *at_colind, *at_row;
  const struct casadi_qp_prob* p = d->prob;
  a_row = (a_colind = p->sp_a+2) + p->nx + 1;
  at_row = (at_colind = p->sp_at+2) + p->na + 1;
  h_row = (h_colind = p->sp_h+2) + p->nx + 1;
  casadi_clear(kkt_i, p->nz);
  if (i<p->nx) {
    for (k=h_colind[i]; k<h_colind[i+1]; ++k) kkt_i[h_row[k]] = d->nz_h[k];
    for (k=a_colind[i]; k<a_colind[i+1]; ++k) kkt_i[p->nx+a_row[k]] = d->nz_a[k];
  } else {
    for (k=at_colind[i-p->nx]; k<at_colind[i-p->nx+1]; ++k) {
      kkt_i[at_row[k]] = -d->nz_at[k];
    }
  }
  kkt_i[i] -= 1.;
}
casadi_real casadi_qp_kkt_dot(struct casadi_qp_data* d, const casadi_real* v, casadi_int i) {
  casadi_int k;
  const casadi_int *h_colind, *h_row, *a_colind, *a_row, *at_colind, *at_row;
  casadi_real r;
  const struct casadi_qp_prob* p = d->prob;
  a_row = (a_colind = p->sp_a + 2) + p->nx + 1;
  at_row = (at_colind = p->sp_at + 2) + p->na + 1;
  h_row = (h_colind = p->sp_h + 2) + p->nx + 1;
  r = v[i];
  if (i < p->nx) {
    for (k=h_colind[i]; k<h_colind[i+1]; ++k) r -= v[h_row[k]] * d->nz_h[k];
    for (k=a_colind[i]; k<a_colind[i+1]; ++k) r -= v[p->nx+a_row[k]] * d->nz_a[k];
  } else {
    for (k=at_colind[i-p->nx]; k<at_colind[i-p->nx+1]; ++k) {
      r += v[at_row[k]] * d->nz_at[k];
    }
  }
  return r;
}
void casadi_qp_kkt_residual(struct casadi_qp_data* d, casadi_real* r) {
  casadi_int i;
  const struct casadi_qp_prob* p = d->prob;
  for (i=0; i<p->nz; ++i) {
    if (d->lam[i]>0.) {
      r[i] = d->ubz[i]-d->z[i];
    } else if (d->lam[i]<0.) {
      r[i] = d->lbz[i]-d->z[i];
    } else if (i<p->nx) {
      r[i] = d->lam[i]-d->infeas[i];
    } else {
      r[i] = d->lam[i];
    }
  }
}
int casadi_qp_zero_blocking(struct casadi_qp_data* d) {
  casadi_int i;
  casadi_real dz_max = 0;
  const struct casadi_qp_prob* p = d->prob;
  for (i = 0; i < p->nz; ++i) {
    if (d->dz[i] < -dz_max && d->lbz[i] - d->z[i] >= d->epr) {
      dz_max = -d->dz[i];
      d->index = i;
      d->sign = -1;
      d->msg = "lbz violated with zero step";
      d->msg_ind = d->index;
    } else if (d->dz[i] > dz_max && d->z[i] - d->ubz[i] >= d->epr) {
      dz_max = d->dz[i];
      d->index = i;
      d->sign = 1;
      d->msg = "ubz violated with zero step";
      d->msg_ind = d->index;
    }
  }
  return dz_max > 0;
}
void casadi_qp_primal_blocking(struct casadi_qp_data* d) {
  casadi_int i;
  casadi_real trial_z;
  const struct casadi_qp_prob* p = d->prob;
  if (casadi_qp_zero_blocking(d)) {
    d->tau = 0.;
    return;
  }
  for (i = 0; i < p->nz; ++i) {
    if (d->dz[i] == 0.) continue;
    trial_z = d->z[i] + d->tau * d->dz[i];
    if (d->dz[i] < 0 && trial_z < d->lbz[i] - d->epr) {
      d->tau = (d->lbz[i] - d->epr - d->z[i]) / d->dz[i];
      d->index = d->lam[i] < 0. ? -1 : i;
      d->sign = -1;
      d->msg = "Enforcing lbz";
      d->msg_ind = i;
    } else if (d->dz[i] > 0 && trial_z > d->ubz[i] + d->epr) {
      d->tau = (d->ubz[i] + d->epr - d->z[i]) / d->dz[i];
      d->index = d->lam[i] > 0. ? -1 : i;
      d->sign = 1;
      d->msg = "Enforcing ubz";
      d->msg_ind = i;
    }
    if (d->tau <= 0) return;
  }
}
casadi_int casadi_qp_dual_breakpoints(struct casadi_qp_data* d, casadi_real* tau_list,
                                      casadi_int* ind_list, casadi_real tau) {
  casadi_int i, n_tau, loc, next_ind, tmp_ind, j;
  casadi_real trial_lam, new_tau, next_tau, tmp_tau;
  const struct casadi_qp_prob* p = d->prob;
  tau_list[0] = tau;
  ind_list[0] = -1;
  n_tau = 1;
  for (i=0; i<p->nz; ++i) {
    if (d->dlam[i]==0.) continue;
    if (d->lam[i]==0.) continue;
    trial_lam = d->lam[i] + tau*d->dlam[i];
    if (d->lam[i]>0 ? trial_lam>=0 : trial_lam<=0) continue;
    new_tau = -d->lam[i]/d->dlam[i];
    for (loc=0; loc<n_tau-1; ++loc) {
      if (new_tau<tau_list[loc]) break;
    }
    n_tau++;
    next_tau=new_tau;
    next_ind=i;
    for (j=loc; j<n_tau; ++j) {
      tmp_tau = tau_list[j];
      tau_list[j] = next_tau;
      next_tau = tmp_tau;
      tmp_ind = ind_list[j];
      ind_list[j] = next_ind;
      next_ind = tmp_ind;
    }
  }
  return n_tau;
}
casadi_int casadi_qp_dual_blocking(struct casadi_qp_data* d) {
  casadi_int i, n_tau, j, k, du_index;
  casadi_real tau_k, dtau, new_infeas, tau1, infeas, tinfeas;
  const casadi_int *at_colind, *at_row;
  const struct casadi_qp_prob* p = d->prob;
  at_row = (at_colind = p->sp_at+2) + p->na + 1;
  n_tau = casadi_qp_dual_breakpoints(d, d->w, d->iw, d->tau);
  du_index = -1;
  tau_k = 0.;
  for (j=0; j<n_tau; ++j) {
    dtau = d->w[j] - tau_k;
    for (k=0; k<p->nx; ++k) {
      infeas  = d->infeas[k];
      tinfeas  = d->tinfeas[k];
      if (fabs(tinfeas)<1e-14) {
        continue;
      } else if (tinfeas<0) {
        infeas *= -1;
        tinfeas *= -1;
      }
      new_infeas = infeas + dtau*tinfeas;
      if (new_infeas > d->edu) {
        tau1 = casadi_fmax(tau_k, tau_k + (d->edu - infeas)/tinfeas);
        if (tau1 < d->tau) {
          d->tau = tau1;
          du_index = k;
        }
      }
    }
    casadi_axpy(p->nx, casadi_fmin(d->tau - tau_k, dtau), d->tinfeas, d->infeas);
    if (du_index>=0) return du_index;
    tau_k = d->w[j];
    i = d->iw[j];
    if (i<0) break;
    if (!d->neverzero[i]) {
      if (i<p->nx) {
        d->tinfeas[i] -= d->dlam[i];
      } else {
        for (k=at_colind[i-p->nx]; k<at_colind[i-p->nx+1]; ++k) {
          d->tinfeas[at_row[k]] -= d->nz_at[k]*d->dlam[i];
        }
      }
    }
  }
  return du_index;
}
void casadi_qp_take_step(struct casadi_qp_data* d) {
  casadi_int i;
  const struct casadi_qp_prob* p = d->prob;
  for (i=0; i<p->nz; ++i) d->iw[i] = d->lam[i]>0. ? 1 : d->lam[i]<0 ? -1 : 0;
  casadi_axpy(p->nz, d->tau, d->dz, d->z);
  casadi_axpy(p->nz, d->tau, d->dlam, d->lam);
  for (i=0; i<p->nz; ++i) {
    if (d->neverzero[i] && (d->iw[i]<0 ? d->lam[i]>0 : d->lam[i]<0)) {
      d->iw[i]=-d->iw[i];
    }
    switch (d->iw[i]) {
      case -1: d->lam[i] = casadi_fmin(d->lam[i], -p->dmin); break;
      case  1: d->lam[i] = casadi_fmax(d->lam[i],  p->dmin); break;
      case  0: d->lam[i] = 0.; break;
    }
  }
}
int casadi_qp_flip_check(struct casadi_qp_data* d) {
  const struct casadi_qp_prob* p = d->prob;
  casadi_qp_kkt_vector(d, d->dlam, d->index);
  if (d->sign == 0) casadi_scal(p->nz, -1., d->dlam);
  casadi_qr_solve(d->dlam, 1, 0, p->sp_v, d->nz_v, p->sp_r, d->nz_r, d->beta,
    p->prinv, p->pc, d->w);
  if (fabs(d->dlam[d->index]-1.) >= 1e-12) return 0;
  casadi_clear(d->dz, p->nz);
  d->dz[d->index] = 1;
  casadi_qr_solve(d->dz, 1, 1, p->sp_v, d->nz_v, p->sp_r, d->nz_r, d->beta,
    p->prinv, p->pc, d->w);
  casadi_scal(p->nz, 1./sqrt(casadi_dot(p->nz, d->dlam, d->dlam)), d->dlam);
  casadi_scal(p->nz, 1./sqrt(casadi_dot(p->nz, d->dz, d->dz)), d->dz);
  return 1;
}
void casadi_qp_factorize(struct casadi_qp_data* d) {
  const struct casadi_qp_prob* p = d->prob;
  if (d->has_search_dir) {
    d->sing = 1;
    return;
  }
  casadi_qp_kkt(d);
  casadi_qr(p->sp_kkt, d->nz_kkt, d->w, p->sp_v, d->nz_v, p->sp_r,
            d->nz_r, d->beta, p->prinv, p->pc);
  d->sing = casadi_qr_singular(&d->mina, &d->imina, d->nz_r, p->sp_r, p->pc, 1e-12);
}
void casadi_qp_expand_step(struct casadi_qp_data* d) {
  casadi_int i;
  const struct casadi_qp_prob* p = d->prob;
  casadi_clear(d->dlam, p->nx);
  casadi_mv(d->nz_h, p->sp_h, d->dz, d->dlam, 0);
  casadi_mv(d->nz_a, p->sp_a, d->dz + p->nx, d->dlam, 1);
  casadi_scal(p->nx, -1., d->dlam);
  for (i = 0; i < p->nx; ++i) if (d->lam[i] == 0.) d->dlam[i] = 0.;
  casadi_copy(d->dz+p->nx, p->na, d->dlam + p->nx);
  casadi_clear(d->dz + p->nx, p->na);
  casadi_mv(d->nz_a, p->sp_a, d->dz, d->dz + p->nx, 0);
  for (i = 0; i < p->nz; ++i) if (fabs(d->dz[i]) < 1e-14) d->dz[i] = 0.;
  casadi_clear(d->tinfeas, p->nx);
  casadi_mv(d->nz_h, p->sp_h, d->dz, d->tinfeas, 0);
  casadi_mv(d->nz_a, p->sp_a, d->dlam + p->nx, d->tinfeas, 1);
  casadi_axpy(p->nx, 1., d->dlam, d->tinfeas);
}
int casadi_qp_pr_direction(struct casadi_qp_data* d) {
  casadi_int i;
  const struct casadi_qp_prob* p = d->prob;
  for (i=0; i<p->nz; ++i) {
    if (d->lbz[i] - d->z[i] >= d->epr) {
      if (d->dz[i] < 0 || d->dlam[i] > 0) return 1;
    } else if (d->z[i] - d->ubz[i] >= d->epr) {
      if (d->dz[i] > 0 || d->dlam[i] < 0) return 1;
    }
  }
  return 0;
}
int casadi_qp_du_direction(struct casadi_qp_data* d) {
  casadi_int i;
  const struct casadi_qp_prob* p = d->prob;
  for (i=0; i<p->nx; ++i) {
    if (d->infeas[i] <= -d->edu && d->tinfeas[i] < -1e-12) {
      return 1;
    } else if (d->infeas[i] >= d->edu && d->tinfeas[i] > 1e-12) {
      return 1;
    }
  }
  return 0;
}
int casadi_qp_enforceable(struct casadi_qp_data* d, casadi_int i, casadi_int s) {
  casadi_int k;
  const casadi_int *at_colind, *at_row;
  const struct casadi_qp_prob* p = d->prob;
  if (fabs(d->infeas[i]) < d->edu) return 1;
  at_colind = p->sp_at + 2;
  at_row = at_colind + p->na + 1;
  if (i<p->nx) {
    return (s < 0) == (d->infeas[i] > 0);
  } else {
    for (k=at_colind[i-p->nx]; k<at_colind[i-p->nx+1]; ++k) {
      if (d->nz_at[k] > 0) {
        if ((s > 0) == (d->infeas[at_row[k]] > 0)) return 0;
      } else if (d->nz_at[k] < 0) {
        if ((s < 0) == (d->infeas[at_row[k]] > 0)) return 0;
      }
    }
    return 1;
  }
}
int casadi_qp_singular_step(struct casadi_qp_data* d) {
  casadi_real tau_test, tau;
  casadi_int nnz_kkt, nk, k, i, best_k, best_neg, neg;
  const struct casadi_qp_prob* p = d->prob;
  for (i = 0; i < p->nz; ++i) d->lincomb[i] = 0;
  for (k = 0; k < d->sing; ++k) {
    if (!d->has_search_dir) {
      casadi_qr_colcomb(d->dlam, d->nz_r, p->sp_r, p->pc, 1e-12, k);
    }
    for (i = 0; i < p->nz; ++i) if (fabs(d->dlam[i]) >= 1e-12) d->lincomb[i]++;
  }
  if (d->has_search_dir) {
    nk = 1;
  } else {
    casadi_trans(d->nz_kkt, p->sp_kkt, d->nz_v, p->sp_kkt, d->iw);
    nnz_kkt = p->sp_kkt[2+p->nz];
    casadi_copy(d->nz_v, nnz_kkt, d->nz_kkt);
    casadi_qr(p->sp_kkt, d->nz_kkt, d->w, p->sp_v, d->nz_v, p->sp_r, d->nz_r,
              d->beta, p->prinv, p->pc);
    nk = casadi_qr_singular(0, 0, d->nz_r, p->sp_r, p->pc, 1e-12);
  }
  best_k = best_neg = -1;
  tau = p->inf;
  for (k=0; k<nk; ++k) {
    if (!d->has_search_dir) {
      casadi_qr_colcomb(d->dz, d->nz_r, p->sp_r, p->pc, 1e-12, k);
    }
    for (i=0; i<p->nz; ++i) {
      d->iw[i] = d->lincomb[i] && fabs(casadi_qp_kkt_dot(d, d->dz, i)) > 1e-12;
    }
    casadi_qp_expand_step(d);
    for (neg = 0; neg < 2; ++neg) {
      if (neg) {
        casadi_scal(p->nz, -1., d->dz);
        casadi_scal(p->nz, -1., d->dlam);
        casadi_scal(p->nx, -1., d->tinfeas);
      }
      if (casadi_qp_pr_direction(d)) continue;
      if (casadi_qp_du_direction(d)) continue;
      for (i=0; i<p->nz; ++i) {
        if (!d->iw[i]) continue;
        if (d->lam[i]==0.) {
          if (d->z[i] <= d->ubz[i] && (d->z[i] >= d->lbz[i] ?
              d->dz[i] < -1e-12 : d->dz[i] > 1e-12)) {
            if (!d->neverlower[i]
                && (tau_test = (d->lbz[i] - d->z[i]) / d->dz[i]) < tau
                && casadi_qp_enforceable(d, i, -1)) {
              tau = tau_test;
              d->r_index = i;
              d->r_sign = -1;
              best_k = k;
              best_neg = neg;
            }
          } else if (d->z[i] >= d->lbz[i] && (d->z[i] <= d->ubz[i] ?
              d->dz[i] > 1e-12 : d->dz[i] < -1e-12)) {
            if (!d->neverupper[i]
                && (tau_test = (d->ubz[i] - d->z[i]) / d->dz[i]) < tau
                && casadi_qp_enforceable(d, i, 1)) {
              tau = tau_test;
              d->r_index = i;
              d->r_sign = 1;
              best_k = k;
              best_neg = neg;
            }
          }
        } else if (!d->neverzero[i]) {
          if (d->lam[i] > 0 ? d->dlam[i] < -1e-12 : d->dlam[i] > 1e-12) {
            if ((tau_test = -d->lam[i] / d->dlam[i]) < tau) {
              tau = tau_test;
              d->r_index = i;
              d->r_sign = 0;
              best_k = k;
              best_neg = neg;
            }
          }
        }
      }
    }
  }
  if (d->r_index < 0) return 1;
  if (--k != best_k) {
    casadi_qr_colcomb(d->dz, d->nz_r, p->sp_r, p->pc, 1e-12, best_k);
    casadi_qp_expand_step(d);
    if (best_neg) tau *= -1;
  } else if (--neg != best_neg) {
    tau *= -1;
  }
  casadi_scal(p->nz, tau, d->dz);
  casadi_scal(p->nz, tau, d->dlam);
  casadi_scal(p->nx, tau, d->tinfeas);
  return 0;
}
int casadi_qp_calc_step(struct casadi_qp_data* d) {
  const struct casadi_qp_prob* p = d->prob;
  d->r_index = -1;
  d->r_sign = 0;
  if (d->sing) return casadi_qp_singular_step(d);
  casadi_qp_kkt_residual(d, d->dz);
  casadi_qr_solve(d->dz, 1, 1, p->sp_v, d->nz_v, p->sp_r, d->nz_r, d->beta,
                  p->prinv, p->pc, d->w);
  casadi_qp_expand_step(d);
  return 0;
}
void casadi_qp_calc_sens(struct casadi_qp_data* d, casadi_int i) {
  const struct casadi_qp_prob* p = d->prob;
  casadi_clear(d->sens, p->nz);
  if (i >= 0) {
    d->sens[i] = d->infeas[i] > 0 ? -1. : 1.;
    casadi_mv(d->nz_a, p->sp_a, d->sens, d->sens + p->nx, 0);
  }
}
void casadi_qp_calc_dependent(struct casadi_qp_data* d) {
  casadi_int i;
  casadi_real r;
  const struct casadi_qp_prob* p = d->prob;
  d->f = casadi_bilin(d->nz_h, p->sp_h, d->z, d->z)/2.
       + casadi_dot(p->nx, d->z, d->g);
  casadi_clear(d->z+p->nx, p->na);
  casadi_mv(d->nz_a, p->sp_a, d->z, d->z+p->nx, 0);
  casadi_copy(d->g, p->nx, d->infeas);
  casadi_mv(d->nz_h, p->sp_h, d->z, d->infeas, 0);
  casadi_mv(d->nz_a, p->sp_a, d->lam+p->nx, d->infeas, 1);
  for (i=0; i<p->nx; ++i) {
    if (d->lam[i]==0) continue;
    r = -d->infeas[i];
    if (d->lam[i]>0) {
      if (d->neverzero[i] && !d->neverlower[i]) {
        d->lam[i] = r==0 ? p->dmin : r;
      } else {
        d->lam[i] = casadi_fmax(r, p->dmin);
      }
    } else {
      if (d->neverzero[i] && !d->neverupper[i]) {
        d->lam[i] = r==0 ? -p->dmin : r;
      } else {
        d->lam[i] = casadi_fmin(r, -p->dmin);
      }
    }
    d->infeas[i] += d->lam[i];
  }
  casadi_qp_pr(d);
  casadi_qp_du(d);
  d->epr = casadi_fmax(d->pr, (0.5 * p->constr_viol_tol / p->dual_inf_tol) * d->du);
  d->edu = casadi_fmax(d->du, (0.5 * p->dual_inf_tol / p->constr_viol_tol) * d->pr);
  casadi_qp_calc_sens(d, d->idu);
}
void casadi_qp_linesearch(struct casadi_qp_data* d) {
  casadi_int du_index;
  d->sign = 0;
  d->index = -1;
  d->tau = 1.;
  casadi_qp_primal_blocking(d);
  du_index = casadi_qp_dual_blocking(d);
  casadi_qp_take_step(d);
  if (du_index >= 0) {
    casadi_qp_calc_sens(d, du_index);
    casadi_qp_du_index(d);
  }
}
void casadi_qp_flip(struct casadi_qp_data* d) {
  const struct casadi_qp_prob* p = d->prob;
  if (d->index == -1 && d->r_index >= 0) {
    if (d->r_sign != 0 || casadi_qp_du_check(d, d->r_index)) {
      d->index = d->r_index;
      d->sign = d->r_sign;
      if (d->sign > 0) {
        d->msg = "Enforced ubz for regularity";
      } else if (d->sign < 0) {
        d->msg = "Enforced lbz for regularity";
      } else if (d->lam[d->index] > 0) {
        d->msg = "Dropped ubz for regularity";
      } else {
        d->msg = "Dropped lbz for regularity";
      }
      d->msg_ind = d->index;
    }
  }
  if (!d->sing && d->index == -1) {
    if (d->pr * p->dual_inf_tol >= p->constr_viol_tol * d->du) {
      if (d->pr >= p->constr_viol_tol) casadi_qp_pr_index(d);
    } else {
      if (d->du >= p->dual_inf_tol) casadi_qp_du_index(d);
    }
  }
  d->has_search_dir = 0;
  if (d->index >= 0) {
    if (!d->sing) d->has_search_dir = casadi_qp_flip_check(d);
    d->lam[d->index] = d->sign==0 ? 0 : d->sign > 0 ? p->dmin : -p->dmin;
    casadi_qp_calc_dependent(d);
  }
}
int casadi_qp_prepare(struct casadi_qp_data* d) {
  const struct casadi_qp_prob* p = d->prob;
  casadi_qp_calc_dependent(d);
  casadi_qp_flip(d);
  casadi_qp_factorize(d);
  if (!d->sing && d->index == -1) {
    d->status = QP_SUCCESS;
    d->msg = "Converged";
    d->msg_ind = -2;
    return 1;
  } else if (d->iter >= p->max_iter) {
    d->status = QP_MAX_ITER;
    d->msg = "Max iter";
    d->msg_ind = -2;
    return 1;
  } else if (!d->sing && d->ipr < 0 && d->idu < 0) {
    d->status = QP_SUCCESS;
    d->msg = "No primal or dual error";
    d->msg_ind = -2;
    return 1;
  } else {
    return 0;
  }
}
int casadi_qp_iterate(struct casadi_qp_data* d) {
  d->msg = 0;
  d->iter++;
  if (casadi_qp_calc_step(d)) {
    d->status = QP_NO_SEARCH_DIR;
    return 1;
  }
  casadi_qp_linesearch(d);
  return 0;
}
#ifndef CASADI_PRINTF
int casadi_qp_print_header(struct casadi_qp_data* d, char* buf, size_t buf_sz) {
  int flag;
  flag = snprintf(buf, buf_sz, "%5s %5s %9s %9s %5s %9s %5s %9s %5s %9s  %4s",
          "Iter", "Sing", "fk", "|pr|", "con", "|du|", "var",
          "min_R", "con", "last_tau", "Note");
  if (flag < 0) {
    d->status = QP_PRINTING_ERROR;
    return 1;
  }
  return 0;
}
int casadi_qp_print_colcomb(struct casadi_qp_data* d, char* buf, size_t buf_sz, casadi_int j) {
  casadi_int num_size, n_print, i, k, buf_offset, val;
  size_t b;
  const struct casadi_qp_prob* p = d->prob;
  casadi_qr_colcomb(d->dlam, d->nz_r, p->sp_r, p->pc, 1e-12, j);
  num_size = 1;
  val = p->nz-1;
  while (val) {
    val/=10;
    num_size++;
  }
  if (buf_sz<=4) return 1;
  n_print = (buf_sz-4)/num_size;
  for (b=0;b<buf_sz;++b) buf[b]=' ';
  buf_offset = 0;
  for (i=0;i<p->nz;++i) {
    if (fabs(d->dlam[i]) >= 1e-12) {
      if (n_print==0) {
        buf[buf_sz-4] = '.';
        buf[buf_sz-3] = '.';
        buf[buf_sz-2] = '.';
        buf[buf_sz-1] = '\0';
        return 1;
      }
      n_print--;
      snprintf(buf+buf_offset, num_size, "%d", (int) (i));
      for (k=0;k<num_size;++k) {
        if (buf[buf_offset+k]=='\0') buf[buf_offset+k] = ' ';
      }
      buf_offset += num_size;
    }
  }
  buf[buf_sz-1] = '\0';
  return 0;
}
int casadi_qp_print_iteration(struct casadi_qp_data* d, char* buf, int buf_sz) {
  int flag;
  flag = snprintf(buf, buf_sz,
    "%5d %5d %9.2g %9.2g %5d %9.2g %5d %9.2g %5d %9.2g  ",
    (int) (d->iter), (int) (d->sing), d->f, d->pr,
    (int) (d->ipr), d->du, (int) (d->idu),
    d->mina, (int) (d->imina), d->tau);
  if (flag < 0) {
    d->status = QP_PRINTING_ERROR;
    return 1;
  }
  buf += flag;
  buf_sz -= flag;
  if (d->msg) {
    if (d->msg_ind > -2) {
      flag = snprintf(buf, buf_sz, "%s, i=%d", d->msg, (int) (d->msg_ind));
    } else {
      flag = snprintf(buf, buf_sz, "%s", d->msg);
    }
    if (flag < 0) {
      d->status = QP_PRINTING_ERROR;
      return 1;
    }
  }
  return 0;
}
#endif

#ifndef casadi_nan
  #define casadi_nan NAN
#endif

struct casadi_nlpsol_prob {
  casadi_int nx, ng, np;
};
struct casadi_nlpsol_data {
  const struct casadi_nlpsol_prob* prob;
  casadi_real *lbz, *ubz;
  const casadi_real *p;
  casadi_real *z;
  casadi_real *lam, *lam_p;
  casadi_real f;
};
void casadi_nlpsol_work(const struct casadi_nlpsol_prob* p, casadi_int* sz_iw, casadi_int* sz_w) {
  *sz_w = *sz_iw = 0;
  *sz_w += p->nx + p->ng;
  *sz_w += p->nx + p->ng;
  *sz_w += p->nx + p->ng;
  *sz_w += p->nx + p->ng;
  *sz_w += p->np;
}
void casadi_nlpsol_init(struct casadi_nlpsol_data* d, casadi_int** iw, casadi_real** w) {
  casadi_int nx, ng, np;
  const struct casadi_nlpsol_prob* p = d->prob;
  nx = p->nx;
  ng = p->ng;
  np = p->np;
  d->z = *w; *w += nx + ng;
  d->lbz = *w; *w += nx + ng;
  d->ubz = *w; *w += nx + ng;
  d->lam = *w; *w += nx + ng;
  d->lam_p = *w; *w += np;
}

struct casadi_sqpmethod_prob {
  const struct casadi_nlpsol_prob* nlp;
  const casadi_int *sp_h, *sp_a, *sp_hr;
  casadi_int merit_memsize;
  casadi_int max_iter_ls;
  casadi_int sz_w_cvx;
  casadi_int sz_iw_cvx;
};
struct casadi_sqpmethod_data {
  const struct casadi_sqpmethod_prob* prob;
  casadi_real* z_cand;
  casadi_real *gLag, *gLag_old;
  casadi_real *gf;
  casadi_real *lbdz, *ubdz;
  casadi_real *dx, *dlam;
  casadi_real *Bk;
  casadi_real *Brk;
  casadi_real *Bproj;
  casadi_real* Jk;
  casadi_real* w_cvx;
  casadi_int* iw_cvx;
  casadi_real* merit_mem;
};
void casadi_sqpmethod_work(const struct casadi_sqpmethod_prob* p,
    casadi_int* sz_iw, casadi_int* sz_w) {
  casadi_int nnz_h, nnz_hr, nnz_a, nx, ng;
  nnz_h = p->sp_h[2+p->sp_h[1]];
  nnz_hr = p->sp_hr[2+p->sp_hr[1]];
  nnz_a = p->sp_a[2+p->sp_a[1]];
  nx = p->nlp->nx;
  ng = p->nlp->ng;
  *sz_w = *sz_iw = 0;
  if (p->max_iter_ls>0) *sz_w += nx + ng;
  *sz_w += nx;
  *sz_w += nx;
  *sz_w += nx;
  *sz_w += nx + ng;
  *sz_w += nx + ng;
  *sz_w += nx;
  *sz_w += nx + ng;
  *sz_w += nnz_h;
  *sz_w += nnz_hr;
  *sz_w += nx;
  *sz_w += nnz_a;
  *sz_w += p->sz_w_cvx;
  *sz_iw += p->sz_iw_cvx;
  if (p->max_iter_ls>0) *sz_w += p->merit_memsize;
}
void casadi_sqpmethod_init(struct casadi_sqpmethod_data* d, casadi_int** iw, casadi_real** w) {
  casadi_int nnz_h, nnz_hr, nnz_a, nx, ng;
  const struct casadi_sqpmethod_prob* p = d->prob;
  nnz_h = p->sp_h[2+p->sp_h[1]];
  nnz_hr = p->sp_hr[2+p->sp_hr[1]];
  nnz_a = p->sp_a[2+p->sp_a[1]];
  nx = p->nlp->nx;
  ng = p->nlp->ng;
  if (p->max_iter_ls>0) {
    d->z_cand = *w;
    *w += nx + ng;
  }
  d->gLag = *w; *w += nx;
  d->gLag_old = *w; *w += nx;
  d->gf = *w; *w += nx;
  d->lbdz = *w; *w += nx + ng;
  d->ubdz = *w; *w += nx + ng;
  d->dx = *w; *w += nx;
  d->dlam = *w; *w += nx + ng;
  d->Bk = *w; *w += nnz_h;
  d->Brk = *w; *w += nnz_hr;
  d->Bproj = *w; *w += nx;
  d->Jk = *w; *w += nnz_a;
  d->w_cvx = *w; *w += p->sz_w_cvx;
  d->iw_cvx = *iw; *iw += p->sz_iw_cvx;
  if (p->max_iter_ls>0) {
    d->merit_mem = *w;
    *w += p->merit_memsize;
  }
}

casadi_real casadi_max_viol(casadi_int n, const casadi_real* x, const casadi_real* lb, const casadi_real* ub) {
  casadi_real r;
  casadi_int i;
  const casadi_real zero = 0;
  r = 0;
  for (i=0; i<n; ++i) {
    casadi_real x_i, lb_i, ub_i;
    x_i = x ? *x++ : zero;
    lb_i = lb ? *lb++ : zero;
    ub_i = ub ? *ub++ : zero;
    r = fmax(r, fmax(x_i-ub_i, zero));
    r = fmax(r, fmax(lb_i-x_i, zero));
  }
  return r;
}

casadi_real casadi_norm_inf(casadi_int n, const casadi_real* x) {
  casadi_int i;
  casadi_real ret = 0;
  for (i=0; i<n; ++i) ret = casadi_fmax(ret, fabs(*x++));
  return ret;
}

casadi_real casadi_sum_viol(casadi_int n, const casadi_real* x, const casadi_real* lb, const casadi_real* ub) {
  casadi_real r;
  casadi_int i;
  const casadi_real zero = 0;
  r = 0;
  for (i=0; i<n; ++i) {
    casadi_real x_i, lb_i, ub_i;
    x_i = x ? *x++ : zero;
    lb_i = lb ? *lb++ : zero;
    ub_i = ub ? *ub++ : zero;
    r += fmax(x_i-ub_i, zero);
    r += fmax(lb_i-x_i, zero);
  }
  return r;
}

#ifdef MATLAB_MEX_FILE
casadi_real* casadi_from_mex(const mxArray* p, casadi_real* y, const casadi_int* sp, casadi_real* w) {
  casadi_int nrow, ncol, nnz, is_sparse, c, k;
  const casadi_int *colind, *row;
  size_t p_nrow, p_ncol;
  mwIndex *Jc, *Ir;
  const double* p_data;
  if (!mxIsDouble(p) || mxGetNumberOfDimensions(p)!=2)
    mexErrMsgIdAndTxt("Casadi:RuntimeError",
      "\"from_mex\" failed: Not a two-dimensional matrix of double precision.");
  nrow = *sp++;
  ncol = *sp++;
  nnz = sp[ncol];
  colind = sp;
  row = sp+ncol+1;
  p_nrow = mxGetM(p);
  p_ncol = mxGetN(p);
  is_sparse = mxIsSparse(p);
  if (is_sparse) {
#ifndef CASADI_MEX_NO_SPARSE
    Jc = mxGetJc(p);
    Ir = mxGetIr(p);
#else /* CASADI_MEX_NO_SPARSE */
    mexErrMsgIdAndTxt("Casadi:RuntimeError",
      "\"from_mex\" failed: Sparse inputs disabled.");
#endif /* CASADI_MEX_NO_SPARSE */
  }
  p_data = (const double*)mxGetData(p);
  if (p_nrow==1 && p_ncol==1) {
    double v = is_sparse && Jc[1]==0 ? 0 : *p_data;
    casadi_fill(y, nnz, v);
  } else {
    casadi_int tr = 0;
    if (nrow!=p_nrow || ncol!=p_ncol) {
      tr = nrow==p_ncol && ncol==p_nrow && (nrow==1 || ncol==1);
      if (!tr) mexErrMsgIdAndTxt("Casadi:RuntimeError",
                                 "\"from_mex\" failed: Dimension mismatch.");
    }
    if (is_sparse) {
      if (tr) {
        for (c=0; c<ncol; ++c)
          for (k=colind[c]; k<colind[c+1]; ++k) w[row[k]+c*nrow]=0;
        for (c=0; c<p_ncol; ++c)
          for (k=Jc[c]; k<Jc[c+1]; ++k) w[c+Ir[k]*p_ncol] = p_data[k];
        for (c=0; c<ncol; ++c)
          for (k=colind[c]; k<colind[c+1]; ++k) y[k] = w[row[k]+c*nrow];
      } else {
        for (c=0; c<ncol; ++c) {
          for (k=colind[c]; k<colind[c+1]; ++k) w[row[k]]=0;
          for (k=Jc[c]; k<Jc[c+1]; ++k) w[Ir[k]]=p_data[k];
          for (k=colind[c]; k<colind[c+1]; ++k) y[k]=w[row[k]];
        }
      }
    } else {
      for (c=0; c<ncol; ++c) {
        for (k=colind[c]; k<colind[c+1]; ++k) {
          y[k] = p_data[row[k]+c*nrow];
        }
      }
    }
  }
  return y;
}

#endif

#define casadi_to_double(x) ((double) x)

#ifdef MATLAB_MEX_FILE
mxArray* casadi_to_mex(const casadi_int* sp, const casadi_real* x) {
  casadi_int nrow, ncol, nnz, c, k;
  const casadi_int *colind, *row;
  mxArray *p;
  double *d;
#ifndef CASADI_MEX_NO_SPARSE
  casadi_int i;
  mwIndex *j;
#endif /* CASADI_MEX_NO_SPARSE */
  nrow = *sp++;
  ncol = *sp++;
  nnz = sp[ncol];
  colind = sp;
  row = sp+ncol+1;
#ifndef CASADI_MEX_NO_SPARSE
  if (nnz!=nrow*ncol) {
    p = mxCreateSparse(nrow, ncol, nnz, mxREAL);
    for (i=0, j=mxGetJc(p); i<=ncol; ++i) *j++ = *colind++;
    for (i=0, j=mxGetIr(p); i<nnz; ++i) *j++ = *row++;
    if (x) {
      d = (double*)mxGetData(p);
      for (i=0; i<nnz; ++i) *d++ = casadi_to_double(*x++);
    }
    return p;
  }
#endif /* CASADI_MEX_NO_SPARSE */
  p = mxCreateDoubleMatrix(nrow, ncol, mxREAL);
  if (x) {
    d = (double*)mxGetData(p);
    for (c=0; c<ncol; ++c) {
      for (k=colind[c]; k<colind[c+1]; ++k) {
        d[row[k]+c*nrow] = casadi_to_double(*x++);
      }
    }
  }
  return p;
}

#endif

static const casadi_int casadi_s0[6] = {1, 2, 0, 0, 1, 0};
static const casadi_int casadi_s1[6] = {1, 2, 0, 1, 1, 0};
static const casadi_int casadi_s2[6] = {1, 4, 7, 10, 11, 12};
static const casadi_int casadi_s3[6] = {0, 2, 6, 8, 13, 15};
static const casadi_int casadi_s4[5] = {3, 5, 9, 14, 16};
static const casadi_int casadi_s5[27] = {11, 7, 0, 2, 4, 6, 9, 12, 15, 17, 1, 4, 2, 5, 3, 6, 0, 1, 7, 1, 2, 8, 2, 3, 9, 3, 10};
static const casadi_int casadi_s6[31] = {7, 11, 0, 1, 4, 7, 10, 11, 12, 13, 14, 15, 16, 17, 3, 0, 3, 4, 1, 4, 5, 2, 5, 6, 0, 1, 2, 3, 4, 5, 6};
static const casadi_int casadi_s7[16] = {7, 7, 0, 1, 2, 3, 4, 5, 6, 6, 0, 1, 2, 3, 4, 5};
static const casadi_int casadi_s8[73] = {18, 18, 0, 3, 6, 9, 13, 17, 21, 24, 26, 30, 34, 38, 40, 42, 44, 46, 48, 50, 52, 0, 8, 11, 1, 9, 12, 2, 10, 13, 3, 7, 8, 14, 4, 8, 9, 15, 5, 9, 10, 16, 6, 10, 17, 3, 7, 0, 3, 4, 8, 1, 4, 5, 9, 2, 5, 6, 10, 0, 11, 1, 12, 2, 13, 3, 14, 4, 15, 5, 16, 6, 17};
static const casadi_int casadi_s9[56] = {18, 18, 0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 35, 0, 1, 1, 16, 2, 3, 3, 13, 4, 10, 5, 6, 6, 7, 7, 10, 8, 9, 9, 10, 10, 13, 11, 12, 12, 13, 13, 16, 14, 15, 15, 16, 16, 17, 17};
static const casadi_int casadi_s10[78] = {18, 18, 0, 1, 3, 4, 6, 7, 8, 10, 13, 14, 20, 26, 27, 34, 40, 41, 48, 51, 57, 0, 0, 1, 2, 2, 3, 4, 5, 5, 6, 4, 6, 7, 8, 4, 5, 6, 7, 8, 9, 3, 6, 7, 8, 9, 10, 11, 2, 3, 8, 9, 10, 11, 12, 1, 3, 10, 11, 12, 13, 14, 0, 1, 11, 12, 13, 14, 15, 14, 15, 16, 1, 13, 14, 15, 16, 17};
static const casadi_int casadi_s11[18] = {0, 2, 4, 14, 11, 8, 5, 15, 16, 13, 7, 1, 3, 10, 17, 12, 9, 6};
static const casadi_int casadi_s12[18] = {11, 0, 12, 1, 13, 17, 6, 2, 16, 10, 5, 15, 9, 4, 7, 8, 14, 3};
static const casadi_int casadi_s13[23] = {1, 10, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
static const casadi_int casadi_s14[11] = {1, 4, 0, 1, 2, 3, 4, 0, 0, 0, 0};

/* f:(i0,i1,i2)->(o0) */
static int casadi_f3(const casadi_real** arg, casadi_real** res, casadi_int* iw, casadi_real* w, int mem) {
  casadi_real a0, a1, a2, a3;
  a0=1.8500000000000000e+001;
  a1=arg[1]? arg[1][0] : 0;
  a0=(a0*a1);
  a1=3.5399999999999998e-001;
  a0=(a0/a1);
  a1=1.8540900000000001e+003;
  a0=(a0-a1);
  a1=1.7180625000000000e+000;
  a2=arg[0]? arg[0][0] : 0;
  a2=casadi_sq(a2);
  a1=(a1*a2);
  a0=(a0-a1);
  a1=20601.;
  a2=arg[2]? arg[2][0] : 0;
  a3=100.;
  a2=(a2/a3);
  a2=atan(a2);
  a2=sin(a2);
  a1=(a1*a2);
  a0=(a0-a1);
  a1=2.6783496966726939e+003;
  a0=(a0/a1);
  if (res[0]!=0) res[0][0]=a0;
  return 0;
}

/* nlp_fg:(x[7],p[10])->(f,g[11]) */
static int casadi_f2(const casadi_real** arg, casadi_real** res, casadi_int* iw, casadi_real* w, int mem) {
  casadi_real **res1=res+2, *rr, *ss;
  const casadi_real **arg1=arg+2;
  casadi_real w0, *w1=w+5, w2, *w3=w+10, w4, *w5=w+21, w6, w7, w8, w9;
  /* #0: @0 = 10 */
  w0 = 10.;
  /* #1: @1 = input[0][1] */
  casadi_copy(arg[0] ? arg[0]+3 : 0, 4, w1);
  /* #2: @2 = @1[0] */
  for (rr=(&w2), ss=w1+0; ss!=w1+1; ss+=1) *rr++ = *ss;
  /* #3: @3 = input[1][0] */
  casadi_copy(arg[1], 10, w3);
  /* #4: @4 = @3[1] */
  for (rr=(&w4), ss=w3+1; ss!=w3+2; ss+=1) *rr++ = *ss;
  /* #5: @4 = (@2-@4) */
  w4  = (w2-w4);
  /* #6: @0 = (@0*@4) */
  w0 *= w4;
  /* #7: @4 = @3[1] */
  for (rr=(&w4), ss=w3+1; ss!=w3+2; ss+=1) *rr++ = *ss;
  /* #8: @2 = (@2-@4) */
  w2 -= w4;
  /* #9: @0 = (@0*@2) */
  w0 *= w2;
  /* #10: @2 = 0.001 */
  w2 = 1.0000000000000000e-003;
  /* #11: @5 = input[0][0] */
  casadi_copy(arg[0], 3, w5);
  /* #12: @4 = @5[0] */
  for (rr=(&w4), ss=w5+0; ss!=w5+1; ss+=1) *rr++ = *ss;
  /* #13: @6 = @3[2] */
  for (rr=(&w6), ss=w3+2; ss!=w3+3; ss+=1) *rr++ = *ss;
  /* #14: @6 = (@4-@6) */
  w6  = (w4-w6);
  /* #15: @2 = (@2*@6) */
  w2 *= w6;
  /* #16: @6 = @3[2] */
  for (rr=(&w6), ss=w3+2; ss!=w3+3; ss+=1) *rr++ = *ss;
  /* #17: @4 = (@4-@6) */
  w4 -= w6;
  /* #18: @2 = (@2*@4) */
  w2 *= w4;
  /* #19: @0 = (@0+@2) */
  w0 += w2;
  /* #20: @2 = 10 */
  w2 = 10.;
  /* #21: @4 = @1[1] */
  for (rr=(&w4), ss=w1+1; ss!=w1+2; ss+=1) *rr++ = *ss;
  /* #22: @6 = @3[4] */
  for (rr=(&w6), ss=w3+4; ss!=w3+5; ss+=1) *rr++ = *ss;
  /* #23: @6 = (@4-@6) */
  w6  = (w4-w6);
  /* #24: @2 = (@2*@6) */
  w2 *= w6;
  /* #25: @6 = @3[4] */
  for (rr=(&w6), ss=w3+4; ss!=w3+5; ss+=1) *rr++ = *ss;
  /* #26: @4 = (@4-@6) */
  w4 -= w6;
  /* #27: @2 = (@2*@4) */
  w2 *= w4;
  /* #28: @0 = (@0+@2) */
  w0 += w2;
  /* #29: @2 = 0.001 */
  w2 = 1.0000000000000000e-003;
  /* #30: @4 = @5[1] */
  for (rr=(&w4), ss=w5+1; ss!=w5+2; ss+=1) *rr++ = *ss;
  /* #31: @6 = @3[5] */
  for (rr=(&w6), ss=w3+5; ss!=w3+6; ss+=1) *rr++ = *ss;
  /* #32: @6 = (@4-@6) */
  w6  = (w4-w6);
  /* #33: @2 = (@2*@6) */
  w2 *= w6;
  /* #34: @6 = @3[5] */
  for (rr=(&w6), ss=w3+5; ss!=w3+6; ss+=1) *rr++ = *ss;
  /* #35: @4 = (@4-@6) */
  w4 -= w6;
  /* #36: @2 = (@2*@4) */
  w2 *= w4;
  /* #37: @0 = (@0+@2) */
  w0 += w2;
  /* #38: @2 = 10 */
  w2 = 10.;
  /* #39: @4 = @1[2] */
  for (rr=(&w4), ss=w1+2; ss!=w1+3; ss+=1) *rr++ = *ss;
  /* #40: @6 = @3[7] */
  for (rr=(&w6), ss=w3+7; ss!=w3+8; ss+=1) *rr++ = *ss;
  /* #41: @6 = (@4-@6) */
  w6  = (w4-w6);
  /* #42: @2 = (@2*@6) */
  w2 *= w6;
  /* #43: @6 = @3[7] */
  for (rr=(&w6), ss=w3+7; ss!=w3+8; ss+=1) *rr++ = *ss;
  /* #44: @4 = (@4-@6) */
  w4 -= w6;
  /* #45: @2 = (@2*@4) */
  w2 *= w4;
  /* #46: @0 = (@0+@2) */
  w0 += w2;
  /* #47: @2 = 0.001 */
  w2 = 1.0000000000000000e-003;
  /* #48: @4 = @5[2] */
  for (rr=(&w4), ss=w5+2; ss!=w5+3; ss+=1) *rr++ = *ss;
  /* #49: @6 = @3[8] */
  for (rr=(&w6), ss=w3+8; ss!=w3+9; ss+=1) *rr++ = *ss;
  /* #50: @6 = (@4-@6) */
  w6  = (w4-w6);
  /* #51: @2 = (@2*@6) */
  w2 *= w6;
  /* #52: @6 = @3[8] */
  for (rr=(&w6), ss=w3+8; ss!=w3+9; ss+=1) *rr++ = *ss;
  /* #53: @4 = (@4-@6) */
  w4 -= w6;
  /* #54: @2 = (@2*@4) */
  w2 *= w4;
  /* #55: @0 = (@0+@2) */
  w0 += w2;
  /* #56: output[0][0] = @0 */
  if (res[0]) res[0][0] = w0;
  /* #57: @0 = @1[0] */
  for (rr=(&w0), ss=w1+0; ss!=w1+1; ss+=1) *rr++ = *ss;
  /* #58: output[1][0] = @0 */
  if (res[1]) res[1][0] = w0;
  /* #59: @0 = @1[1] */
  for (rr=(&w0), ss=w1+1; ss!=w1+2; ss+=1) *rr++ = *ss;
  /* #60: @2 = @1[0] */
  for (rr=(&w2), ss=w1+0; ss!=w1+1; ss+=1) *rr++ = *ss;
  /* #61: @4 = 0.2 */
  w4 = 2.0000000000000001e-001;
  /* #62: @6 = @1[0] */
  for (rr=(&w6), ss=w1+0; ss!=w1+1; ss+=1) *rr++ = *ss;
  /* #63: @7 = @5[0] */
  for (rr=(&w7), ss=w5+0; ss!=w5+1; ss+=1) *rr++ = *ss;
  /* #64: @8 = @3[3] */
  for (rr=(&w8), ss=w3+3; ss!=w3+4; ss+=1) *rr++ = *ss;
  /* #65: @9 = f(@6, @7, @8) */
  arg1[0]=(&w6);
  arg1[1]=(&w7);
  arg1[2]=(&w8);
  res1[0]=(&w9);
  if (casadi_f3(arg1, res1, iw, w, 0)) return 1;
  /* #66: @4 = (@4*@9) */
  w4 *= w9;
  /* #67: @2 = (@2+@4) */
  w2 += w4;
  /* #68: @0 = (@0-@2) */
  w0 -= w2;
  /* #69: output[1][1] = @0 */
  if (res[1]) res[1][1] = w0;
  /* #70: @0 = @1[2] */
  for (rr=(&w0), ss=w1+2; ss!=w1+3; ss+=1) *rr++ = *ss;
  /* #71: @2 = @1[1] */
  for (rr=(&w2), ss=w1+1; ss!=w1+2; ss+=1) *rr++ = *ss;
  /* #72: @4 = 0.2 */
  w4 = 2.0000000000000001e-001;
  /* #73: @9 = @1[1] */
  for (rr=(&w9), ss=w1+1; ss!=w1+2; ss+=1) *rr++ = *ss;
  /* #74: @6 = @5[1] */
  for (rr=(&w6), ss=w5+1; ss!=w5+2; ss+=1) *rr++ = *ss;
  /* #75: @7 = @3[6] */
  for (rr=(&w7), ss=w3+6; ss!=w3+7; ss+=1) *rr++ = *ss;
  /* #76: @8 = f(@9, @6, @7) */
  arg1[0]=(&w9);
  arg1[1]=(&w6);
  arg1[2]=(&w7);
  res1[0]=(&w8);
  if (casadi_f3(arg1, res1, iw, w, 0)) return 1;
  /* #77: @4 = (@4*@8) */
  w4 *= w8;
  /* #78: @2 = (@2+@4) */
  w2 += w4;
  /* #79: @0 = (@0-@2) */
  w0 -= w2;
  /* #80: output[1][2] = @0 */
  if (res[1]) res[1][2] = w0;
  /* #81: @0 = @1[3] */
  for (rr=(&w0), ss=w1+3; ss!=w1+4; ss+=1) *rr++ = *ss;
  /* #82: @2 = @1[2] */
  for (rr=(&w2), ss=w1+2; ss!=w1+3; ss+=1) *rr++ = *ss;
  /* #83: @4 = 0.2 */
  w4 = 2.0000000000000001e-001;
  /* #84: @8 = @1[2] */
  for (rr=(&w8), ss=w1+2; ss!=w1+3; ss+=1) *rr++ = *ss;
  /* #85: @9 = @5[2] */
  for (rr=(&w9), ss=w5+2; ss!=w5+3; ss+=1) *rr++ = *ss;
  /* #86: @6 = @3[9] */
  for (rr=(&w6), ss=w3+9; ss!=w3+10; ss+=1) *rr++ = *ss;
  /* #87: @7 = f(@8, @9, @6) */
  arg1[0]=(&w8);
  arg1[1]=(&w9);
  arg1[2]=(&w6);
  res1[0]=(&w7);
  if (casadi_f3(arg1, res1, iw, w, 0)) return 1;
  /* #88: @4 = (@4*@7) */
  w4 *= w7;
  /* #89: @2 = (@2+@4) */
  w2 += w4;
  /* #90: @0 = (@0-@2) */
  w0 -= w2;
  /* #91: output[1][3] = @0 */
  if (res[1]) res[1][3] = w0;
  /* #92: output[1][4] = @5 */
  if (res[1]) casadi_copy(w5, 3, res[1]+4);
  /* #93: output[1][5] = @1 */
  if (res[1]) casadi_copy(w1, 4, res[1]+7);
  return 0;
}

/* fwd2_f:(i0,i1,i2,out_o0[1x1,0nz],fwd_i0[1x2],fwd_i1[1x2],fwd_i2[1x2])->(fwd_o0[1x2]) */
static int casadi_f5(const casadi_real** arg, casadi_real** res, casadi_int* iw, casadi_real* w, int mem) {
  casadi_real a0, a1, a10, a11, a2, a3, a4, a5, a6, a7, a8, a9;
  a0=3.7336424039112486e-004;
  a1=2.8248587570621471e+000;
  a2=1.8500000000000000e+001;
  a3=arg[5]? arg[5][0] : 0;
  a3=(a2*a3);
  a3=(a1*a3);
  a4=1.7180625000000000e+000;
  a5=arg[0]? arg[0][0] : 0;
  a5=(a5+a5);
  a6=arg[4]? arg[4][0] : 0;
  a6=(a5*a6);
  a6=(a4*a6);
  a3=(a3-a6);
  a6=20601.;
  a7=arg[2]? arg[2][0] : 0;
  a8=100.;
  a7=(a7/a8);
  a8=atan(a7);
  a8=cos(a8);
  a9=1.0000000000000000e-002;
  a10=arg[6]? arg[6][0] : 0;
  a10=(a9*a10);
  a11=1.;
  a7=casadi_sq(a7);
  a11=(a11+a7);
  a10=(a10/a11);
  a10=(a8*a10);
  a10=(a6*a10);
  a3=(a3-a10);
  a3=(a0*a3);
  if (res[0]!=0) res[0][0]=a3;
  a3=arg[5]? arg[5][1] : 0;
  a2=(a2*a3);
  a1=(a1*a2);
  a2=arg[4]? arg[4][1] : 0;
  a5=(a5*a2);
  a4=(a4*a5);
  a1=(a1-a4);
  a4=arg[6]? arg[6][1] : 0;
  a9=(a9*a4);
  a9=(a9/a11);
  a8=(a8*a9);
  a6=(a6*a8);
  a1=(a1-a6);
  a0=(a0*a1);
  if (res[0]!=0) res[0][1]=a0;
  return 0;
}

/* nlp_jac_fg:(x[7],p[10])->(f,grad_f_x[7],g[11],jac_g_x[11x7,17nz]) */
static int casadi_f4(const casadi_real** arg, casadi_real** res, casadi_int* iw, casadi_real* w, int mem) {
  casadi_int i;
  casadi_real **res1=res+4, *rr, *ss;
  const casadi_int *cii;
  const casadi_real **arg1=arg+2, *cs;
  casadi_real w0, *w1=w+13, w2, *w3=w+18, w4, w5, w6, *w7=w+31, w8, w9, w10, w11, w12, w13, w14, w15, w16, w17, w18, w19, w20, w21, w22, *w23=w+49, *w24=w+52, *w25=w+56, *w29=w+73, *w30=w+75, *w31=w+77, *w32=w+79, *w33=w+81, *w34=w+83, *w35=w+85, *w36=w+87, *w37=w+89, *w38=w+95, *w39=w+101, *w40=w+106, *w41=w+111;
  /* #0: @0 = 10 */
  w0 = 10.;
  /* #1: @1 = input[0][1] */
  casadi_copy(arg[0] ? arg[0]+3 : 0, 4, w1);
  /* #2: @2 = @1[0] */
  for (rr=(&w2), ss=w1+0; ss!=w1+1; ss+=1) *rr++ = *ss;
  /* #3: @3 = input[1][0] */
  casadi_copy(arg[1], 10, w3);
  /* #4: @4 = @3[1] */
  for (rr=(&w4), ss=w3+1; ss!=w3+2; ss+=1) *rr++ = *ss;
  /* #5: @4 = (@2-@4) */
  w4  = (w2-w4);
  /* #6: @4 = (@0*@4) */
  w4  = (w0*w4);
  /* #7: @5 = @3[1] */
  for (rr=(&w5), ss=w3+1; ss!=w3+2; ss+=1) *rr++ = *ss;
  /* #8: @2 = (@2-@5) */
  w2 -= w5;
  /* #9: @5 = (@4*@2) */
  w5  = (w4*w2);
  /* #10: @6 = 0.001 */
  w6 = 1.0000000000000000e-003;
  /* #11: @7 = input[0][0] */
  casadi_copy(arg[0], 3, w7);
  /* #12: @8 = @7[0] */
  for (rr=(&w8), ss=w7+0; ss!=w7+1; ss+=1) *rr++ = *ss;
  /* #13: @9 = @3[2] */
  for (rr=(&w9), ss=w3+2; ss!=w3+3; ss+=1) *rr++ = *ss;
  /* #14: @9 = (@8-@9) */
  w9  = (w8-w9);
  /* #15: @9 = (@6*@9) */
  w9  = (w6*w9);
  /* #16: @10 = @3[2] */
  for (rr=(&w10), ss=w3+2; ss!=w3+3; ss+=1) *rr++ = *ss;
  /* #17: @8 = (@8-@10) */
  w8 -= w10;
  /* #18: @10 = (@9*@8) */
  w10  = (w9*w8);
  /* #19: @5 = (@5+@10) */
  w5 += w10;
  /* #20: @10 = 10 */
  w10 = 10.;
  /* #21: @11 = @1[1] */
  for (rr=(&w11), ss=w1+1; ss!=w1+2; ss+=1) *rr++ = *ss;
  /* #22: @12 = @3[4] */
  for (rr=(&w12), ss=w3+4; ss!=w3+5; ss+=1) *rr++ = *ss;
  /* #23: @12 = (@11-@12) */
  w12  = (w11-w12);
  /* #24: @12 = (@10*@12) */
  w12  = (w10*w12);
  /* #25: @13 = @3[4] */
  for (rr=(&w13), ss=w3+4; ss!=w3+5; ss+=1) *rr++ = *ss;
  /* #26: @11 = (@11-@13) */
  w11 -= w13;
  /* #27: @13 = (@12*@11) */
  w13  = (w12*w11);
  /* #28: @5 = (@5+@13) */
  w5 += w13;
  /* #29: @13 = 0.001 */
  w13 = 1.0000000000000000e-003;
  /* #30: @14 = @7[1] */
  for (rr=(&w14), ss=w7+1; ss!=w7+2; ss+=1) *rr++ = *ss;
  /* #31: @15 = @3[5] */
  for (rr=(&w15), ss=w3+5; ss!=w3+6; ss+=1) *rr++ = *ss;
  /* #32: @15 = (@14-@15) */
  w15  = (w14-w15);
  /* #33: @15 = (@13*@15) */
  w15  = (w13*w15);
  /* #34: @16 = @3[5] */
  for (rr=(&w16), ss=w3+5; ss!=w3+6; ss+=1) *rr++ = *ss;
  /* #35: @14 = (@14-@16) */
  w14 -= w16;
  /* #36: @16 = (@15*@14) */
  w16  = (w15*w14);
  /* #37: @5 = (@5+@16) */
  w5 += w16;
  /* #38: @16 = 10 */
  w16 = 10.;
  /* #39: @17 = @1[2] */
  for (rr=(&w17), ss=w1+2; ss!=w1+3; ss+=1) *rr++ = *ss;
  /* #40: @18 = @3[7] */
  for (rr=(&w18), ss=w3+7; ss!=w3+8; ss+=1) *rr++ = *ss;
  /* #41: @18 = (@17-@18) */
  w18  = (w17-w18);
  /* #42: @18 = (@16*@18) */
  w18  = (w16*w18);
  /* #43: @19 = @3[7] */
  for (rr=(&w19), ss=w3+7; ss!=w3+8; ss+=1) *rr++ = *ss;
  /* #44: @17 = (@17-@19) */
  w17 -= w19;
  /* #45: @19 = (@18*@17) */
  w19  = (w18*w17);
  /* #46: @5 = (@5+@19) */
  w5 += w19;
  /* #47: @19 = 0.001 */
  w19 = 1.0000000000000000e-003;
  /* #48: @20 = @7[2] */
  for (rr=(&w20), ss=w7+2; ss!=w7+3; ss+=1) *rr++ = *ss;
  /* #49: @21 = @3[8] */
  for (rr=(&w21), ss=w3+8; ss!=w3+9; ss+=1) *rr++ = *ss;
  /* #50: @21 = (@20-@21) */
  w21  = (w20-w21);
  /* #51: @21 = (@19*@21) */
  w21  = (w19*w21);
  /* #52: @22 = @3[8] */
  for (rr=(&w22), ss=w3+8; ss!=w3+9; ss+=1) *rr++ = *ss;
  /* #53: @20 = (@20-@22) */
  w20 -= w22;
  /* #54: @22 = (@21*@20) */
  w22  = (w21*w20);
  /* #55: @5 = (@5+@22) */
  w5 += w22;
  /* #56: output[0][0] = @5 */
  if (res[0]) res[0][0] = w5;
  /* #57: @23 = zeros(1x3) */
  casadi_clear(w23, 3);
  /* #58: @19 = (@19*@20) */
  w19 *= w20;
  /* #59: @21 = (@21+@19) */
  w21 += w19;
  /* #60: (@23[2] += @21) */
  for (rr=w23+2, ss=(&w21); rr!=w23+3; rr+=1) *rr += *ss++;
  /* #61: @13 = (@13*@14) */
  w13 *= w14;
  /* #62: @15 = (@15+@13) */
  w15 += w13;
  /* #63: (@23[1] += @15) */
  for (rr=w23+1, ss=(&w15); rr!=w23+2; rr+=1) *rr += *ss++;
  /* #64: @6 = (@6*@8) */
  w6 *= w8;
  /* #65: @9 = (@9+@6) */
  w9 += w6;
  /* #66: (@23[0] += @9) */
  for (rr=w23+0, ss=(&w9); rr!=w23+1; rr+=1) *rr += *ss++;
  /* #67: output[1][0] = @23 */
  casadi_copy(w23, 3, res[1]);
  /* #68: @24 = zeros(1x4) */
  casadi_clear(w24, 4);
  /* #69: @16 = (@16*@17) */
  w16 *= w17;
  /* #70: @18 = (@18+@16) */
  w18 += w16;
  /* #71: (@24[2] += @18) */
  for (rr=w24+2, ss=(&w18); rr!=w24+3; rr+=1) *rr += *ss++;
  /* #72: @10 = (@10*@11) */
  w10 *= w11;
  /* #73: @12 = (@12+@10) */
  w12 += w10;
  /* #74: (@24[1] += @12) */
  for (rr=w24+1, ss=(&w12); rr!=w24+2; rr+=1) *rr += *ss++;
  /* #75: @0 = (@0*@2) */
  w0 *= w2;
  /* #76: @4 = (@4+@0) */
  w4 += w0;
  /* #77: (@24[0] += @4) */
  for (rr=w24+0, ss=(&w4); rr!=w24+1; rr+=1) *rr += *ss++;
  /* #78: output[1][1] = @24 */
  if (res[1]) casadi_copy(w24, 4, res[1]+3);
  /* #79: @4 = @1[0] */
  for (rr=(&w4), ss=w1+0; ss!=w1+1; ss+=1) *rr++ = *ss;
  /* #80: output[2][0] = @4 */
  if (res[2]) res[2][0] = w4;
  /* #81: @4 = @1[1] */
  for (rr=(&w4), ss=w1+1; ss!=w1+2; ss+=1) *rr++ = *ss;
  /* #82: @0 = @1[0] */
  for (rr=(&w0), ss=w1+0; ss!=w1+1; ss+=1) *rr++ = *ss;
  /* #83: @2 = 0.2 */
  w2 = 2.0000000000000001e-001;
  /* #84: @12 = @1[0] */
  for (rr=(&w12), ss=w1+0; ss!=w1+1; ss+=1) *rr++ = *ss;
  /* #85: @10 = @7[0] */
  for (rr=(&w10), ss=w7+0; ss!=w7+1; ss+=1) *rr++ = *ss;
  /* #86: @11 = @3[3] */
  for (rr=(&w11), ss=w3+3; ss!=w3+4; ss+=1) *rr++ = *ss;
  /* #87: @18 = f(@12, @10, @11) */
  arg1[0]=(&w12);
  arg1[1]=(&w10);
  arg1[2]=(&w11);
  res1[0]=(&w18);
  if (casadi_f3(arg1, res1, iw, w, 0)) return 1;
  /* #88: @18 = (@2*@18) */
  w18  = (w2*w18);
  /* #89: @0 = (@0+@18) */
  w0 += w18;
  /* #90: @4 = (@4-@0) */
  w4 -= w0;
  /* #91: output[2][1] = @4 */
  if (res[2]) res[2][1] = w4;
  /* #92: @4 = @1[2] */
  for (rr=(&w4), ss=w1+2; ss!=w1+3; ss+=1) *rr++ = *ss;
  /* #93: @0 = @1[1] */
  for (rr=(&w0), ss=w1+1; ss!=w1+2; ss+=1) *rr++ = *ss;
  /* #94: @18 = 0.2 */
  w18 = 2.0000000000000001e-001;
  /* #95: @16 = @1[1] */
  for (rr=(&w16), ss=w1+1; ss!=w1+2; ss+=1) *rr++ = *ss;
  /* #96: @17 = @7[1] */
  for (rr=(&w17), ss=w7+1; ss!=w7+2; ss+=1) *rr++ = *ss;
  /* #97: @9 = @3[6] */
  for (rr=(&w9), ss=w3+6; ss!=w3+7; ss+=1) *rr++ = *ss;
  /* #98: @6 = f(@16, @17, @9) */
  arg1[0]=(&w16);
  arg1[1]=(&w17);
  arg1[2]=(&w9);
  res1[0]=(&w6);
  if (casadi_f3(arg1, res1, iw, w, 0)) return 1;
  /* #99: @6 = (@18*@6) */
  w6  = (w18*w6);
  /* #100: @0 = (@0+@6) */
  w0 += w6;
  /* #101: @4 = (@4-@0) */
  w4 -= w0;
  /* #102: output[2][2] = @4 */
  if (res[2]) res[2][2] = w4;
  /* #103: @4 = @1[3] */
  for (rr=(&w4), ss=w1+3; ss!=w1+4; ss+=1) *rr++ = *ss;
  /* #104: @0 = @1[2] */
  for (rr=(&w0), ss=w1+2; ss!=w1+3; ss+=1) *rr++ = *ss;
  /* #105: @6 = 0.2 */
  w6 = 2.0000000000000001e-001;
  /* #106: @8 = @1[2] */
  for (rr=(&w8), ss=w1+2; ss!=w1+3; ss+=1) *rr++ = *ss;
  /* #107: @15 = @7[2] */
  for (rr=(&w15), ss=w7+2; ss!=w7+3; ss+=1) *rr++ = *ss;
  /* #108: @13 = @3[9] */
  for (rr=(&w13), ss=w3+9; ss!=w3+10; ss+=1) *rr++ = *ss;
  /* #109: @14 = f(@8, @15, @13) */
  arg1[0]=(&w8);
  arg1[1]=(&w15);
  arg1[2]=(&w13);
  res1[0]=(&w14);
  if (casadi_f3(arg1, res1, iw, w, 0)) return 1;
  /* #110: @14 = (@6*@14) */
  w14  = (w6*w14);
  /* #111: @0 = (@0+@14) */
  w0 += w14;
  /* #112: @4 = (@4-@0) */
  w4 -= w0;
  /* #113: output[2][3] = @4 */
  if (res[2]) res[2][3] = w4;
  /* #114: output[2][4] = @7 */
  if (res[2]) casadi_copy(w7, 3, res[2]+4);
  /* #115: output[2][5] = @1 */
  if (res[2]) casadi_copy(w1, 4, res[2]+7);
  /* #116: @25 = zeros(7x11,17nz) */
  casadi_clear(w25, 17);
  /* #117: @26 = 00 */
  /* #118: @27 = 00 */
  /* #119: @28 = 00 */
  /* #120: @29 = ones(7x1,2nz) */
  casadi_fill(w29, 2, 1.);
  /* #121: {NULL, @30} = vertsplit(@29) */
  casadi_copy(w29, 2, w30);
  /* #122: @29 = @30' */
  casadi_copy(w30, 2, w29);
  /* #123: @4 = @29[0] */
  for (rr=(&w4), ss=w29+0; ss!=w29+1; ss+=1) *rr++ = *ss;
  /* #124: @0 = horzcat(@28, @4) */
  rr=(&w0);
  *rr++ = w4;
  /* #125: @31 = dense(@0) */
  casadi_densify((&w0), casadi_s0, w31, 0);
  /* #126: @7 = ones(7x1,3nz) */
  casadi_fill(w7, 3, 1.);
  /* #127: {@23, NULL} = vertsplit(@7) */
  casadi_copy(w7, 3, w23);
  /* #128: @7 = @23' */
  casadi_copy(w23, 3, w7);
  /* #129: @0 = @7[0] */
  for (rr=(&w0), ss=w7+0; ss!=w7+1; ss+=1) *rr++ = *ss;
  /* #130: @28 = 00 */
  /* #131: @4 = horzcat(@0, @28) */
  rr=(&w4);
  *rr++ = w0;
  /* #132: @32 = dense(@4) */
  casadi_densify((&w4), casadi_s1, w32, 0);
  /* #133: @33 = zeros(1x2) */
  casadi_clear(w33, 2);
  /* #134: @34 = fwd2_f(@12, @10, @11, @27, @31, @32, @33) */
  arg1[0]=(&w12);
  arg1[1]=(&w10);
  arg1[2]=(&w11);
  arg1[3]=0;
  arg1[4]=w31;
  arg1[5]=w32;
  arg1[6]=w33;
  res1[0]=w34;
  if (casadi_f5(arg1, res1, iw, w, 0)) return 1;
  /* #135: {@12, @10} = horzsplit(@34) */
  w12 = w34[0];
  w10 = w34[1];
  /* #136: @12 = (@2*@12) */
  w12  = (w2*w12);
  /* #137: @12 = (-@12) */
  w12 = (- w12 );
  /* #138: @27 = 00 */
  /* #139: @28 = 00 */
  /* #140: @34 = ones(7x1,2nz) */
  casadi_fill(w34, 2, 1.);
  /* #141: {NULL, @31} = vertsplit(@34) */
  casadi_copy(w34, 2, w31);
  /* #142: @34 = @31' */
  casadi_copy(w31, 2, w34);
  /* #143: @11 = @34[0] */
  for (rr=(&w11), ss=w34+0; ss!=w34+1; ss+=1) *rr++ = *ss;
  /* #144: @4 = horzcat(@28, @11) */
  rr=(&w4);
  *rr++ = w11;
  /* #145: @32 = dense(@4) */
  casadi_densify((&w4), casadi_s0, w32, 0);
  /* #146: @4 = @7[1] */
  for (rr=(&w4), ss=w7+1; ss!=w7+2; ss+=1) *rr++ = *ss;
  /* #147: @28 = 00 */
  /* #148: @11 = horzcat(@4, @28) */
  rr=(&w11);
  *rr++ = w4;
  /* #149: @33 = dense(@11) */
  casadi_densify((&w11), casadi_s1, w33, 0);
  /* #150: @35 = zeros(1x2) */
  casadi_clear(w35, 2);
  /* #151: @36 = fwd2_f(@16, @17, @9, @27, @32, @33, @35) */
  arg1[0]=(&w16);
  arg1[1]=(&w17);
  arg1[2]=(&w9);
  arg1[3]=0;
  arg1[4]=w32;
  arg1[5]=w33;
  arg1[6]=w35;
  res1[0]=w36;
  if (casadi_f5(arg1, res1, iw, w, 0)) return 1;
  /* #152: {@16, @17} = horzsplit(@36) */
  w16 = w36[0];
  w17 = w36[1];
  /* #153: @16 = (@18*@16) */
  w16  = (w18*w16);
  /* #154: @16 = (-@16) */
  w16 = (- w16 );
  /* #155: @27 = 00 */
  /* #156: @28 = 00 */
  /* #157: @9 = @29[1] */
  for (rr=(&w9), ss=w29+1; ss!=w29+2; ss+=1) *rr++ = *ss;
  /* #158: @11 = horzcat(@28, @9) */
  rr=(&w11);
  *rr++ = w9;
  /* #159: @36 = dense(@11) */
  casadi_densify((&w11), casadi_s0, w36, 0);
  /* #160: @11 = @7[2] */
  for (rr=(&w11), ss=w7+2; ss!=w7+3; ss+=1) *rr++ = *ss;
  /* #161: @28 = 00 */
  /* #162: @9 = horzcat(@11, @28) */
  rr=(&w9);
  *rr++ = w11;
  /* #163: @32 = dense(@9) */
  casadi_densify((&w9), casadi_s1, w32, 0);
  /* #164: @33 = zeros(1x2) */
  casadi_clear(w33, 2);
  /* #165: @35 = fwd2_f(@8, @15, @13, @27, @36, @32, @33) */
  arg1[0]=(&w8);
  arg1[1]=(&w15);
  arg1[2]=(&w13);
  arg1[3]=0;
  arg1[4]=w36;
  arg1[5]=w32;
  arg1[6]=w33;
  res1[0]=w35;
  if (casadi_f5(arg1, res1, iw, w, 0)) return 1;
  /* #166: {@8, @15} = horzsplit(@35) */
  w8 = w35[0];
  w15 = w35[1];
  /* #167: @8 = (@6*@8) */
  w8  = (w6*w8);
  /* #168: @8 = (-@8) */
  w8 = (- w8 );
  /* #169: @27 = zeros(4x1,0nz) */
  /* #170: @37 = vertcat(@26, @12, @16, @8, @23, @27) */
  rr=w37;
  *rr++ = w12;
  *rr++ = w16;
  *rr++ = w8;
  for (i=0, cs=w23; i<3; ++i) *rr++ = *cs++;
  /* #171: @38 = @37[:6] */
  for (rr=w38, ss=w37+0; ss!=w37+6; ss+=1) *rr++ = *ss;
  /* #172: (@25[1, 4, 7, 10, 11, 12] = @38) */
  for (cii=casadi_s2, rr=w25, ss=w38; cii!=casadi_s2+6; ++cii, ++ss) if (*cii>=0) rr[*cii] = *ss;
  /* #173: @12 = @29[0] */
  for (rr=(&w12), ss=w29+0; ss!=w29+1; ss+=1) *rr++ = *ss;
  /* #174: @16 = @29[0] */
  for (rr=(&w16), ss=w29+0; ss!=w29+1; ss+=1) *rr++ = *ss;
  /* #175: @2 = (@2*@10) */
  w2 *= w10;
  /* #176: @16 = (@16+@2) */
  w16 += w2;
  /* #177: @16 = (-@16) */
  w16 = (- w16 );
  /* #178: @2 = @29[1] */
  for (rr=(&w2), ss=w29+1; ss!=w29+2; ss+=1) *rr++ = *ss;
  /* #179: @10 = @29[1] */
  for (rr=(&w10), ss=w29+1; ss!=w29+2; ss+=1) *rr++ = *ss;
  /* #180: @6 = (@6*@15) */
  w6 *= w15;
  /* #181: @10 = (@10+@6) */
  w10 += w6;
  /* #182: @10 = (-@10) */
  w10 = (- w10 );
  /* #183: @26 = zeros(3x1,0nz) */
  /* #184: @38 = vertcat(@12, @16, @2, @10, @26, @30) */
  rr=w38;
  *rr++ = w12;
  *rr++ = w16;
  *rr++ = w2;
  *rr++ = w10;
  for (i=0, cs=w30; i<2; ++i) *rr++ = *cs++;
  /* #185: @37 = @38[:6] */
  for (rr=w37, ss=w38+0; ss!=w38+6; ss+=1) *rr++ = *ss;
  /* #186: (@25[0, 2, 6, 8, 13, 15] = @37) */
  for (cii=casadi_s3, rr=w25, ss=w37; cii!=casadi_s3+6; ++cii, ++ss) if (*cii>=0) rr[*cii] = *ss;
  /* #187: @26 = 00 */
  /* #188: @12 = @34[0] */
  for (rr=(&w12), ss=w34+0; ss!=w34+1; ss+=1) *rr++ = *ss;
  /* #189: @16 = @34[0] */
  for (rr=(&w16), ss=w34+0; ss!=w34+1; ss+=1) *rr++ = *ss;
  /* #190: @18 = (@18*@17) */
  w18 *= w17;
  /* #191: @16 = (@16+@18) */
  w16 += w18;
  /* #192: @16 = (-@16) */
  w16 = (- w16 );
  /* #193: @18 = @34[1] */
  for (rr=(&w18), ss=w34+1; ss!=w34+2; ss+=1) *rr++ = *ss;
  /* #194: @27 = zeros(3x1,0nz) */
  /* #195: @39 = vertcat(@26, @12, @16, @18, @27, @31) */
  rr=w39;
  *rr++ = w12;
  *rr++ = w16;
  *rr++ = w18;
  for (i=0, cs=w31; i<2; ++i) *rr++ = *cs++;
  /* #196: @40 = @39[:5] */
  for (rr=w40, ss=w39+0; ss!=w39+5; ss+=1) *rr++ = *ss;
  /* #197: (@25[3, 5, 9, 14, 16] = @40) */
  for (cii=casadi_s4, rr=w25, ss=w40; cii!=casadi_s4+5; ++cii, ++ss) if (*cii>=0) rr[*cii] = *ss;
  /* #198: @41 = @25' */
  casadi_trans(w25,casadi_s6, w41, casadi_s5, iw);
  /* #199: output[3][0] = @41 */
  casadi_copy(w41, 17, res[3]);
  return 0;
}

/* fwd1_adj1_f:(i0,i1,i2,out_o0[1x1,0nz],adj_o0,out_adj_i0[1x1,0nz],out_adj_i1[1x1,0nz],out_adj_i2[1x1,0nz],fwd_i0,fwd_i1,fwd_i2,fwd_out_o0[1x1,0nz],fwd_adj_o0)->(fwd_adj_i0,fwd_adj_i1,fwd_adj_i2) */
static int casadi_f7(const casadi_real** arg, casadi_real** res, casadi_int* iw, casadi_real* w, int mem) {
  casadi_real a0, a1, a2, a3, a4, a5, a6, a7, a8;
  a0=1.7180625000000000e+000;
  a1=3.7336424039112486e-004;
  a2=arg[4]? arg[4][0] : 0;
  a2=(a1*a2);
  a3=(a0*a2);
  a4=arg[8]? arg[8][0] : 0;
  a4=(a4+a4);
  a3=(a3*a4);
  a4=arg[0]? arg[0][0] : 0;
  a4=(a4+a4);
  a5=arg[12]? arg[12][0] : 0;
  a1=(a1*a5);
  a0=(a0*a1);
  a4=(a4*a0);
  a3=(a3+a4);
  a3=(-a3);
  if (res[0]!=0) res[0][0]=a3;
  a3=1.8500000000000000e+001;
  a4=2.8248587570621471e+000;
  a4=(a4*a1);
  a3=(a3*a4);
  if (res[1]!=0) res[1][0]=a3;
  a3=1.0000000000000000e-002;
  a4=arg[2]? arg[2][0] : 0;
  a0=100.;
  a4=(a4/a0);
  a0=atan(a4);
  a5=cos(a0);
  a6=20601.;
  a1=(a6*a1);
  a1=(a5*a1);
  a6=(a6*a2);
  a0=sin(a0);
  a2=arg[10]? arg[10][0] : 0;
  a2=(a3*a2);
  a7=1.;
  a8=casadi_sq(a4);
  a8=(a7+a8);
  a8=(a2/a8);
  a0=(a0*a8);
  a0=(a6*a0);
  a1=(a1-a0);
  a0=casadi_sq(a4);
  a7=(a7+a0);
  a1=(a1/a7);
  a5=(a5*a6);
  a5=(a5/a7);
  a5=(a5/a7);
  a4=(a4+a4);
  a4=(a4*a2);
  a5=(a5*a4);
  a1=(a1-a5);
  a3=(a3*a1);
  a3=(-a3);
  if (res[2]!=0) res[2][0]=a3;
  return 0;
}

/* nlp_hess_l:(x[7],p[10],lam_f,lam_g[11])->(sym_hess_gamma_x_x[7x7,6nz]) */
static int casadi_f6(const casadi_real** arg, casadi_real** res, casadi_int* iw, casadi_real* w, int mem) {
  casadi_int i;
  casadi_real **res1=res+1, *rr, *ss;
  const casadi_real **arg1=arg+4, *cs;
  casadi_real *w0=w+9, *w1=w+15, *w2=w+18, w3, *w4=w+23, w5, *w6=w+27, w7, w9, *w10=w+39, w11, w12, w13, *w17=w+53, *w18=w+60, *w19=w+63, w20, w21, w23, w24, w25, *w26=w+72;
  /* #0: @0 = zeros(7x7,6nz) */
  casadi_clear(w0, 6);
  /* #1: @1 = zeros(1x3) */
  casadi_clear(w1, 3);
  /* #2: @2 = input[0][1] */
  casadi_copy(arg[0] ? arg[0]+3 : 0, 4, w2);
  /* #3: @3 = @2[2] */
  for (rr=(&w3), ss=w2+2; ss!=w2+3; ss+=1) *rr++ = *ss;
  /* #4: @4 = input[0][0] */
  casadi_copy(arg[0], 3, w4);
  /* #5: @5 = @4[2] */
  for (rr=(&w5), ss=w4+2; ss!=w4+3; ss+=1) *rr++ = *ss;
  /* #6: @6 = input[1][0] */
  casadi_copy(arg[1], 10, w6);
  /* #7: @7 = @6[9] */
  for (rr=(&w7), ss=w6+9; ss!=w6+10; ss+=1) *rr++ = *ss;
  /* #8: @8 = 00 */
  /* #9: @9 = 0.2 */
  w9 = 2.0000000000000001e-001;
  /* #10: @10 = input[3][0] */
  casadi_copy(arg[3], 11, w10);
  /* #11: {NULL, @11, @12, @13, NULL, NULL} = vertsplit(@10) */
  w11 = w10[1];
  w12 = w10[2];
  w13 = w10[3];
  /* #12: @9 = (@9*@13) */
  w9 *= w13;
  /* #13: @9 = (-@9) */
  w9 = (- w9 );
  /* #14: @14 = 00 */
  /* #15: @15 = 00 */
  /* #16: @16 = 00 */
  /* #17: @17 = ones(7x1) */
  casadi_fill(w17, 7, 1.);
  /* #18: {@18, @19} = vertsplit(@17) */
  casadi_copy(w17, 3, w18);
  casadi_copy(w17+3, 4, w19);
  /* #19: @19 = @19' */
  /* #20: @13 = @19[2] */
  for (rr=(&w13), ss=w19+2; ss!=w19+3; ss+=1) *rr++ = *ss;
  /* #21: @18 = @18' */
  /* #22: @20 = @18[2] */
  for (rr=(&w20), ss=w18+2; ss!=w18+3; ss+=1) *rr++ = *ss;
  /* #23: @21 = 0 */
  w21 = 0.;
  /* #24: @22 = 00 */
  /* #25: @23 = 0 */
  w23 = 0.;
  /* #26: {@24, @25, NULL} = fwd1_adj1_f(@3, @5, @7, @8, @9, @14, @15, @16, @13, @20, @21, @22, @23) */
  arg1[0]=(&w3);
  arg1[1]=(&w5);
  arg1[2]=(&w7);
  arg1[3]=0;
  arg1[4]=(&w9);
  arg1[5]=0;
  arg1[6]=0;
  arg1[7]=0;
  arg1[8]=(&w13);
  arg1[9]=(&w20);
  arg1[10]=(&w21);
  arg1[11]=0;
  arg1[12]=(&w23);
  res1[0]=(&w24);
  res1[1]=(&w25);
  res1[2]=0;
  if (casadi_f7(arg1, res1, iw, w, 0)) return 1;
  /* #27: (@1[2] += @25) */
  for (rr=w1+2, ss=(&w25); rr!=w1+3; rr+=1) *rr += *ss++;
  /* #28: @25 = @2[1] */
  for (rr=(&w25), ss=w2+1; ss!=w2+2; ss+=1) *rr++ = *ss;
  /* #29: @3 = @4[1] */
  for (rr=(&w3), ss=w4+1; ss!=w4+2; ss+=1) *rr++ = *ss;
  /* #30: @5 = @6[6] */
  for (rr=(&w5), ss=w6+6; ss!=w6+7; ss+=1) *rr++ = *ss;
  /* #31: @8 = 00 */
  /* #32: @7 = 0.2 */
  w7 = 2.0000000000000001e-001;
  /* #33: @7 = (@7*@12) */
  w7 *= w12;
  /* #34: @7 = (-@7) */
  w7 = (- w7 );
  /* #35: @14 = 00 */
  /* #36: @15 = 00 */
  /* #37: @16 = 00 */
  /* #38: @12 = @19[1] */
  for (rr=(&w12), ss=w19+1; ss!=w19+2; ss+=1) *rr++ = *ss;
  /* #39: @9 = @18[1] */
  for (rr=(&w9), ss=w18+1; ss!=w18+2; ss+=1) *rr++ = *ss;
  /* #40: @13 = 0 */
  w13 = 0.;
  /* #41: @22 = 00 */
  /* #42: @20 = 0 */
  w20 = 0.;
  /* #43: {@21, @23, NULL} = fwd1_adj1_f(@25, @3, @5, @8, @7, @14, @15, @16, @12, @9, @13, @22, @20) */
  arg1[0]=(&w25);
  arg1[1]=(&w3);
  arg1[2]=(&w5);
  arg1[3]=0;
  arg1[4]=(&w7);
  arg1[5]=0;
  arg1[6]=0;
  arg1[7]=0;
  arg1[8]=(&w12);
  arg1[9]=(&w9);
  arg1[10]=(&w13);
  arg1[11]=0;
  arg1[12]=(&w20);
  res1[0]=(&w21);
  res1[1]=(&w23);
  res1[2]=0;
  if (casadi_f7(arg1, res1, iw, w, 0)) return 1;
  /* #44: (@1[1] += @23) */
  for (rr=w1+1, ss=(&w23); rr!=w1+2; rr+=1) *rr += *ss++;
  /* #45: @23 = @2[0] */
  for (rr=(&w23), ss=w2+0; ss!=w2+1; ss+=1) *rr++ = *ss;
  /* #46: @25 = @4[0] */
  for (rr=(&w25), ss=w4+0; ss!=w4+1; ss+=1) *rr++ = *ss;
  /* #47: @3 = @6[3] */
  for (rr=(&w3), ss=w6+3; ss!=w6+4; ss+=1) *rr++ = *ss;
  /* #48: @8 = 00 */
  /* #49: @5 = 0.2 */
  w5 = 2.0000000000000001e-001;
  /* #50: @5 = (@5*@11) */
  w5 *= w11;
  /* #51: @5 = (-@5) */
  w5 = (- w5 );
  /* #52: @14 = 00 */
  /* #53: @15 = 00 */
  /* #54: @16 = 00 */
  /* #55: @11 = @19[0] */
  for (rr=(&w11), ss=w19+0; ss!=w19+1; ss+=1) *rr++ = *ss;
  /* #56: @7 = @18[0] */
  for (rr=(&w7), ss=w18+0; ss!=w18+1; ss+=1) *rr++ = *ss;
  /* #57: @12 = 0 */
  w12 = 0.;
  /* #58: @22 = 00 */
  /* #59: @9 = 0 */
  w9 = 0.;
  /* #60: {@13, @20, NULL} = fwd1_adj1_f(@23, @25, @3, @8, @5, @14, @15, @16, @11, @7, @12, @22, @9) */
  arg1[0]=(&w23);
  arg1[1]=(&w25);
  arg1[2]=(&w3);
  arg1[3]=0;
  arg1[4]=(&w5);
  arg1[5]=0;
  arg1[6]=0;
  arg1[7]=0;
  arg1[8]=(&w11);
  arg1[9]=(&w7);
  arg1[10]=(&w12);
  arg1[11]=0;
  arg1[12]=(&w9);
  res1[0]=(&w13);
  res1[1]=(&w20);
  res1[2]=0;
  if (casadi_f7(arg1, res1, iw, w, 0)) return 1;
  /* #61: (@1[0] += @20) */
  for (rr=w1+0, ss=(&w20); rr!=w1+1; rr+=1) *rr += *ss++;
  /* #62: @20 = input[2][0] */
  w20 = arg[2] ? arg[2][0] : 0;
  /* #63: @23 = 0.001 */
  w23 = 1.0000000000000000e-003;
  /* #64: @25 = @18[2] */
  for (rr=(&w25), ss=w18+2; ss!=w18+3; ss+=1) *rr++ = *ss;
  /* #65: @3 = (@23*@25) */
  w3  = (w23*w25);
  /* #66: @3 = (@20*@3) */
  w3  = (w20*w3);
  /* #67: @25 = (@20*@25) */
  w25  = (w20*w25);
  /* #68: @23 = (@23*@25) */
  w23 *= w25;
  /* #69: @3 = (@3+@23) */
  w3 += w23;
  /* #70: (@1[2] += @3) */
  for (rr=w1+2, ss=(&w3); rr!=w1+3; rr+=1) *rr += *ss++;
  /* #71: @3 = 0.001 */
  w3 = 1.0000000000000000e-003;
  /* #72: @23 = @18[1] */
  for (rr=(&w23), ss=w18+1; ss!=w18+2; ss+=1) *rr++ = *ss;
  /* #73: @25 = (@3*@23) */
  w25  = (w3*w23);
  /* #74: @25 = (@20*@25) */
  w25  = (w20*w25);
  /* #75: @23 = (@20*@23) */
  w23  = (w20*w23);
  /* #76: @3 = (@3*@23) */
  w3 *= w23;
  /* #77: @25 = (@25+@3) */
  w25 += w3;
  /* #78: (@1[1] += @25) */
  for (rr=w1+1, ss=(&w25); rr!=w1+2; rr+=1) *rr += *ss++;
  /* #79: @25 = 0.001 */
  w25 = 1.0000000000000000e-003;
  /* #80: @3 = @18[0] */
  for (rr=(&w3), ss=w18+0; ss!=w18+1; ss+=1) *rr++ = *ss;
  /* #81: @23 = (@25*@3) */
  w23  = (w25*w3);
  /* #82: @23 = (@20*@23) */
  w23  = (w20*w23);
  /* #83: @3 = (@20*@3) */
  w3  = (w20*w3);
  /* #84: @25 = (@25*@3) */
  w25 *= w3;
  /* #85: @23 = (@23+@25) */
  w23 += w25;
  /* #86: (@1[0] += @23) */
  for (rr=w1+0, ss=(&w23); rr!=w1+1; rr+=1) *rr += *ss++;
  /* #87: @1 = @1' */
  /* #88: @2 = zeros(1x4) */
  casadi_clear(w2, 4);
  /* #89: (@2[2] += @24) */
  for (rr=w2+2, ss=(&w24); rr!=w2+3; rr+=1) *rr += *ss++;
  /* #90: (@2[1] += @21) */
  for (rr=w2+1, ss=(&w21); rr!=w2+2; rr+=1) *rr += *ss++;
  /* #91: (@2[0] += @13) */
  for (rr=w2+0, ss=(&w13); rr!=w2+1; rr+=1) *rr += *ss++;
  /* #92: @13 = 10 */
  w13 = 10.;
  /* #93: @21 = @19[2] */
  for (rr=(&w21), ss=w19+2; ss!=w19+3; ss+=1) *rr++ = *ss;
  /* #94: @24 = (@13*@21) */
  w24  = (w13*w21);
  /* #95: @24 = (@20*@24) */
  w24  = (w20*w24);
  /* #96: @21 = (@20*@21) */
  w21  = (w20*w21);
  /* #97: @13 = (@13*@21) */
  w13 *= w21;
  /* #98: @24 = (@24+@13) */
  w24 += w13;
  /* #99: (@2[2] += @24) */
  for (rr=w2+2, ss=(&w24); rr!=w2+3; rr+=1) *rr += *ss++;
  /* #100: @24 = 10 */
  w24 = 10.;
  /* #101: @13 = @19[1] */
  for (rr=(&w13), ss=w19+1; ss!=w19+2; ss+=1) *rr++ = *ss;
  /* #102: @21 = (@24*@13) */
  w21  = (w24*w13);
  /* #103: @21 = (@20*@21) */
  w21  = (w20*w21);
  /* #104: @13 = (@20*@13) */
  w13  = (w20*w13);
  /* #105: @24 = (@24*@13) */
  w24 *= w13;
  /* #106: @21 = (@21+@24) */
  w21 += w24;
  /* #107: (@2[1] += @21) */
  for (rr=w2+1, ss=(&w21); rr!=w2+2; rr+=1) *rr += *ss++;
  /* #108: @21 = 10 */
  w21 = 10.;
  /* #109: @24 = @19[0] */
  for (rr=(&w24), ss=w19+0; ss!=w19+1; ss+=1) *rr++ = *ss;
  /* #110: @13 = (@21*@24) */
  w13  = (w21*w24);
  /* #111: @13 = (@20*@13) */
  w13  = (w20*w13);
  /* #112: @20 = (@20*@24) */
  w20 *= w24;
  /* #113: @21 = (@21*@20) */
  w21 *= w20;
  /* #114: @13 = (@13+@21) */
  w13 += w21;
  /* #115: (@2[0] += @13) */
  for (rr=w2+0, ss=(&w13); rr!=w2+1; rr+=1) *rr += *ss++;
  /* #116: @2 = @2' */
  /* #117: @17 = vertcat(@1, @2) */
  rr=w17;
  for (i=0, cs=w1; i<3; ++i) *rr++ = *cs++;
  for (i=0, cs=w2; i<4; ++i) *rr++ = *cs++;
  /* #118: @26 = @17[:6] */
  for (rr=w26, ss=w17+0; ss!=w17+6; ss+=1) *rr++ = *ss;
  /* #119: (@0[:6] = @26) */
  for (rr=w0+0, ss=w26; rr!=w0+6; rr+=1) *rr = *ss++;
  /* #120: @26 = @17[:6] */
  for (rr=w26, ss=w17+0; ss!=w17+6; ss+=1) *rr++ = *ss;
  /* #121: (@0[:6] = @26) */
  for (rr=w0+0, ss=w26; rr!=w0+6; rr+=1) *rr = *ss++;
  /* #122: output[0][0] = @0 */
  casadi_copy(w0, 6, res[0]);
  return 0;
}

/* adj1_f:(i0,i1,i2,out_o0[1x1,0nz],adj_o0)->(adj_i0,adj_i1,adj_i2) */
static int casadi_f9(const casadi_real** arg, casadi_real** res, casadi_int* iw, casadi_real* w, int mem) {
  casadi_real a0, a1, a2, a3, a4;
  a0=arg[0]? arg[0][0] : 0;
  a0=(a0+a0);
  a1=1.7180625000000000e+000;
  a2=3.7336424039112486e-004;
  a3=arg[4]? arg[4][0] : 0;
  a2=(a2*a3);
  a1=(a1*a2);
  a0=(a0*a1);
  a0=(-a0);
  if (res[0]!=0) res[0][0]=a0;
  a0=1.8500000000000000e+001;
  a1=2.8248587570621471e+000;
  a1=(a1*a2);
  a0=(a0*a1);
  if (res[1]!=0) res[1][0]=a0;
  a0=1.0000000000000000e-002;
  a1=arg[2]? arg[2][0] : 0;
  a3=100.;
  a1=(a1/a3);
  a3=atan(a1);
  a3=cos(a3);
  a4=20601.;
  a4=(a4*a2);
  a3=(a3*a4);
  a4=1.;
  a1=casadi_sq(a1);
  a4=(a4+a1);
  a3=(a3/a4);
  a0=(a0*a3);
  a0=(-a0);
  if (res[2]!=0) res[2][0]=a0;
  return 0;
}

/* nlp_grad:(x[7],p[10],lam_f,lam_g[11])->(f,g[11],grad_gamma_x[7],grad_gamma_p[10]) */
static int casadi_f8(const casadi_real** arg, casadi_real** res, casadi_int* iw, casadi_real* w, int mem) {
  casadi_real **res1=res+4, *rr, *ss;
  const casadi_real **arg1=arg+4;
  casadi_real w0, *w1=w+6, w2, *w3=w+11, w4, w5, w6, *w7=w+24, w8, w9, w10, w11, w12, w13, w14, w15, w16, w17, w18, w19, w20, w21, w22, w23, w24, w25, w26, w27, w28, w29, w30, w31, w32, w33, w34, w35, *w36=w+55, w37, w39, w40, w41, w42, w43, w44;
  /* #0: @0 = 10 */
  w0 = 10.;
  /* #1: @1 = input[0][1] */
  casadi_copy(arg[0] ? arg[0]+3 : 0, 4, w1);
  /* #2: @2 = @1[0] */
  for (rr=(&w2), ss=w1+0; ss!=w1+1; ss+=1) *rr++ = *ss;
  /* #3: @3 = input[1][0] */
  casadi_copy(arg[1], 10, w3);
  /* #4: @4 = @3[1] */
  for (rr=(&w4), ss=w3+1; ss!=w3+2; ss+=1) *rr++ = *ss;
  /* #5: @4 = (@2-@4) */
  w4  = (w2-w4);
  /* #6: @4 = (@0*@4) */
  w4  = (w0*w4);
  /* #7: @5 = @3[1] */
  for (rr=(&w5), ss=w3+1; ss!=w3+2; ss+=1) *rr++ = *ss;
  /* #8: @2 = (@2-@5) */
  w2 -= w5;
  /* #9: @5 = (@4*@2) */
  w5  = (w4*w2);
  /* #10: @6 = 0.001 */
  w6 = 1.0000000000000000e-003;
  /* #11: @7 = input[0][0] */
  casadi_copy(arg[0], 3, w7);
  /* #12: @8 = @7[0] */
  for (rr=(&w8), ss=w7+0; ss!=w7+1; ss+=1) *rr++ = *ss;
  /* #13: @9 = @3[2] */
  for (rr=(&w9), ss=w3+2; ss!=w3+3; ss+=1) *rr++ = *ss;
  /* #14: @9 = (@8-@9) */
  w9  = (w8-w9);
  /* #15: @9 = (@6*@9) */
  w9  = (w6*w9);
  /* #16: @10 = @3[2] */
  for (rr=(&w10), ss=w3+2; ss!=w3+3; ss+=1) *rr++ = *ss;
  /* #17: @8 = (@8-@10) */
  w8 -= w10;
  /* #18: @10 = (@9*@8) */
  w10  = (w9*w8);
  /* #19: @5 = (@5+@10) */
  w5 += w10;
  /* #20: @10 = 10 */
  w10 = 10.;
  /* #21: @11 = @1[1] */
  for (rr=(&w11), ss=w1+1; ss!=w1+2; ss+=1) *rr++ = *ss;
  /* #22: @12 = @3[4] */
  for (rr=(&w12), ss=w3+4; ss!=w3+5; ss+=1) *rr++ = *ss;
  /* #23: @12 = (@11-@12) */
  w12  = (w11-w12);
  /* #24: @12 = (@10*@12) */
  w12  = (w10*w12);
  /* #25: @13 = @3[4] */
  for (rr=(&w13), ss=w3+4; ss!=w3+5; ss+=1) *rr++ = *ss;
  /* #26: @11 = (@11-@13) */
  w11 -= w13;
  /* #27: @13 = (@12*@11) */
  w13  = (w12*w11);
  /* #28: @5 = (@5+@13) */
  w5 += w13;
  /* #29: @13 = 0.001 */
  w13 = 1.0000000000000000e-003;
  /* #30: @14 = @7[1] */
  for (rr=(&w14), ss=w7+1; ss!=w7+2; ss+=1) *rr++ = *ss;
  /* #31: @15 = @3[5] */
  for (rr=(&w15), ss=w3+5; ss!=w3+6; ss+=1) *rr++ = *ss;
  /* #32: @15 = (@14-@15) */
  w15  = (w14-w15);
  /* #33: @15 = (@13*@15) */
  w15  = (w13*w15);
  /* #34: @16 = @3[5] */
  for (rr=(&w16), ss=w3+5; ss!=w3+6; ss+=1) *rr++ = *ss;
  /* #35: @14 = (@14-@16) */
  w14 -= w16;
  /* #36: @16 = (@15*@14) */
  w16  = (w15*w14);
  /* #37: @5 = (@5+@16) */
  w5 += w16;
  /* #38: @16 = 10 */
  w16 = 10.;
  /* #39: @17 = @1[2] */
  for (rr=(&w17), ss=w1+2; ss!=w1+3; ss+=1) *rr++ = *ss;
  /* #40: @18 = @3[7] */
  for (rr=(&w18), ss=w3+7; ss!=w3+8; ss+=1) *rr++ = *ss;
  /* #41: @18 = (@17-@18) */
  w18  = (w17-w18);
  /* #42: @18 = (@16*@18) */
  w18  = (w16*w18);
  /* #43: @19 = @3[7] */
  for (rr=(&w19), ss=w3+7; ss!=w3+8; ss+=1) *rr++ = *ss;
  /* #44: @17 = (@17-@19) */
  w17 -= w19;
  /* #45: @19 = (@18*@17) */
  w19  = (w18*w17);
  /* #46: @5 = (@5+@19) */
  w5 += w19;
  /* #47: @19 = 0.001 */
  w19 = 1.0000000000000000e-003;
  /* #48: @20 = @7[2] */
  for (rr=(&w20), ss=w7+2; ss!=w7+3; ss+=1) *rr++ = *ss;
  /* #49: @21 = @3[8] */
  for (rr=(&w21), ss=w3+8; ss!=w3+9; ss+=1) *rr++ = *ss;
  /* #50: @21 = (@20-@21) */
  w21  = (w20-w21);
  /* #51: @21 = (@19*@21) */
  w21  = (w19*w21);
  /* #52: @22 = @3[8] */
  for (rr=(&w22), ss=w3+8; ss!=w3+9; ss+=1) *rr++ = *ss;
  /* #53: @20 = (@20-@22) */
  w20 -= w22;
  /* #54: @22 = (@21*@20) */
  w22  = (w21*w20);
  /* #55: @5 = (@5+@22) */
  w5 += w22;
  /* #56: output[0][0] = @5 */
  if (res[0]) res[0][0] = w5;
  /* #57: @5 = @1[0] */
  for (rr=(&w5), ss=w1+0; ss!=w1+1; ss+=1) *rr++ = *ss;
  /* #58: output[1][0] = @5 */
  if (res[1]) res[1][0] = w5;
  /* #59: @5 = @1[1] */
  for (rr=(&w5), ss=w1+1; ss!=w1+2; ss+=1) *rr++ = *ss;
  /* #60: @22 = @1[0] */
  for (rr=(&w22), ss=w1+0; ss!=w1+1; ss+=1) *rr++ = *ss;
  /* #61: @23 = 0.2 */
  w23 = 2.0000000000000001e-001;
  /* #62: @24 = @1[0] */
  for (rr=(&w24), ss=w1+0; ss!=w1+1; ss+=1) *rr++ = *ss;
  /* #63: @25 = @7[0] */
  for (rr=(&w25), ss=w7+0; ss!=w7+1; ss+=1) *rr++ = *ss;
  /* #64: @26 = @3[3] */
  for (rr=(&w26), ss=w3+3; ss!=w3+4; ss+=1) *rr++ = *ss;
  /* #65: @27 = f(@24, @25, @26) */
  arg1[0]=(&w24);
  arg1[1]=(&w25);
  arg1[2]=(&w26);
  res1[0]=(&w27);
  if (casadi_f3(arg1, res1, iw, w, 0)) return 1;
  /* #66: @27 = (@23*@27) */
  w27  = (w23*w27);
  /* #67: @22 = (@22+@27) */
  w22 += w27;
  /* #68: @5 = (@5-@22) */
  w5 -= w22;
  /* #69: output[1][1] = @5 */
  if (res[1]) res[1][1] = w5;
  /* #70: @5 = @1[2] */
  for (rr=(&w5), ss=w1+2; ss!=w1+3; ss+=1) *rr++ = *ss;
  /* #71: @22 = @1[1] */
  for (rr=(&w22), ss=w1+1; ss!=w1+2; ss+=1) *rr++ = *ss;
  /* #72: @27 = 0.2 */
  w27 = 2.0000000000000001e-001;
  /* #73: @28 = @1[1] */
  for (rr=(&w28), ss=w1+1; ss!=w1+2; ss+=1) *rr++ = *ss;
  /* #74: @29 = @7[1] */
  for (rr=(&w29), ss=w7+1; ss!=w7+2; ss+=1) *rr++ = *ss;
  /* #75: @30 = @3[6] */
  for (rr=(&w30), ss=w3+6; ss!=w3+7; ss+=1) *rr++ = *ss;
  /* #76: @31 = f(@28, @29, @30) */
  arg1[0]=(&w28);
  arg1[1]=(&w29);
  arg1[2]=(&w30);
  res1[0]=(&w31);
  if (casadi_f3(arg1, res1, iw, w, 0)) return 1;
  /* #77: @31 = (@27*@31) */
  w31  = (w27*w31);
  /* #78: @22 = (@22+@31) */
  w22 += w31;
  /* #79: @5 = (@5-@22) */
  w5 -= w22;
  /* #80: output[1][2] = @5 */
  if (res[1]) res[1][2] = w5;
  /* #81: @5 = @1[3] */
  for (rr=(&w5), ss=w1+3; ss!=w1+4; ss+=1) *rr++ = *ss;
  /* #82: @22 = @1[2] */
  for (rr=(&w22), ss=w1+2; ss!=w1+3; ss+=1) *rr++ = *ss;
  /* #83: @31 = 0.2 */
  w31 = 2.0000000000000001e-001;
  /* #84: @32 = @1[2] */
  for (rr=(&w32), ss=w1+2; ss!=w1+3; ss+=1) *rr++ = *ss;
  /* #85: @33 = @7[2] */
  for (rr=(&w33), ss=w7+2; ss!=w7+3; ss+=1) *rr++ = *ss;
  /* #86: @34 = @3[9] */
  for (rr=(&w34), ss=w3+9; ss!=w3+10; ss+=1) *rr++ = *ss;
  /* #87: @35 = f(@32, @33, @34) */
  arg1[0]=(&w32);
  arg1[1]=(&w33);
  arg1[2]=(&w34);
  res1[0]=(&w35);
  if (casadi_f3(arg1, res1, iw, w, 0)) return 1;
  /* #88: @35 = (@31*@35) */
  w35  = (w31*w35);
  /* #89: @22 = (@22+@35) */
  w22 += w35;
  /* #90: @5 = (@5-@22) */
  w5 -= w22;
  /* #91: output[1][3] = @5 */
  if (res[1]) res[1][3] = w5;
  /* #92: output[1][4] = @7 */
  if (res[1]) casadi_copy(w7, 3, res[1]+4);
  /* #93: output[1][5] = @1 */
  if (res[1]) casadi_copy(w1, 4, res[1]+7);
  /* #94: @36 = input[3][0] */
  casadi_copy(arg[3], 11, w36);
  /* #95: {@5, @22, @35, @37, @7, @1} = vertsplit(@36) */
  w5 = w36[0];
  w22 = w36[1];
  w35 = w36[2];
  w37 = w36[3];
  casadi_copy(w36+4, 3, w7);
  casadi_copy(w36+7, 4, w1);
  /* #96: @7 = @7' */
  /* #97: @38 = 00 */
  /* #98: @39 = (@31*@37) */
  w39  = (w31*w37);
  /* #99: @39 = (-@39) */
  w39 = (- w39 );
  /* #100: {@40, @41, NULL} = adj1_f(@32, @33, @34, @38, @39) */
  arg1[0]=(&w32);
  arg1[1]=(&w33);
  arg1[2]=(&w34);
  arg1[3]=0;
  arg1[4]=(&w39);
  res1[0]=(&w40);
  res1[1]=(&w41);
  res1[2]=0;
  if (casadi_f9(arg1, res1, iw, w, 0)) return 1;
  /* #101: (@7[2] += @41) */
  for (rr=w7+2, ss=(&w41); rr!=w7+3; rr+=1) *rr += *ss++;
  /* #102: @38 = 00 */
  /* #103: @41 = (@27*@35) */
  w41  = (w27*w35);
  /* #104: @41 = (-@41) */
  w41 = (- w41 );
  /* #105: {@39, @42, NULL} = adj1_f(@28, @29, @30, @38, @41) */
  arg1[0]=(&w28);
  arg1[1]=(&w29);
  arg1[2]=(&w30);
  arg1[3]=0;
  arg1[4]=(&w41);
  res1[0]=(&w39);
  res1[1]=(&w42);
  res1[2]=0;
  if (casadi_f9(arg1, res1, iw, w, 0)) return 1;
  /* #106: (@7[1] += @42) */
  for (rr=w7+1, ss=(&w42); rr!=w7+2; rr+=1) *rr += *ss++;
  /* #107: @38 = 00 */
  /* #108: @42 = (@23*@22) */
  w42  = (w23*w22);
  /* #109: @42 = (-@42) */
  w42 = (- w42 );
  /* #110: {@41, @43, NULL} = adj1_f(@24, @25, @26, @38, @42) */
  arg1[0]=(&w24);
  arg1[1]=(&w25);
  arg1[2]=(&w26);
  arg1[3]=0;
  arg1[4]=(&w42);
  res1[0]=(&w41);
  res1[1]=(&w43);
  res1[2]=0;
  if (casadi_f9(arg1, res1, iw, w, 0)) return 1;
  /* #111: (@7[0] += @43) */
  for (rr=w7+0, ss=(&w43); rr!=w7+1; rr+=1) *rr += *ss++;
  /* #112: @43 = input[2][0] */
  w43 = arg[2] ? arg[2][0] : 0;
  /* #113: @42 = (@21*@43) */
  w42  = (w21*w43);
  /* #114: @44 = (@20*@43) */
  w44  = (w20*w43);
  /* #115: @44 = (@19*@44) */
  w44  = (w19*w44);
  /* #116: @42 = (@42+@44) */
  w42 += w44;
  /* #117: (@7[2] += @42) */
  for (rr=w7+2, ss=(&w42); rr!=w7+3; rr+=1) *rr += *ss++;
  /* #118: @42 = (@15*@43) */
  w42  = (w15*w43);
  /* #119: @44 = (@14*@43) */
  w44  = (w14*w43);
  /* #120: @44 = (@13*@44) */
  w44  = (w13*w44);
  /* #121: @42 = (@42+@44) */
  w42 += w44;
  /* #122: (@7[1] += @42) */
  for (rr=w7+1, ss=(&w42); rr!=w7+2; rr+=1) *rr += *ss++;
  /* #123: @42 = (@9*@43) */
  w42  = (w9*w43);
  /* #124: @44 = (@8*@43) */
  w44  = (w8*w43);
  /* #125: @44 = (@6*@44) */
  w44  = (w6*w44);
  /* #126: @42 = (@42+@44) */
  w42 += w44;
  /* #127: (@7[0] += @42) */
  for (rr=w7+0, ss=(&w42); rr!=w7+1; rr+=1) *rr += *ss++;
  /* #128: output[2][0] = @7 */
  casadi_copy(w7, 3, res[2]);
  /* #129: @1 = @1' */
  /* #130: (@1[2] += @40) */
  for (rr=w1+2, ss=(&w40); rr!=w1+3; rr+=1) *rr += *ss++;
  /* #131: @40 = (-@37) */
  w40 = (- w37 );
  /* #132: (@1[2] += @40) */
  for (rr=w1+2, ss=(&w40); rr!=w1+3; rr+=1) *rr += *ss++;
  /* #133: (@1[3] += @37) */
  for (rr=w1+3, ss=(&w37); rr!=w1+4; rr+=1) *rr += *ss++;
  /* #134: (@1[1] += @39) */
  for (rr=w1+1, ss=(&w39); rr!=w1+2; rr+=1) *rr += *ss++;
  /* #135: @39 = (-@35) */
  w39 = (- w35 );
  /* #136: (@1[1] += @39) */
  for (rr=w1+1, ss=(&w39); rr!=w1+2; rr+=1) *rr += *ss++;
  /* #137: (@1[2] += @35) */
  for (rr=w1+2, ss=(&w35); rr!=w1+3; rr+=1) *rr += *ss++;
  /* #138: (@1[0] += @41) */
  for (rr=w1+0, ss=(&w41); rr!=w1+1; rr+=1) *rr += *ss++;
  /* #139: @41 = (-@22) */
  w41 = (- w22 );
  /* #140: (@1[0] += @41) */
  for (rr=w1+0, ss=(&w41); rr!=w1+1; rr+=1) *rr += *ss++;
  /* #141: (@1[1] += @22) */
  for (rr=w1+1, ss=(&w22); rr!=w1+2; rr+=1) *rr += *ss++;
  /* #142: (@1[0] += @5) */
  for (rr=w1+0, ss=(&w5); rr!=w1+1; rr+=1) *rr += *ss++;
  /* #143: @5 = (@18*@43) */
  w5  = (w18*w43);
  /* #144: @22 = (@17*@43) */
  w22  = (w17*w43);
  /* #145: @22 = (@16*@22) */
  w22  = (w16*w22);
  /* #146: @5 = (@5+@22) */
  w5 += w22;
  /* #147: (@1[2] += @5) */
  for (rr=w1+2, ss=(&w5); rr!=w1+3; rr+=1) *rr += *ss++;
  /* #148: @5 = (@12*@43) */
  w5  = (w12*w43);
  /* #149: @22 = (@11*@43) */
  w22  = (w11*w43);
  /* #150: @22 = (@10*@22) */
  w22  = (w10*w22);
  /* #151: @5 = (@5+@22) */
  w5 += w22;
  /* #152: (@1[1] += @5) */
  for (rr=w1+1, ss=(&w5); rr!=w1+2; rr+=1) *rr += *ss++;
  /* #153: @5 = (@4*@43) */
  w5  = (w4*w43);
  /* #154: @22 = (@2*@43) */
  w22  = (w2*w43);
  /* #155: @22 = (@0*@22) */
  w22  = (w0*w22);
  /* #156: @5 = (@5+@22) */
  w5 += w22;
  /* #157: (@1[0] += @5) */
  for (rr=w1+0, ss=(&w5); rr!=w1+1; rr+=1) *rr += *ss++;
  /* #158: output[2][1] = @1 */
  if (res[2]) casadi_copy(w1, 4, res[2]+3);
  /* #159: @3 = zeros(1x10) */
  casadi_clear(w3, 10);
  /* #160: @38 = 00 */
  /* #161: {NULL, @5, @22, @41, NULL, NULL} = vertsplit(@36) */
  w5 = w36[1];
  w22 = w36[2];
  w41 = w36[3];
  /* #162: @31 = (@31*@41) */
  w31 *= w41;
  /* #163: @31 = (-@31) */
  w31 = (- w31 );
  /* #164: {NULL, NULL, @41} = adj1_f(@32, @33, @34, @38, @31) */
  arg1[0]=(&w32);
  arg1[1]=(&w33);
  arg1[2]=(&w34);
  arg1[3]=0;
  arg1[4]=(&w31);
  res1[0]=0;
  res1[1]=0;
  res1[2]=(&w41);
  if (casadi_f9(arg1, res1, iw, w, 0)) return 1;
  /* #165: (@3[9] += @41) */
  for (rr=w3+9, ss=(&w41); rr!=w3+10; rr+=1) *rr += *ss++;
  /* #166: @38 = 00 */
  /* #167: @27 = (@27*@22) */
  w27 *= w22;
  /* #168: @27 = (-@27) */
  w27 = (- w27 );
  /* #169: {NULL, NULL, @22} = adj1_f(@28, @29, @30, @38, @27) */
  arg1[0]=(&w28);
  arg1[1]=(&w29);
  arg1[2]=(&w30);
  arg1[3]=0;
  arg1[4]=(&w27);
  res1[0]=0;
  res1[1]=0;
  res1[2]=(&w22);
  if (casadi_f9(arg1, res1, iw, w, 0)) return 1;
  /* #170: (@3[6] += @22) */
  for (rr=w3+6, ss=(&w22); rr!=w3+7; rr+=1) *rr += *ss++;
  /* #171: @38 = 00 */
  /* #172: @23 = (@23*@5) */
  w23 *= w5;
  /* #173: @23 = (-@23) */
  w23 = (- w23 );
  /* #174: {NULL, NULL, @5} = adj1_f(@24, @25, @26, @38, @23) */
  arg1[0]=(&w24);
  arg1[1]=(&w25);
  arg1[2]=(&w26);
  arg1[3]=0;
  arg1[4]=(&w23);
  res1[0]=0;
  res1[1]=0;
  res1[2]=(&w5);
  if (casadi_f9(arg1, res1, iw, w, 0)) return 1;
  /* #175: (@3[3] += @5) */
  for (rr=w3+3, ss=(&w5); rr!=w3+4; rr+=1) *rr += *ss++;
  /* #176: @21 = (@21*@43) */
  w21 *= w43;
  /* #177: @21 = (-@21) */
  w21 = (- w21 );
  /* #178: (@3[8] += @21) */
  for (rr=w3+8, ss=(&w21); rr!=w3+9; rr+=1) *rr += *ss++;
  /* #179: @20 = (@20*@43) */
  w20 *= w43;
  /* #180: @19 = (@19*@20) */
  w19 *= w20;
  /* #181: @19 = (-@19) */
  w19 = (- w19 );
  /* #182: (@3[8] += @19) */
  for (rr=w3+8, ss=(&w19); rr!=w3+9; rr+=1) *rr += *ss++;
  /* #183: @18 = (@18*@43) */
  w18 *= w43;
  /* #184: @18 = (-@18) */
  w18 = (- w18 );
  /* #185: (@3[7] += @18) */
  for (rr=w3+7, ss=(&w18); rr!=w3+8; rr+=1) *rr += *ss++;
  /* #186: @17 = (@17*@43) */
  w17 *= w43;
  /* #187: @16 = (@16*@17) */
  w16 *= w17;
  /* #188: @16 = (-@16) */
  w16 = (- w16 );
  /* #189: (@3[7] += @16) */
  for (rr=w3+7, ss=(&w16); rr!=w3+8; rr+=1) *rr += *ss++;
  /* #190: @15 = (@15*@43) */
  w15 *= w43;
  /* #191: @15 = (-@15) */
  w15 = (- w15 );
  /* #192: (@3[5] += @15) */
  for (rr=w3+5, ss=(&w15); rr!=w3+6; rr+=1) *rr += *ss++;
  /* #193: @14 = (@14*@43) */
  w14 *= w43;
  /* #194: @13 = (@13*@14) */
  w13 *= w14;
  /* #195: @13 = (-@13) */
  w13 = (- w13 );
  /* #196: (@3[5] += @13) */
  for (rr=w3+5, ss=(&w13); rr!=w3+6; rr+=1) *rr += *ss++;
  /* #197: @12 = (@12*@43) */
  w12 *= w43;
  /* #198: @12 = (-@12) */
  w12 = (- w12 );
  /* #199: (@3[4] += @12) */
  for (rr=w3+4, ss=(&w12); rr!=w3+5; rr+=1) *rr += *ss++;
  /* #200: @11 = (@11*@43) */
  w11 *= w43;
  /* #201: @10 = (@10*@11) */
  w10 *= w11;
  /* #202: @10 = (-@10) */
  w10 = (- w10 );
  /* #203: (@3[4] += @10) */
  for (rr=w3+4, ss=(&w10); rr!=w3+5; rr+=1) *rr += *ss++;
  /* #204: @9 = (@9*@43) */
  w9 *= w43;
  /* #205: @9 = (-@9) */
  w9 = (- w9 );
  /* #206: (@3[2] += @9) */
  for (rr=w3+2, ss=(&w9); rr!=w3+3; rr+=1) *rr += *ss++;
  /* #207: @8 = (@8*@43) */
  w8 *= w43;
  /* #208: @6 = (@6*@8) */
  w6 *= w8;
  /* #209: @6 = (-@6) */
  w6 = (- w6 );
  /* #210: (@3[2] += @6) */
  for (rr=w3+2, ss=(&w6); rr!=w3+3; rr+=1) *rr += *ss++;
  /* #211: @4 = (@4*@43) */
  w4 *= w43;
  /* #212: @4 = (-@4) */
  w4 = (- w4 );
  /* #213: (@3[1] += @4) */
  for (rr=w3+1, ss=(&w4); rr!=w3+2; rr+=1) *rr += *ss++;
  /* #214: @2 = (@2*@43) */
  w2 *= w43;
  /* #215: @0 = (@0*@2) */
  w0 *= w2;
  /* #216: @0 = (-@0) */
  w0 = (- w0 );
  /* #217: (@3[1] += @0) */
  for (rr=w3+1, ss=(&w0); rr!=w3+2; rr+=1) *rr += *ss++;
  /* #218: output[3][0] = @3 */
  casadi_copy(w3, 10, res[3]);
  return 0;
}

/* qpsol:(h[7x7,6nz],g[7],a[11x7,17nz],lba[11],uba[11],lbx[7],ubx[7],x0[7],lam_x0[7],lam_a0[11],q[],p[])->(x[7],cost,lam_a[11],lam_x[7]) */
static int casadi_f10(const casadi_real** arg, casadi_real** res, casadi_int* iw, casadi_real* w, int mem) {
  int flag;
  struct casadi_qp_data d;
  struct casadi_qp_prob p;
  p.sp_a = casadi_s5;
  p.sp_h = casadi_s7;
  p.sp_at = casadi_s6;
  p.sp_kkt = casadi_s8;
  p.sp_v = casadi_s9;
  p.sp_r = casadi_s10;
  p.prinv = casadi_s11;
  p.pc =  casadi_s12;
  casadi_qp_setup(&p);
  p.max_iter = 1000;
  p.min_lam = 0;
  p.constr_viol_tol = 1e-008;
  p.dual_inf_tol = 1e-008;
  d.prob = &p;
  d.nz_h = arg[0];
  d.g = arg[1];
  d.nz_a = arg[2];
  casadi_qp_init(&d, &iw, &w);
  /* Pass bounds on z */
  if (arg[5]) {
    casadi_copy(arg[5], 7, d.lbz);
  } else {
    casadi_fill(d.lbz, 7, -casadi_inf);
  }
  if (arg[3]) {
    casadi_copy(arg[3], 11, d.lbz+7);
  } else {
    casadi_fill(d.lbz+7, 11, -casadi_inf);
  }
  if (arg[6]) {
    casadi_copy(arg[6], 7, d.ubz);
  } else {
    casadi_fill(d.ubz, 7, casadi_inf);
  }
  if (arg[4]) {
    casadi_copy(arg[4], 11, d.ubz+7);
  } else {
    casadi_fill(d.ubz+7, 11, casadi_inf);
  }
  /* Pass initial guess */
  if (arg[7]) {
    casadi_copy(arg[7], 7, d.z);
  } else {
    casadi_clear(d.z, 7);
  }
  casadi_fill(d.z+7, 11, casadi_nan);
  if (arg[8]) {
    casadi_copy(arg[8], 7, d.lam);
  } else {
    casadi_clear(d.lam, 7);
  }
  if (arg[9]) {
    casadi_copy(arg[9], 11, d.lam+7);
  } else {
    casadi_clear(d.lam+7, 11);
  }
  /* Solve QP */
  if (casadi_qp_reset(&d)) return 1;
  while (1) {
    flag = casadi_qp_prepare(&d);
    if (flag || casadi_qp_iterate(&d)) break;
  }
  /* Get solution */
  if (res[1]) casadi_copy(&d.f, 1, res[1]);
  if (res[0]) casadi_copy(d.z, 7, res[0]);
  if (res[3]) casadi_copy(d.lam, 7, res[3]);
  if (res[2]) casadi_copy(d.lam+7, 11, res[2]);
  return d.status != QP_SUCCESS;
  return 0;
}

/* solver:(x0[7],p[10],lbx[7],ubx[7],lbg[11],ubg[11],lam_x0[7],lam_g0[11])->(x[7],f,g[11],lam_x[7],lam_g[11],lam_p[10]) */
static int casadi_f1(const casadi_real** arg, casadi_real** res, casadi_int* iw, casadi_real* w, int mem) {
  casadi_int iter_count=0, ls_iter=0, *m_iw;
  casadi_real F_sens, du_inf, dx_norminf, fk_cand, l1, l1_cand, l1_infeas, m_f, **m_res=res+6, *m_w, pr_inf, sigma=0.0, t=0.0, tl1;
  const casadi_real **m_arg=arg+8, *m_p=arg[1], one=1;
  struct casadi_nlpsol_data d_nlp;
  struct casadi_nlpsol_prob p_nlp;
  struct casadi_sqpmethod_data d;
  struct casadi_sqpmethod_prob p;
  d_nlp.prob = &p_nlp;
  p_nlp.nx = 7;
  p_nlp.ng = 11;
  p_nlp.np = 10;
  casadi_nlpsol_init(&d_nlp, &iw, &w);
  if (arg[0]) {
    casadi_copy(arg[0], 7, d_nlp.z);
  } else {
    casadi_clear(d_nlp.z, 7);
  }
  if (arg[6]) {
    casadi_copy(arg[6], 7, d_nlp.lam);
  } else {
    casadi_clear(d_nlp.lam, 7);
  }
  if (arg[7]) {
    casadi_copy(arg[7], 11, d_nlp.lam+7);
  } else {
    casadi_clear(d_nlp.lam+7, 11);
  }
  if (arg[2]) {
    casadi_copy(arg[2], 7, d_nlp.lbz);
  } else {
    casadi_fill(d_nlp.lbz, 7, -casadi_inf);
  }
  if (arg[3]) {
    casadi_copy(arg[3], 7, d_nlp.ubz);
  } else {
    casadi_fill(d_nlp.ubz, 7, casadi_inf);
  }
  if (arg[4]) {
    casadi_copy(arg[4], 11, d_nlp.lbz+7);
  } else {
    casadi_fill(d_nlp.lbz+7, 11, -casadi_inf);
  }
  if (arg[5]) {
    casadi_copy(arg[5], 11, d_nlp.ubz+7);
  } else {
    casadi_fill(d_nlp.ubz+7, 11, casadi_inf);
  }
  d.prob = &p;
  p.sp_hr = casadi_s7;
  p.sp_h = casadi_s7;
  p.sz_w_cvx = 0;
  p.sz_iw_cvx = 0;
  p.sp_a = casadi_s5;
  p.merit_memsize = 4;
  p.max_iter_ls = 3;
  p.nlp = &p_nlp;
  casadi_sqpmethod_init(&d, &iw, &w);
  m_w = w;
  m_iw = iw;
  casadi_clear(d.dx, 7);
  /* MAIN OPTIMIZATION LOOP */
  while (1) {
    /* Evaluate f, g and first order derivative information */
    m_arg[0] = d_nlp.z;
    m_arg[1] = m_p;
    m_res[0] = &m_f;
    m_res[1] = d.gf;
    m_res[2] = d_nlp.z+7;
    m_res[3] = d.Jk;
    if (casadi_f4(m_arg, m_res, m_iw, m_w, 0)) return 1;
    /* Evaluate the gradient of the Lagrangian */
    casadi_copy(d.gf, 7, d.gLag);
    casadi_mv(d.Jk, casadi_s5, d_nlp.lam+7, d.gLag, 1);
    casadi_axpy(7, 1.0, d_nlp.lam, d.gLag);
    /* Primal infeasability */
    pr_inf = casadi_max_viol(18, d_nlp.z, d_nlp.lbz, d_nlp.ubz);
    /* inf-norm of lagrange gradient */
    du_inf = casadi_norm_inf(7, d.gLag);
    /* inf-norm of step */
    dx_norminf = casadi_norm_inf(7, d.dx);
    /* Checking convergence criteria */
    if (iter_count >= 0 && pr_inf < 1e-006 && du_inf < 1e-006) break;
    if (iter_count >= 2000) break;
    if (iter_count >= 1 && iter_count >= 0 && dx_norminf <= 1e-010) break;
    /* Update/reset exact Hessian */
    m_arg[0] = d_nlp.z;
    m_arg[1] = m_p;
    m_arg[2] = &one;
    m_arg[3] = d_nlp.lam+7;
    m_res[0] = d.Bk;
    if (casadi_f6(m_arg, m_res, m_iw, m_w, 0)) return 1;
    /* Formulate the QP */
    casadi_copy(d_nlp.lbz, 18, d.lbdz);
    casadi_axpy(18, -1.0, d_nlp.z, d.lbdz);
    casadi_copy(d_nlp.ubz, 18, d.ubdz);
    casadi_axpy(18, -1.0, d_nlp.z, d.ubdz);
    /* Initial guess */
    casadi_copy(d_nlp.lam, 18, d.dlam);
    casadi_clear(d.dx, 7);
    /* Increase counter */
    iter_count++;
    /* Solve the QP */
    m_arg[0] = 0;
    m_arg[1] = 0;
    m_arg[2] = 0;
    m_arg[3] = 0;
    m_arg[4] = 0;
    m_arg[5] = 0;
    m_arg[6] = 0;
    m_arg[7] = 0;
    m_arg[8] = 0;
    m_arg[9] = 0;
    m_arg[10] = 0;
    m_arg[11] = 0;
    m_arg[0] = d.Bk;
    m_arg[1] = d.gf;
    m_arg[7] = d.dx;
    m_arg[8] = d.dlam;
    m_arg[9] = d.dlam+7;
    m_arg[5] = d.lbdz;
    m_arg[6] = d.ubdz;
    m_arg[2] = d.Jk;
    m_arg[3] = d.lbdz+7;
    m_arg[4] = d.ubdz+7;
    m_res[0] = 0;
    m_res[1] = 0;
    m_res[2] = 0;
    m_res[3] = 0;
    m_res[0] = d.dx;
    m_res[3] = d.dlam;
    m_res[2] = d.dlam+7;
    casadi_f10(m_arg, m_res, m_iw, m_w, 0);
    /* Detecting indefiniteness */
    /* Calculate penalty parameter of merit function */
    sigma = casadi_fmax(sigma, (1.01*casadi_norm_inf(18, d.dlam)));
    /* Calculate L1-merit function in the actual iterate */
    l1_infeas = casadi_sum_viol(18, d_nlp.z, d_nlp.lbz, d_nlp.ubz);
    /* Right-hand side of Armijo condition */
    F_sens = casadi_dot(7, d.dx, d.gf);
    tl1 = F_sens - sigma * l1_infeas;
    l1 = m_f + sigma * l1_infeas;
    /* Stepsize */
    t = 1.0;
    /* Merit function value in candidate */
    l1_cand = 0.0;
    /* Reset line-search counter, success marker */
    ls_iter = 0;
    /* Line-search loop */
    while (1) {
      /*  Increase counter */
      ls_iter++;
      /* Candidate step */
      casadi_copy(d_nlp.z, 7, d.z_cand);
      casadi_axpy(7, t, d.dx, d.z_cand);
      /* Evaluating objective and constraints */
      m_arg[0] = d.z_cand;
      ;m_arg[1] = m_p;
      ;m_res[0] = &fk_cand;
      ;m_res[1] = d.z_cand+7;
      ;if (casadi_f2(m_arg, m_res, m_iw, m_w, 0)) {
        /* Avoid infinite recursion */
        if (ls_iter == 3) {
          break;
        }
        /* line-search failed, skip iteration */
        t = 0.8* t;
        continue;
      }
      /* Calculating merit-function in candidate */
      l1_cand = fk_cand + sigma * casadi_sum_viol(18, d.z_cand, d_nlp.lbz, d_nlp.ubz);
      if (l1_cand <= l1 + t * 0.0001* tl1) {
        break;
      }
      /* Line-search not successful, but we accept it. */
      if (ls_iter == 3) {
        break;
      }
      /* Backtracking */
      t = 0.8* t;
    }
    /* Candidate accepted, update dual variables */
    casadi_scal(18, 1-t, d_nlp.lam);
    casadi_axpy(18, t, d.dlam, d_nlp.lam);
    casadi_scal(7, t, d.dx);
    /* Take step */
    casadi_axpy(7, 1.0, d.dx, d_nlp.z);
  }
  m_arg[0] = d_nlp.z;
  m_arg[1] = m_p;
  m_arg[2] = &one;
  m_arg[3] = d_nlp.lam+7;
  m_res[0] = 0;
  m_res[1] = 0;
  m_res[2] = 0;
  m_res[3] = d_nlp.lam_p;
  if (casadi_f8(m_arg, m_res, m_iw, m_w, 0)) return 1;
  casadi_scal(10, -1.0, d_nlp.lam_p);
  if (res[0]) casadi_copy(d_nlp.z, 7, res[0]);
  if (res[2]) casadi_copy(d_nlp.z+7, 11, res[2]);
  if (res[3]) casadi_copy(d_nlp.lam, 7, res[3]);
  if (res[4]) casadi_copy(d_nlp.lam+7, 11, res[4]);
  if (res[5]) casadi_copy(d_nlp.lam_p, 10, res[5]);
  if (res[1]) casadi_copy(&m_f, 1, res[1]);
  return 0;
}

/* helper:(i0[7],i1[10],i2[11])->(o0[1x4]) */
static int casadi_f11(const casadi_real** arg, casadi_real** res, casadi_int* iw, casadi_real* w, int mem) {
  casadi_real *w0=w+0;
  /* #0: @0 = input[0][1] */
  casadi_copy(arg[0] ? arg[0]+3 : 0, 4, w0);
  /* #1: output[0][0] = @0 */
  casadi_copy(w0, 4, res[0]);
  return 0;
}

/* M:(i0[1x10])->(o0[1x4]) */
static int casadi_f0(const casadi_real** arg, casadi_real** res, casadi_int* iw, casadi_real* w, int mem) {
  casadi_int i;
  casadi_real **res1=res+1, *rr, *ss;
  const casadi_real **arg1=arg+1, *cs;
  casadi_real *w0=w+577, *w1=w+584, *w2=w+594, *w3=w+604, *w4=w+611, w5, w6, w7, w8, *w9=w+622, *w10=w+625, *w11=w+629, *w12=w+640, *w13=w+651, *w14=w+658, *w15=w+669, *w16=w+676;
  /* #0: @0 = zeros(7x1) */
  casadi_clear(w0, 7);
  /* #1: @1 = input[0][0] */
  casadi_copy(arg[0], 10, w1);
  /* #2: @2 = @1' */
  casadi_copy(w1, 10, w2);
  /* #3: @3 = -inf(7x1) */
  casadi_fill(w3, 7, -casadi_inf);
  /* #4: @4 = inf(7x1) */
  casadi_fill(w4, 7, casadi_inf);
  /* #5: @5 = @1[0] */
  for (rr=(&w5), ss=w1+0; ss!=w1+1; ss+=1) *rr++ = *ss;
  /* #6: @6 = 0 */
  w6 = 0.;
  /* #7: @7 = 0 */
  w7 = 0.;
  /* #8: @8 = 0 */
  w8 = 0.;
  /* #9: @9 = all_-250(3x1) */
  casadi_fill(w9, 3, -250.);
  /* #10: @10 = zeros(4x1) */
  casadi_clear(w10, 4);
  /* #11: @11 = vertcat(@5, @6, @7, @8, @9, @10) */
  rr=w11;
  *rr++ = w5;
  *rr++ = w6;
  *rr++ = w7;
  *rr++ = w8;
  for (i=0, cs=w9; i<3; ++i) *rr++ = *cs++;
  for (i=0, cs=w10; i<4; ++i) *rr++ = *cs++;
  /* #12: @9 = all_250(3x1) */
  casadi_fill(w9, 3, 250.);
  /* #13: @10 = all_60(4x1) */
  casadi_fill(w10, 4, 60.);
  /* #14: @12 = vertcat(@5, @6, @7, @8, @9, @10) */
  rr=w12;
  *rr++ = w5;
  *rr++ = w6;
  *rr++ = w7;
  *rr++ = w8;
  for (i=0, cs=w9; i<3; ++i) *rr++ = *cs++;
  for (i=0, cs=w10; i<4; ++i) *rr++ = *cs++;
  /* #15: @13 = zeros(7x1) */
  casadi_clear(w13, 7);
  /* #16: @14 = zeros(11x1) */
  casadi_clear(w14, 11);
  /* #17: {@15, NULL, NULL, NULL, @16, NULL} = solver(@0, @2, @3, @4, @11, @12, @13, @14) */
  arg1[0]=w0;
  arg1[1]=w2;
  arg1[2]=w3;
  arg1[3]=w4;
  arg1[4]=w11;
  arg1[5]=w12;
  arg1[6]=w13;
  arg1[7]=w14;
  res1[0]=w15;
  res1[1]=0;
  res1[2]=0;
  res1[3]=0;
  res1[4]=w16;
  res1[5]=0;
  if (casadi_f1(arg1, res1, iw, w, 0)) return 1;
  /* #18: @10 = helper(@15, @2, @16) */
  arg1[0]=w15;
  arg1[1]=w2;
  arg1[2]=w16;
  res1[0]=w10;
  if (casadi_f11(arg1, res1, iw, w, 0)) return 1;
  /* #19: output[0][0] = @10 */
  casadi_copy(w10, 4, res[0]);
  return 0;
}

CASADI_SYMBOL_EXPORT int M(const casadi_real** arg, casadi_real** res, casadi_int* iw, casadi_real* w, int mem){
  return casadi_f0(arg, res, iw, w, mem);
}

CASADI_SYMBOL_EXPORT int M_alloc_mem(void) {
  return 0;
}

CASADI_SYMBOL_EXPORT int M_init_mem(int mem) {
  return 0;
}

CASADI_SYMBOL_EXPORT void M_free_mem(int mem) {
}

CASADI_SYMBOL_EXPORT int M_checkout(void) {
  return 0;
}

CASADI_SYMBOL_EXPORT void M_release(int mem) {
}

CASADI_SYMBOL_EXPORT void M_incref(void) {
}

CASADI_SYMBOL_EXPORT void M_decref(void) {
}

CASADI_SYMBOL_EXPORT casadi_int M_n_in(void) { return 1;}

CASADI_SYMBOL_EXPORT casadi_int M_n_out(void) { return 1;}

CASADI_SYMBOL_EXPORT casadi_real M_default_in(casadi_int i){
  switch (i) {
    default: return 0;
  }
}

CASADI_SYMBOL_EXPORT const char* M_name_in(casadi_int i){
  switch (i) {
    case 0: return "i0";
    default: return 0;
  }
}

CASADI_SYMBOL_EXPORT const char* M_name_out(casadi_int i){
  switch (i) {
    case 0: return "o0";
    default: return 0;
  }
}

CASADI_SYMBOL_EXPORT const casadi_int* M_sparsity_in(casadi_int i) {
  switch (i) {
    case 0: return casadi_s13;
    default: return 0;
  }
}

CASADI_SYMBOL_EXPORT const casadi_int* M_sparsity_out(casadi_int i) {
  switch (i) {
    case 0: return casadi_s14;
    default: return 0;
  }
}

CASADI_SYMBOL_EXPORT int M_work(casadi_int *sz_arg, casadi_int* sz_res, casadi_int *sz_iw, casadi_int *sz_w) {
  if (sz_arg) *sz_arg = 26;
  if (sz_res) *sz_res = 17;
  if (sz_iw) *sz_iw = 90;
  if (sz_w) *sz_w = 687;
  return 0;
}

#ifdef MATLAB_MEX_FILE
void mex_M(int resc, mxArray *resv[], int argc, const mxArray *argv[]) {
  casadi_int i, j;
  casadi_real w[701];
  casadi_int iw[90];
  const casadi_real* arg[26] = {0};
  casadi_real* res[17] = {0};
  if (argc>1) mexErrMsgIdAndTxt("Casadi:RuntimeError","Evaluation of \"M\" failed. Too many input arguments (%d, max 1)", argc);
  if (resc>1) mexErrMsgIdAndTxt("Casadi:RuntimeError","Evaluation of \"M\" failed. Too many output arguments (%d, max 1)", resc);
  if (--argc>=0) arg[0] = casadi_from_mex(argv[0], w, casadi_s13, w+14);
  --resc;
  res[0] = w+10;
  i = M(arg, res, iw, w+14, 0);
  if (i) mexErrMsgIdAndTxt("Casadi:RuntimeError","Evaluation of \"M\" failed.");
  if (res[0]) resv[0] = casadi_to_mex(casadi_s14, res[0]);
}
#endif


#ifdef MATLAB_MEX_FILE
void mexFunction(int resc, mxArray *resv[], int argc, const mxArray *argv[]) {
  char buf[2];
  int buf_ok = --argc >= 0 && !mxGetString(*argv++, buf, sizeof(buf));
  if (!buf_ok) {
    /* name error */
  } else if (strcmp(buf, "M")==0) {
    mex_M(resc, resv, argc, argv);
    return;
  }
  mexErrMsgTxt("First input should be a command string. Possible values: 'M'");
}
#endif
#ifdef __cplusplus
} /* extern "C" */
#endif
