   1                 		.file	"octet_queue.c"
   2                 		.variant xap2+
   3                 	
   4                 		.small
   5                 	
   6                 		.section	.debug_abbrev,"",@progbits
   7                 	.Ldebug_abbrev0:
   8                 		.section	.debug_info,"",@progbits
   9                 	.Ldebug_info0:
  10                 		.section	.debug_line,"",@progbits
  11                 	.Ldebug_line0:
  12 0000 00 00 00 00 		.text
  12      00 02 00 00 
  12      00 00 01 01 
  12      FB 0E 0D 00 
  12      01 01 01 01 
  13                 	.Ltext0:
  14                 		.section	.text.queueData,"ax",@progbits
  15                 		.type	queueData, @function
  16                 	queueData:
  17                 	.LFB2:
  18                 		.file 1 "octet_queue.c"
   0:octet_queue.c **** /******************************************************************************
   1:octet_queue.c ****  *  Copyright Cambridge Silicon Radio Limited 2013-2015
   2:octet_queue.c ****  *  Part of CSR uEnergy SDK 2.4.4
   3:octet_queue.c ****  *  Application version 2.4.4.0
   4:octet_queue.c ****  *
   5:octet_queue.c ****  *  FILE
   6:octet_queue.c ****  *      octet_queue.c
   7:octet_queue.c ****  *
   8:octet_queue.c ****  *  DESCRIPTION
   9:octet_queue.c ****  *      Circular buffer implementation using packed and unpacked arrays
  10:octet_queue.c ****  *
  11:octet_queue.c ****  ******************************************************************************/
  12:octet_queue.c **** 
  13:octet_queue.c **** /*============================================================================*
  14:octet_queue.c ****  *  SDK Header Files
  15:octet_queue.c ****  *============================================================================*/
  16:octet_queue.c **** 
  17:octet_queue.c **** #include <mem.h>            /* Memory library */
  18:octet_queue.c **** 
  19:octet_queue.c **** /*============================================================================*
  20:octet_queue.c ****  *  Local Header Files
  21:octet_queue.c ****  *============================================================================*/
  22:octet_queue.c **** 
  23:octet_queue.c **** #include "octet_queue.h"    /* Interface to this source file */
  24:octet_queue.c **** 
  25:octet_queue.c **** /*============================================================================*
  26:octet_queue.c ****  *  Private Definitions
  27:octet_queue.c ****  *============================================================================*/
  28:octet_queue.c **** 
  29:octet_queue.c **** /*----------------------------------------------------------------------------*
  30:octet_queue.c ****  *  NAME
  31:octet_queue.c ****  *      FILL_BUFFER
  32:octet_queue.c ****  *
  33:octet_queue.c ****  *  DESCRIPTION
  34:octet_queue.c ****  *      Fill a buffer with a fill octet.
  35:octet_queue.c ****  *
  36:octet_queue.c ****  *  PARAMETERS
  37:octet_queue.c ****  *      buffer [in]             Buffer to fill
  38:octet_queue.c ****  *      octet [in]              Octet to fill buffer with. The octet in the LSB
  39:octet_queue.c ****  *                              of the 16-bit word will be used
  40:octet_queue.c ****  *      size [in]               Number of elements to fill. For a packed buffer
  41:octet_queue.c ****  *                              this is the number of uint16's, for an unpacked
  42:octet_queue.c ****  *                              unpacked buffer this is the number of uint8's
  43:octet_queue.c ****  *
  44:octet_queue.c ****  *  RETURNS
  45:octet_queue.c ****  *      Original pointer to the destination buffer
  46:octet_queue.c ****  *----------------------------------------------------------------------------*/
  47:octet_queue.c **** #define FILL_BUFFER(buffer, octet, size) \
  48:octet_queue.c ****     MemSet(buffer, ((uint16)(octet) << 8) | ((octet) & 0x00ff), size)
  49:octet_queue.c **** 
  50:octet_queue.c **** /*============================================================================*
  51:octet_queue.c ****  *  Private Function Prototypes
  52:octet_queue.c ****  *============================================================================*/
  53:octet_queue.c **** 
  54:octet_queue.c **** /* Store data in the queue */
  55:octet_queue.c **** static uint16 queueData(OQ_HANDLE   handle,
  56:octet_queue.c ****                         const void *p_data,
  57:octet_queue.c ****                         uint16      data_size_in_octets,
  58:octet_queue.c ****                         bool        src_starts_at_odd_octet,
  59:octet_queue.c ****                         OQDataMode  src_data_mode);
  60:octet_queue.c **** 
  61:octet_queue.c **** /* Extract data from the queue */
  62:octet_queue.c **** static uint16 popData(OQ_HANDLE  handle,
  63:octet_queue.c ****                       void      *p_data,
  64:octet_queue.c ****                       uint16     data_size_in_octets);
  65:octet_queue.c **** 
  66:octet_queue.c **** /*============================================================================*
  67:octet_queue.c ****  *  Private Function Implementations
  68:octet_queue.c ****  *============================================================================*/
  69:octet_queue.c **** 
  70:octet_queue.c **** /*----------------------------------------------------------------------------*
  71:octet_queue.c ****  *  NAME
  72:octet_queue.c ****  *      queueData
  73:octet_queue.c ****  *
  74:octet_queue.c ****  *  DESCRIPTION
  75:octet_queue.c ****  *      Queue data into octet queue.
  76:octet_queue.c ****  *
  77:octet_queue.c ****  *  PARAMETERS
  78:octet_queue.c ****  *      handle [in]             Handle to the octet queue into which data is to
  79:octet_queue.c ****  *                              be queued
  80:octet_queue.c ****  *      p_data [in]             Pointer to the source buffer holding data to be
  81:octet_queue.c ****  *                              queued. Size of each element of the buffer
  82:octet_queue.c ****  *                              depends on the source buffer data mode.
  83:octet_queue.c ****  *      data_size_in_octets [in]
  84:octet_queue.c ****  *                              The number of octets to be queued.
  85:octet_queue.c ****  *      src_starts_at_odd_octet [in] 
  86:octet_queue.c ****  *                              Start from odd octet when copying from the
  87:octet_queue.c ****  *                              source buffer. This parameter is only applicable
  88:octet_queue.c ****  *                              in packed mode.
  89:octet_queue.c ****  *      src_data_mode [in]      Data mode that the source buffer uses.
  90:octet_queue.c ****  *
  91:octet_queue.c ****  *  RETURNS
  92:octet_queue.c ****  *      Number of octets of data actually buffered
  93:octet_queue.c ****  *----------------------------------------------------------------------------*/
  94:octet_queue.c **** static uint16 queueData(OQ_HANDLE   handle,
  95:octet_queue.c ****                         const void *p_data,
  96:octet_queue.c ****                         uint16      data_size_in_octets,
  97:octet_queue.c ****                         bool        src_starts_at_odd_octet,
  98:octet_queue.c ****                         OQDataMode  src_data_mode)
  99:octet_queue.c **** {
  19                 	er	#0x001c
  20 0000 1C 0B       	.LCFI0:
  21                 		st	AL,@(0x0013,Y)
  22 0001 13 27       		st	AH,@(0x0014,Y)
  23 0002 14 23       		.loc 1 103 0
 100:octet_queue.c ****     /* Available space in the queue, in octets */
 101:octet_queue.c ****     /* (This will be 0 if handle is invalid) */
 102:octet_queue.c ****     const uint16 space = OQSpace(handle);
  24                 	L,@(0x0013,Y)
  25 0003 13 17       		bsr	OQSpace
  26 0004 00 00 00 00 		st	AL,@(0x0012,Y)
  26      00 9C 
  27 0007 12 27       		.loc 1 106 0
 103:octet_queue.c ****     
 104:octet_queue.c ****     /* Number of octets of data that can be queued */
 105:octet_queue.c ****     const uint16 octets_queued = MIN(space, data_size_in_octets);
  28                 	AL,@(0x0012,Y)
  29 0008 12 17       		st	AL,@(0x0018,Y)
  30 0009 18 27       		ld	X,@(0x001c,Y)
  31 000a 1C 1B       		st	X,@(0x0017,Y)
  32 000b 17 2B       		ld	AL,@(0x0017,Y)
  33 000c 17 17       		cmp	AL,@(0x0018,Y)
  34 000d 18 87       		bcz	.L2
  35 000e 00 00 00 00 		ld	X,@(0x0018,Y)
  35      00 2C 
  36 0011 18 1B       		st	X,@(0x0017,Y)
  37 0012 17 2B       	.L2:
  38                 		ld	AL,@(0x0017,Y)
  39 0013 17 17       		st	AL,@(0x0011,Y)
  40 0014 11 27       		.loc 1 109 0
 106:octet_queue.c ****     
 107:octet_queue.c ****     /* Number of octets of data remaining to be queued */
 108:octet_queue.c ****     uint16 data_to_be_queued = octets_queued;
  41                 	11,Y)
  42 0015 11 17       		st	AL,@(0x0010,Y)
  43 0016 10 27       		.loc 1 112 0
 109:octet_queue.c ****     
 110:octet_queue.c ****     /* If there is no space to queue more data return now */
 111:octet_queue.c ****     if (data_to_be_queued == 0)
  44                 	t	@(0x0010,Y)
  45 0017 10 9B       		bne	.L3
  46 0018 00 00 00 00 		.loc 1 113 0
  46      00 F0 
 112:octet_queue.c ****         return 0;
  47                 		X,#0x0000
  48 001b 00 18       		st	X,@(0x0016,Y)
  49 001c 16 2B       		bra	.L4
  50 001d 00 00 00 00 	.L3:
  50      00 E0 
  51                 		.loc 1 115 0
 113:octet_queue.c ****     
 114:octet_queue.c ****     if ((handle->mode == OQDataMode_packed) &&
  52                 	,@(0x0013,Y)
  53 0020 13 1B       		ld	AL,@(0x0005,X)
  54 0021 05 16       		cmp	AL,#0x0001
  55 0022 01 84       		bne	.L5
  56 0023 00 00 00 00 		ld	AL,@(0x001e,Y)
  56      00 F0 
  57 0026 1E 17       		cmp	AL,#0x0001
  58 0027 01 84       		bne	.L5
  59 0028 00 00 00 00 	.LBB2:
  59      00 F0 
  60                 		.loc 1 119 0
 115:octet_queue.c ****         (src_data_mode == OQDataMode_packed))
 116:octet_queue.c ****     {
 117:octet_queue.c ****         /* Pointer into source buffer */
 118:octet_queue.c ****         const uint16 *in = (const uint16 *)p_data;
  61                 	0x0014,Y)
  62 002b 14 17       		st	AL,@(0x000f,Y)
  63 002c 0F 27       		.loc 1 121 0
 119:octet_queue.c ****         /* Pointer into destination buffer */
 120:octet_queue.c ****         uint16 *out = (uint16 *)handle->p_buffer + handle->boundary/2;
  64                 		X,@(0x0013,Y)
  65 002d 13 1B       		ld	AL,@(0,X)
  66 002e 00 16       		st	AL,@0xfff8
  67 002f F8 25       		ld	X,@(0x0013,Y)
  68 0030 13 1B       		ld	AL,@(0x0003,X)
  69 0031 03 16       		ld	AH,@$XAP_AL
  70 0032 00 00 00 11 		lsr	#0x0001
  71 0034 00 09 01 A4 		ld	AL,@$XAP_AH
  72 0036 00 00 00 15 		ld	X,@0xfff8
  73 0038 F8 19       		add	X,@$XAP_AL
  74 0039 00 00 00 39 		st	X,@(0x000e,Y)
  75 003b 0E 2B       		.loc 1 123 0
 121:octet_queue.c ****         /* Flag to indicate whether source octet is from MSB or LSB */
 122:octet_queue.c ****         bool in_msb = src_starts_at_odd_octet;
  76                 	01d,Y)
  77 003c 1D 17       		st	AL,@(0x000d,Y)
  78 003d 0D 27       		.loc 1 125 0
 123:octet_queue.c ****         /* Flag to indicate whether destination octet is from MSB or LSB */
 124:octet_queue.c ****         bool out_msb = handle->boundary & 0x1;
  79                 		X,@(0x0013,Y)
  80 003e 13 1B       		ld	AL,@(0x0003,X)
  81 003f 03 16       		ld	X,@$XAP_AL
  82 0040 00 00 00 19 		and	X,#0x0001
  83 0042 01 C8       		st	X,@(0x000c,Y)
  84 0043 0C 2B       		.loc 1 128 0
 125:octet_queue.c ****     
 126:octet_queue.c ****         /* If the source and destination buffers are not similarly aligned */
 127:octet_queue.c ****         if (in_msb != out_msb)
  85                 	,@(0x000d,Y)
  86 0044 0D 17       		cmp	AL,@(0x000c,Y)
  87 0045 0C 87       		beq	.L6
  88 0046 00 00 00 00 	.L14:
  88      00 F4 
  89                 	.LBB3:
  90                 		.loc 1 136 0
 128:octet_queue.c ****         {
 129:octet_queue.c ****             /* Copy each octet from source to destination one by one */
 130:octet_queue.c ****             do
 131:octet_queue.c ****             {
 132:octet_queue.c ****                 uint16 src_octet;       /* Octet to copy */
 133:octet_queue.c ****             
 134:octet_queue.c ****                 /* Read octet from source */
 135:octet_queue.c ****                 if (in_msb)
  91                 	(0x000d,Y)
  92 0049 0D 9B       		beq	.L7
  93 004a 00 00 00 00 		.loc 1 138 0
  93      00 F4 
 136:octet_queue.c ****                 {
 137:octet_queue.c ****                     src_octet = (*in & 0xff00) >> 8;
  94                 		X,@(0x000f,Y)
  95 004d 0F 1B       		ld	AL,@(0,X)
  96 004e 00 16       		ld	AH,@$XAP_AL
  97 004f 00 00 00 11 		lsr	#0x0008
  98 0051 00 09 08 A4 		st	AH,@(0x000b,Y)
  99 0053 0B 23       		.loc 1 139 0
 138:octet_queue.c ****                     in++;   /* Move the input pointer to the next word */
 100                 	,@(0x000f,Y)
 101 0054 0F 17       		ld	X,@$XAP_AL
 102 0055 00 00 00 19 		add	X,#0x0001
 103 0057 01 38       		st	X,@(0x000f,Y)
 104 0058 0F 2B       		bra	.L8
 105 0059 00 00 00 00 	.L7:
 105      00 E0 
 106                 		.loc 1 143 0
 139:octet_queue.c ****                 }
 140:octet_queue.c ****                 else
 141:octet_queue.c ****                 {
 142:octet_queue.c ****                     src_octet = *in & 0x00ff;
 107                 	(0x000f,Y)
 108 005c 0F 1B       		ld	AL,@(0,X)
 109 005d 00 16       		ld	X,@$XAP_AL
 110 005e 00 00 00 19 		and	X,#0x00ff
 111 0060 01 00 FF C8 		st	X,@(0x000b,Y)
 112 0062 0B 2B       	.L8:
 113                 		.loc 1 147 0
 143:octet_queue.c ****                 }
 144:octet_queue.c ****             
 145:octet_queue.c ****                 /* Write octet to destination */
 146:octet_queue.c ****                 if (out_msb)
 114                 	0x000c,Y)
 115 0063 0C 9B       		beq	.L9
 116 0064 00 00 00 00 		.loc 1 149 0
 116      00 F4 
 147:octet_queue.c ****                 {
 148:octet_queue.c ****                     *out = (*out & 0x00ff) | (src_octet << 8);
 117                 		X,@(0x000e,Y)
 118 0067 0E 1B       		ld	AL,@(0,X)
 119 0068 00 16       		ld	X,@$XAP_AL
 120 0069 00 00 00 19 		and	X,#0x00ff
 121 006b 01 00 FF C8 		ld	AL,@(0x000b,Y)
 122 006d 0B 17       		asl	#0x0008
 123 006e 08 A0       		or	AL,@$XAP_UXL
 124 006f 00 00 00 B5 		ld	X,@(0x000e,Y)
 125 0071 0E 1B       		st	AL,@(0,X)
 126 0072 00 26       		.loc 1 150 0
 149:octet_queue.c ****                     out++;  /* Move the output pointer to the next word */
 127                 	x000e,Y)
 128 0073 0E 17       		ld	X,@$XAP_AL
 129 0074 00 00 00 19 		add	X,#0x0001
 130 0076 01 38       		st	X,@(0x000e,Y)
 131 0077 0E 2B       		bra	.L10
 132 0078 00 00 00 00 	.L9:
 132      00 E0 
 133                 		.loc 1 154 0
 150:octet_queue.c ****                 }
 151:octet_queue.c ****                 else
 152:octet_queue.c ****                 {
 153:octet_queue.c ****                     *out = (*out & 0xff00) | src_octet;
 134                 	(0x000e,Y)
 135 007b 0E 1B       		ld	AL,@(0,X)
 136 007c 00 16       		and	AL,#0xff00
 137 007d FF 00 00 C4 		or	AL,@(0x000b,Y)
 138 007f 0B B7       		ld	X,@(0x000e,Y)
 139 0080 0E 1B       		st	AL,@(0,X)
 140 0081 00 26       	.L10:
 141                 		.loc 1 158 0
 154:octet_queue.c ****                 }
 155:octet_queue.c **** 
 156:octet_queue.c ****                 /* Toggle MSB flags */
 157:octet_queue.c ****                 in_msb = !in_msb;
 142                 	0x0000
 143 0082 00 14       		st	AL,@(0x0019,Y)
 144 0083 19 27       		tst	@(0x000d,Y)
 145 0084 0D 9B       		bne	.L11
 146 0085 00 00 00 00 		ld	X,#0x0001
 146      00 F0 
 147 0088 01 18       		st	X,@(0x0019,Y)
 148 0089 19 2B       	.L11:
 149                 		ld	AL,@(0x0019,Y)
 150 008a 19 17       		st	AL,@(0x000d,Y)
 151 008b 0D 27       		.loc 1 159 0
 158:octet_queue.c ****                 out_msb = !out_msb;
 152                 	000
 153 008c 00 18       		st	X,@(0x001a,Y)
 154 008d 1A 2B       		tst	@(0x000c,Y)
 155 008e 0C 9B       		bne	.L12
 156 008f 00 00 00 00 		ld	AL,#0x0001
 156      00 F0 
 157 0092 01 14       		st	AL,@(0x001a,Y)
 158 0093 1A 27       	.L12:
 159                 		ld	X,@(0x001a,Y)
 160 0094 1A 1B       		st	X,@(0x000c,Y)
 161 0095 0C 2B       		.loc 1 168 0
 159:octet_queue.c ****                     
 160:octet_queue.c ****                 /* The above could be optimised given that if in_msb is true,
 161:octet_queue.c ****                  * then out_msb must be false, and vice versa. In fact we do
 162:octet_queue.c ****                  * not need out_msb at all.
 163:octet_queue.c ****                  * It has been left un-optimised to improve readability.
 164:octet_queue.c ****                  */
 165:octet_queue.c ****                     
 166:octet_queue.c ****                 /* Decrement number of octets to be queued */
 167:octet_queue.c ****                 data_to_be_queued--;
 162                 	x0010,Y)
 163 0096 10 17       		ld	X,@$XAP_AL
 164 0097 00 00 00 19 		add	X,#0xffff
 165 0099 FF 38       		st	X,@(0x0010,Y)
 166 009a 10 2B       		.loc 1 173 0
 168:octet_queue.c **** 
 169:octet_queue.c ****                 /* Advance queue boundary and wrap round if end of buffer
 170:octet_queue.c ****                  * reached.
 171:octet_queue.c ****                  */
 172:octet_queue.c ****                 if (++handle->boundary == OQCapacity(handle))
 167                 	,@(0x0013,Y)
 168 009b 13 1B       		ld	AL,@(0x0003,X)
 169 009c 03 16       		add	AL,#0x0001
 170 009d 01 34       		ld	X,@(0x0013,Y)
 171 009e 13 1B       		st	AL,@(0x0003,X)
 172 009f 03 26       		ld	X,@(0x0013,Y)
 173 00a0 13 1B       		ld	X,@(0x0003,X)
 174 00a1 03 1A       		st	X,@(0x0015,Y)
 175 00a2 15 2B       		ld	AL,@(0x0013,Y)
 176 00a3 13 17       		bsr	OQCapacity
 177 00a4 00 00 00 00 		ld	X,@(0x0015,Y)
 177      00 9C 
 178 00a7 15 1B       		cmp	X,@$XAP_AL
 179 00a8 00 00 00 89 		bne	.L13
 180 00aa 00 00 00 00 		.loc 1 175 0
 180      00 F0 
 173:octet_queue.c ****                 {
 174:octet_queue.c ****                     out = (uint16 *)handle->p_buffer;
 181                 	,Y)
 182 00ad 13 1B       		ld	AL,@(0,X)
 183 00ae 00 16       		st	AL,@(0x000e,Y)
 184 00af 0E 27       		.loc 1 176 0
 175:octet_queue.c ****                     handle->boundary = 0;
 185                 	X,@(0x0013,Y)
 186 00b0 13 1B       		ld	AL,#0x0000
 187 00b1 00 14       		st	AL,@(0x0003,X)
 188 00b2 03 26       	.L13:
 189                 	.LBE3:
 190                 		.loc 1 178 0
 176:octet_queue.c ****                 }
 177:octet_queue.c ****             } while (data_to_be_queued > 0);
 191                 	(0x0010,Y)
 192 00b3 10 9B       		bne	.L14
 193 00b4 00 00 00 00 		bra	.L19
 193      00 F0 
 194 00b7 00 00 00 00 	.L6:
 194      00 E0 
 195                 	.LBB4:
 196                 		.loc 1 188 0
 178:octet_queue.c ****         }
 179:octet_queue.c ****         else /* in_msb == out_msb */
 180:octet_queue.c ****         {
 181:octet_queue.c ****             /* How many octets will fit in the remaining buffer */
 182:octet_queue.c ****             uint16 remaining;
 183:octet_queue.c **** 
 184:octet_queue.c ****             /* If the buffers are aligned on the MSB copy the first octet
 185:octet_queue.c ****              * separately (because MemCopy only works on whole words).
 186:octet_queue.c ****              */
 187:octet_queue.c ****             if (in_msb)
 197                 	(0x000d,Y)
 198 00ba 0D 9B       		beq	.L16
 199 00bb 00 00 00 00 		.loc 1 191 0
 199      00 F4 
 188:octet_queue.c ****             {
 189:octet_queue.c ****                 /* Copy the octet from the source to the destination */
 190:octet_queue.c ****                 *out = (*out & 0x00ff) | (*in & 0xff00);
 200                 		X,@(0x000e,Y)
 201 00be 0E 1B       		ld	AL,@(0,X)
 202 00bf 00 16       		ld	AH,@$XAP_AL
 203 00c0 00 00 00 11 		and	AH,#0x00ff
 204 00c2 01 00 FF C0 		ld	X,@(0x000f,Y)
 205 00c4 0F 1B       		ld	AL,@(0,X)
 206 00c5 00 16       		and	AL,#0xff00
 207 00c6 FF 00 00 C4 		or	AL,@$XAP_AH
 208 00c8 00 00 00 B5 		ld	X,@(0x000e,Y)
 209 00ca 0E 1B       		st	AL,@(0,X)
 210 00cb 00 26       		.loc 1 194 0
 191:octet_queue.c ****             
 192:octet_queue.c ****                 /* Decrement number of octets to be queued */
 193:octet_queue.c ****                 data_to_be_queued--;
 211                 	0010,Y)
 212 00cc 10 17       		ld	X,@$XAP_AL
 213 00cd 00 00 00 19 		add	X,#0xffff
 214 00cf FF 38       		st	X,@(0x0010,Y)
 215 00d0 10 2B       		.loc 1 197 0
 194:octet_queue.c ****             
 195:octet_queue.c ****                 /* Advance buffer pointers */
 196:octet_queue.c ****                 in++;
 216                 	L,@(0x000f,Y)
 217 00d1 0F 17       		ld	X,@$XAP_AL
 218 00d2 00 00 00 19 		add	X,#0x0001
 219 00d4 01 38       		st	X,@(0x000f,Y)
 220 00d5 0F 2B       		.loc 1 198 0
 197:octet_queue.c ****                 out++;
 221                 	L,@(0x000e,Y)
 222 00d6 0E 17       		ld	X,@$XAP_AL
 223 00d7 00 00 00 19 		add	X,#0x0001
 224 00d9 01 38       		st	X,@(0x000e,Y)
 225 00da 0E 2B       		.loc 1 201 0
 198:octet_queue.c ****             
 199:octet_queue.c ****                 /* Advance queue boundary */
 200:octet_queue.c ****                 handle->boundary++;
 226                 	,@(0x0013,Y)
 227 00db 13 1B       		ld	AL,@(0x0003,X)
 228 00dc 03 16       		add	AL,#0x0001
 229 00dd 01 34       		ld	X,@(0x0013,Y)
 230 00de 13 1B       		st	AL,@(0x0003,X)
 231 00df 03 26       	.L16:
 232                 		.loc 1 205 0
 201:octet_queue.c ****             }
 202:octet_queue.c ****                 
 203:octet_queue.c ****             /* Check whether the buffer will wrap round */
 204:octet_queue.c ****             remaining = OQCapacity(handle) - handle->boundary;
 233                 	@(0x0013,Y)
 234 00e0 13 17       		bsr	OQCapacity
 235 00e1 00 00 00 00 		ld	AH,@$XAP_AL
 235      00 9C 
 236 00e4 00 00 00 11 		ld	X,@(0x0013,Y)
 237 00e6 13 1B       		ld	AL,@(0x0003,X)
 238 00e7 03 16       		ld	X,@$XAP_AH
 239 00e8 00 00 00 19 		sub	X,@$XAP_AL
 240 00ea 00 00 00 59 		st	X,@(0x000a,Y)
 241 00ec 0A 2B       		.loc 1 206 0
 205:octet_queue.c ****             if (data_to_be_queued >= remaining)
 242                 	0x0010,Y)
 243 00ed 10 17       		cmp	AL,@(0x000a,Y)
 244 00ee 0A 87       		bcs	.L17
 245 00ef 00 00 00 00 		.loc 1 209 0
 245      00 FC 
 206:octet_queue.c ****             {
 207:octet_queue.c ****                 /* Copy the data from source to destination */
 208:octet_queue.c ****                 MemCopy(out, in, remaining/2);
 246                 	AL,@(0x000a,Y)
 247 00f2 0A 17       		ld	AH,@$XAP_AL
 248 00f3 00 00 00 11 		lsr	#0x0001
 249 00f5 00 09 01 A4 		ld	AL,@$XAP_AH
 250 00f7 00 00 00 15 		st	AL,@(0,Y)
 251 00f9 00 27       		ld	AL,@(0x000e,Y)
 252 00fa 0E 17       		ld	AH,@(0x000f,Y)
 253 00fb 0F 13       		bsr	memcpy
 254 00fc 00 00 00 00 		.loc 1 212 0
 254      00 9C 
 209:octet_queue.c ****                     
 210:octet_queue.c ****                 /* Decrement the number of octets remaining to be copied */
 211:octet_queue.c ****                 data_to_be_queued -= remaining;
 255                 	0x0010,Y)
 256 00ff 10 17       		sub	AL,@(0x000a,Y)
 257 0100 0A 57       		st	AL,@(0x0010,Y)
 258 0101 10 27       		.loc 1 215 0
 212:octet_queue.c ****                     
 213:octet_queue.c ****                 /* Advance the input pointer */
 214:octet_queue.c ****                 in += remaining/2;
 259                 	AL,@(0x000a,Y)
 260 0102 0A 17       		ld	AH,@$XAP_AL
 261 0103 00 00 00 11 		lsr	#0x0001
 262 0105 00 09 01 A4 		ld	AL,@(0x000f,Y)
 263 0107 0F 17       		ld	X,@$XAP_AL
 264 0108 00 00 00 19 		add	X,@$XAP_AH
 265 010a 00 00 00 39 		st	X,@(0x000f,Y)
 266 010c 0F 2B       		.loc 1 218 0
 215:octet_queue.c ****             
 216:octet_queue.c ****                 /* Reset the output pointer */
 217:octet_queue.c ****                 out = (uint16 *)handle->p_buffer;
 267                 	0x0013,Y)
 268 010d 13 1B       		ld	AL,@(0,X)
 269 010e 00 16       		st	AL,@(0x000e,Y)
 270 010f 0E 27       		.loc 1 221 0
 218:octet_queue.c ****             
 219:octet_queue.c ****                 /* Reset the queue boundary */
 220:octet_queue.c ****                 handle->boundary = 0;
 271                 	X,@(0x0013,Y)
 272 0110 13 1B       		ld	AL,#0x0000
 273 0111 00 14       		st	AL,@(0x0003,X)
 274 0112 03 26       	.L17:
 275                 		.loc 1 225 0
 221:octet_queue.c ****             }
 222:octet_queue.c ****         
 223:octet_queue.c ****             /* Copy from source to destination */
 224:octet_queue.c ****             MemCopy(out, in, data_to_be_queued/2);
 276                 	L,@(0x0010,Y)
 277 0113 10 17       		ld	AH,@$XAP_AL
 278 0114 00 00 00 11 		lsr	#0x0001
 279 0116 00 09 01 A4 		ld	AL,@$XAP_AH
 280 0118 00 00 00 15 		st	AL,@(0,Y)
 281 011a 00 27       		ld	AL,@(0x000e,Y)
 282 011b 0E 17       		ld	AH,@(0x000f,Y)
 283 011c 0F 13       		bsr	memcpy
 284 011d 00 00 00 00 		.loc 1 228 0
 284      00 9C 
 225:octet_queue.c ****         
 226:octet_queue.c ****             /* If there is an odd octet left over */
 227:octet_queue.c ****             if (data_to_be_queued & 0x1)
 285                 	0x0010,Y)
 286 0120 10 17       		and	AL,#0x0001
 287 0121 01 C4       		tst	@$XAP_AL
 288 0122 00 00 00 99 		beq	.L18
 289 0124 00 00 00 00 		.loc 1 231 0
 289      00 F4 
 228:octet_queue.c ****             {
 229:octet_queue.c ****                 /* Advance buffer pointers */
 230:octet_queue.c ****                 in += data_to_be_queued/2;
 290                 	L,@(0x0010,Y)
 291 0127 10 17       		ld	AH,@$XAP_AL
 292 0128 00 00 00 11 		lsr	#0x0001
 293 012a 00 09 01 A4 		ld	AL,@(0x000f,Y)
 294 012c 0F 17       		ld	X,@$XAP_AL
 295 012d 00 00 00 19 		add	X,@$XAP_AH
 296 012f 00 00 00 39 		st	X,@(0x000f,Y)
 297 0131 0F 2B       		.loc 1 232 0
 231:octet_queue.c ****                 out += data_to_be_queued/2;
 298                 	(0x0010,Y)
 299 0132 10 17       		ld	AH,@$XAP_AL
 300 0133 00 00 00 11 		lsr	#0x0001
 301 0135 00 09 01 A4 		ld	AL,@(0x000e,Y)
 302 0137 0E 17       		ld	X,@$XAP_AL
 303 0138 00 00 00 19 		add	X,@$XAP_AH
 304 013a 00 00 00 39 		st	X,@(0x000e,Y)
 305 013c 0E 2B       		.loc 1 235 0
 232:octet_queue.c ****             
 233:octet_queue.c ****                 /* Copy the octet into the LSB leaving the MSB unaltered */
 234:octet_queue.c ****                 *out = (*out & 0xff00) | (*in & 0x00ff);
 306                 	0x000e,Y)
 307 013d 0E 1B       		ld	AL,@(0,X)
 308 013e 00 16       		ld	AH,@$XAP_AL
 309 013f 00 00 00 11 		and	AH,#0xff00
 310 0141 FF 00 00 C0 		ld	X,@(0x000f,Y)
 311 0143 0F 1B       		ld	AL,@(0,X)
 312 0144 00 16       		and	AL,#0x00ff
 313 0145 01 00 FF C4 		or	AL,@$XAP_AH
 314 0147 00 00 00 B5 		ld	X,@(0x000e,Y)
 315 0149 0E 1B       		st	AL,@(0,X)
 316 014a 00 26       	.L18:
 317                 		.loc 1 239 0
 235:octet_queue.c ****             }
 236:octet_queue.c ****                 
 237:octet_queue.c ****             /* Advance queue boundary */
 238:octet_queue.c ****             handle->boundary += data_to_be_queued;
 318                 	13,Y)
 319 014b 13 1B       		ld	AL,@(0x0003,X)
 320 014c 03 16       		add	AL,@(0x0010,Y)
 321 014d 10 37       		ld	X,@(0x0013,Y)
 322 014e 13 1B       		st	AL,@(0x0003,X)
 323 014f 03 26       		bra	.L19
 324 0150 00 00 00 00 	.L5:
 324      00 E0 
 325                 	.LBE4:
 326                 	.LBE2:
 327                 		.loc 1 242 0
 239:octet_queue.c ****         }
 240:octet_queue.c ****     }
 241:octet_queue.c ****     else if ((handle->mode == OQDataMode_unpacked) &&
 328                 	0013,Y)
 329 0153 13 1B       		ld	AL,@(0x0005,X)
 330 0154 05 16       		tst	@$XAP_AL
 331 0155 00 00 00 99 		bne	.L20
 332 0157 00 00 00 00 		tst	@(0x001e,Y)
 332      00 F0 
 333 015a 1E 9B       		bne	.L20
 334 015b 00 00 00 00 	.LBB5:
 334      00 F0 
 335                 		.loc 1 246 0
 242:octet_queue.c ****              (src_data_mode == OQDataMode_unpacked))
 243:octet_queue.c ****     {
 244:octet_queue.c ****         /* Pointer into source buffer */
 245:octet_queue.c ****         const uint8 *in = (const uint8 *)p_data;
 336                 	(0x0014,Y)
 337 015e 14 17       		st	AL,@(0x0009,Y)
 338 015f 09 27       		.loc 1 248 0
 246:octet_queue.c ****         /* Pointer into destination buffer */
 247:octet_queue.c ****         uint8 *out = (uint8 *)handle->p_buffer + handle->boundary;
 339                 		X,@(0x0013,Y)
 340 0160 13 1B       		ld	AL,@(0,X)
 341 0161 00 16       		ld	AH,@$XAP_AL
 342 0162 00 00 00 11 		ld	X,@(0x0013,Y)
 343 0164 13 1B       		ld	AL,@(0x0003,X)
 344 0165 03 16       		ld	X,@$XAP_AH
 345 0166 00 00 00 19 		add	X,@$XAP_AL
 346 0168 00 00 00 39 		st	X,@(0x0008,Y)
 347 016a 08 2B       		.loc 1 250 0
 248:octet_queue.c ****         /* How many octets will fit in the remaining buffer */
 249:octet_queue.c ****         const uint16 remaining = OQCapacity(handle) - handle->boundary;
 348                 	0x0013,Y)
 349 016b 13 17       		bsr	OQCapacity
 350 016c 00 00 00 00 		ld	AH,@$XAP_AL
 350      00 9C 
 351 016f 00 00 00 11 		ld	X,@(0x0013,Y)
 352 0171 13 1B       		ld	AL,@(0x0003,X)
 353 0172 03 16       		ld	X,@$XAP_AH
 354 0173 00 00 00 19 		sub	X,@$XAP_AL
 355 0175 00 00 00 59 		st	X,@(0x0007,Y)
 356 0177 07 2B       		.loc 1 253 0
 250:octet_queue.c **** 
 251:octet_queue.c ****         /* Check whether the buffer will wrap round */
 252:octet_queue.c ****         if (data_to_be_queued >= remaining)
 357                 	0x0010,Y)
 358 0178 10 17       		cmp	AL,@(0x0007,Y)
 359 0179 07 87       		bcs	.L21
 360 017a 00 00 00 00 		.loc 1 256 0
 360      00 FC 
 253:octet_queue.c ****         {
 254:octet_queue.c ****             /* Copy the data from source to destination */
 255:octet_queue.c ****             MemCopy(out, in, remaining);
 361                 	AL,@(0x0007,Y)
 362 017d 07 17       		st	AL,@(0,Y)
 363 017e 00 27       		ld	AL,@(0x0008,Y)
 364 017f 08 17       		ld	AH,@(0x0009,Y)
 365 0180 09 13       		bsr	memcpy
 366 0181 00 00 00 00 		.loc 1 259 0
 366      00 9C 
 256:octet_queue.c **** 
 257:octet_queue.c ****             /* Decrement the number of octets remaining to be copied */
 258:octet_queue.c ****             data_to_be_queued -= remaining;
 367                 	,@(0x0010,Y)
 368 0184 10 17       		sub	AL,@(0x0007,Y)
 369 0185 07 57       		st	AL,@(0x0010,Y)
 370 0186 10 27       		.loc 1 262 0
 259:octet_queue.c ****         
 260:octet_queue.c ****             /* Advance the input pointer */
 261:octet_queue.c ****             in += remaining;
 371                 	AL,@(0x0009,Y)
 372 0187 09 17       		ld	X,@$XAP_AL
 373 0188 00 00 00 19 		add	X,@(0x0007,Y)
 374 018a 07 3B       		st	X,@(0x0009,Y)
 375 018b 09 2B       		.loc 1 265 0
 262:octet_queue.c **** 
 263:octet_queue.c ****             /* Reset the output pointer */
 264:octet_queue.c ****             out = (uint8 *)handle->p_buffer;
 376                 	,@(0x0013,Y)
 377 018c 13 1B       		ld	AL,@(0,X)
 378 018d 00 16       		st	AL,@(0x0008,Y)
 379 018e 08 27       		.loc 1 268 0
 265:octet_queue.c ****         
 266:octet_queue.c ****             /* Reset the queue boundary */
 267:octet_queue.c ****             handle->boundary = 0;
 380                 	X,@(0x0013,Y)
 381 018f 13 1B       		ld	AL,#0x0000
 382 0190 00 14       		st	AL,@(0x0003,X)
 383 0191 03 26       	.L21:
 384                 		.loc 1 272 0
 268:octet_queue.c ****         }
 269:octet_queue.c **** 
 270:octet_queue.c ****         /* Copy from source to destination */
 271:octet_queue.c ****         MemCopy(out, in, data_to_be_queued);
 385                 	L,@(0x0010,Y)
 386 0192 10 17       		st	AL,@(0,Y)
 387 0193 00 27       		ld	AL,@(0x0008,Y)
 388 0194 08 17       		ld	AH,@(0x0009,Y)
 389 0195 09 13       		bsr	memcpy
 390 0196 00 00 00 00 		.loc 1 275 0
 390      00 9C 
 272:octet_queue.c **** 
 273:octet_queue.c ****         /* Advance queue boundary */
 274:octet_queue.c ****         handle->boundary += data_to_be_queued;
 391                 	@(0x0013,Y)
 392 0199 13 1B       		ld	AL,@(0x0003,X)
 393 019a 03 16       		add	AL,@(0x0010,Y)
 394 019b 10 37       		ld	X,@(0x0013,Y)
 395 019c 13 1B       		st	AL,@(0x0003,X)
 396 019d 03 26       		bra	.L19
 397 019e 00 00 00 00 	.L20:
 397      00 E0 
 398                 	.LBE5:
 399                 		.loc 1 277 0
 275:octet_queue.c ****     }
 276:octet_queue.c ****     else if ((handle->mode == OQDataMode_packed) &&
 400                 	x0013,Y)
 401 01a1 13 1B       		ld	AL,@(0x0005,X)
 402 01a2 05 16       		cmp	AL,#0x0001
 403 01a3 01 84       		bne	.L22
 404 01a4 00 00 00 00 		tst	@(0x001e,Y)
 404      00 F0 
 405 01a7 1E 9B       		bne	.L22
 406 01a8 00 00 00 00 	.LBB6:
 406      00 F0 
 407                 		.loc 1 281 0
 277:octet_queue.c ****              (src_data_mode == OQDataMode_unpacked))
 278:octet_queue.c ****     {
 279:octet_queue.c ****         /* Pointer into source buffer */
 280:octet_queue.c ****         const uint8 *in = (const uint8 *)p_data;
 408                 	(0x0014,Y)
 409 01ab 14 17       		st	AL,@(0x0006,Y)
 410 01ac 06 27       		.loc 1 283 0
 281:octet_queue.c ****         /* Pointer into destination buffer */
 282:octet_queue.c ****         uint16 *out = (uint16 *)handle->p_buffer + handle->boundary/2;
 411                 		X,@(0x0013,Y)
 412 01ad 13 1B       		ld	AL,@(0,X)
 413 01ae 00 16       		st	AL,@0xfff8
 414 01af F8 25       		ld	X,@(0x0013,Y)
 415 01b0 13 1B       		ld	AL,@(0x0003,X)
 416 01b1 03 16       		ld	AH,@$XAP_AL
 417 01b2 00 00 00 11 		lsr	#0x0001
 418 01b4 00 09 01 A4 		ld	AL,@$XAP_AH
 419 01b6 00 00 00 15 		ld	X,@0xfff8
 420 01b8 F8 19       		add	X,@$XAP_AL
 421 01b9 00 00 00 39 		st	X,@(0x0005,Y)
 422 01bb 05 2B       		.loc 1 288 0
 283:octet_queue.c ****         /* How many octets will fit in the remaining buffer */
 284:octet_queue.c ****         uint16 remaining;
 285:octet_queue.c ****     
 286:octet_queue.c ****         /* If the first octet to write is in the MSB */
 287:octet_queue.c ****         if (handle->boundary & 0x1)
 423                 	13,Y)
 424 01bc 13 1B       		ld	AL,@(0x0003,X)
 425 01bd 03 16       		and	AL,#0x0001
 426 01be 01 C4       		tst	@$XAP_AL
 427 01bf 00 00 00 99 		beq	.L23
 428 01c1 00 00 00 00 		.loc 1 293 0
 428      00 F4 
 288:octet_queue.c ****         {
 289:octet_queue.c ****             /* Copy the first octet separately (MemCopyPack only copies into
 290:octet_queue.c ****              * whole words)
 291:octet_queue.c ****              */
 292:octet_queue.c ****             *out = (*out & 0x00ff) | ((*in & 0x00ff) << 8);
 429                 	@(0x0005,Y)
 430 01c4 05 1B       		ld	AL,@(0,X)
 431 01c5 00 16       		ld	X,@$XAP_AL
 432 01c6 00 00 00 19 		and	X,#0x00ff
 433 01c8 01 00 FF C8 		st	X,@0xfff8
 434 01ca F8 29       		ld	X,@(0x0006,Y)
 435 01cb 06 1B       		ld	AL,@(0,X)
 436 01cc 00 16       		asl	#0x0008
 437 01cd 08 A0       		or	AL,@0xfff8
 438 01ce F8 B5       		ld	X,@(0x0005,Y)
 439 01cf 05 1B       		st	AL,@(0,X)
 440 01d0 00 26       		.loc 1 296 0
 293:octet_queue.c ****         
 294:octet_queue.c ****             /* Decrement number of octets remaining to be copied */
 295:octet_queue.c ****             data_to_be_queued--;
 441                 	010,Y)
 442 01d1 10 17       		ld	X,@$XAP_AL
 443 01d2 00 00 00 19 		add	X,#0xffff
 444 01d4 FF 38       		st	X,@(0x0010,Y)
 445 01d5 10 2B       		.loc 1 299 0
 296:octet_queue.c ****         
 297:octet_queue.c ****             /* Advance pointers */
 298:octet_queue.c ****             out++;
 446                 	L,@(0x0005,Y)
 447 01d6 05 17       		ld	X,@$XAP_AL
 448 01d7 00 00 00 19 		add	X,#0x0001
 449 01d9 01 38       		st	X,@(0x0005,Y)
 450 01da 05 2B       		.loc 1 300 0
 299:octet_queue.c ****             in++;
 451                 	L,@(0x0006,Y)
 452 01db 06 17       		ld	X,@$XAP_AL
 453 01dc 00 00 00 19 		add	X,#0x0001
 454 01de 01 38       		st	X,@(0x0006,Y)
 455 01df 06 2B       		.loc 1 303 0
 300:octet_queue.c ****         
 301:octet_queue.c ****             /* Advance queue boundary */
 302:octet_queue.c ****             handle->boundary++;
 456                 	,@(0x0013,Y)
 457 01e0 13 1B       		ld	AL,@(0x0003,X)
 458 01e1 03 16       		add	AL,#0x0001
 459 01e2 01 34       		ld	X,@(0x0013,Y)
 460 01e3 13 1B       		st	AL,@(0x0003,X)
 461 01e4 03 26       	.L23:
 462                 		.loc 1 307 0
 303:octet_queue.c ****         }
 304:octet_queue.c **** 
 305:octet_queue.c ****         /* Check whether the buffer will wrap round */
 306:octet_queue.c ****         remaining = OQCapacity(handle) - handle->boundary;
 463                 	@(0x0013,Y)
 464 01e5 13 17       		bsr	OQCapacity
 465 01e6 00 00 00 00 		ld	AH,@$XAP_AL
 465      00 9C 
 466 01e9 00 00 00 11 		ld	X,@(0x0013,Y)
 467 01eb 13 1B       		ld	AL,@(0x0003,X)
 468 01ec 03 16       		ld	X,@$XAP_AH
 469 01ed 00 00 00 19 		sub	X,@$XAP_AL
 470 01ef 00 00 00 59 		st	X,@(0x0004,Y)
 471 01f1 04 2B       		.loc 1 308 0
 307:octet_queue.c ****         if (data_to_be_queued >= remaining)
 472                 	0x0010,Y)
 473 01f2 10 17       		cmp	AL,@(0x0004,Y)
 474 01f3 04 87       		bcs	.L24
 475 01f4 00 00 00 00 		.loc 1 311 0
 475      00 FC 
 308:octet_queue.c ****         {
 309:octet_queue.c ****             /* Copy the data from source to destination */
 310:octet_queue.c ****             MemCopyPack(out, in, remaining);
 476                 	AL,@(0x0004,Y)
 477 01f7 04 17       		st	AL,@(0,Y)
 478 01f8 00 27       		ld	AL,@(0x0005,Y)
 479 01f9 05 17       		ld	AH,@(0x0006,Y)
 480 01fa 06 13       		bsr	MemCopyPack
 481 01fb 00 00 00 00 		.loc 1 314 0
 481      00 9C 
 311:octet_queue.c **** 
 312:octet_queue.c ****             /* Decrement the number of octets remaining to be copied */
 313:octet_queue.c ****             data_to_be_queued -= remaining;
 482                 	,@(0x0010,Y)
 483 01fe 10 17       		sub	AL,@(0x0004,Y)
 484 01ff 04 57       		st	AL,@(0x0010,Y)
 485 0200 10 27       		.loc 1 317 0
 314:octet_queue.c **** 
 315:octet_queue.c ****             /* Advance the input pointer */
 316:octet_queue.c ****             in += remaining;
 486                 	AL,@(0x0006,Y)
 487 0201 06 17       		ld	X,@$XAP_AL
 488 0202 00 00 00 19 		add	X,@(0x0004,Y)
 489 0204 04 3B       		st	X,@(0x0006,Y)
 490 0205 06 2B       		.loc 1 320 0
 317:octet_queue.c ****         
 318:octet_queue.c ****             /* Reset the output pointer */
 319:octet_queue.c ****             out = (uint16 *)handle->p_buffer;
 491                 	,@(0x0013,Y)
 492 0206 13 1B       		ld	AL,@(0,X)
 493 0207 00 16       		st	AL,@(0x0005,Y)
 494 0208 05 27       		.loc 1 323 0
 320:octet_queue.c ****         
 321:octet_queue.c ****             /* Reset the queue boundary */
 322:octet_queue.c ****             handle->boundary = 0;
 495                 	X,@(0x0013,Y)
 496 0209 13 1B       		ld	AL,#0x0000
 497 020a 00 14       		st	AL,@(0x0003,X)
 498 020b 03 26       	.L24:
 499                 		.loc 1 330 0
 323:octet_queue.c ****         }
 324:octet_queue.c **** 
 325:octet_queue.c ****         /* Copy whole words from source to destination. If there are an odd
 326:octet_queue.c ****          * number of octets to copy then the last octet is copied into the
 327:octet_queue.c ****          * LSB of the last destination word, and the MSB is not modified.
 328:octet_queue.c ****          */
 329:octet_queue.c ****         MemCopyPack(out, in, data_to_be_queued);
 500                 	L,@(0x0010,Y)
 501 020c 10 17       		st	AL,@(0,Y)
 502 020d 00 27       		ld	AL,@(0x0005,Y)
 503 020e 05 17       		ld	AH,@(0x0006,Y)
 504 020f 06 13       		bsr	MemCopyPack
 505 0210 00 00 00 00 		.loc 1 333 0
 505      00 9C 
 330:octet_queue.c **** 
 331:octet_queue.c ****         /* Advance queue boundary */
 332:octet_queue.c ****         handle->boundary += data_to_be_queued;
 506                 	@(0x0013,Y)
 507 0213 13 1B       		ld	AL,@(0x0003,X)
 508 0214 03 16       		add	AL,@(0x0010,Y)
 509 0215 10 37       		ld	X,@(0x0013,Y)
 510 0216 13 1B       		st	AL,@(0x0003,X)
 511 0217 03 26       		bra	.L19
 512 0218 00 00 00 00 	.L22:
 512      00 E0 
 513                 	.LBE6:
 514                 	.LBB7:
 515                 		.loc 1 339 0
 333:octet_queue.c ****     }
 334:octet_queue.c ****     else /* ((handle->mode == OQDataMode_unpacked) &&
 335:octet_queue.c ****              (src_data_mode == OQDataMode_packed)) */
 336:octet_queue.c ****     {
 337:octet_queue.c ****         /* Pointer into source buffer */
 338:octet_queue.c ****         const uint16 *in = (const uint16 *)p_data;
 516                 	x0014,Y)
 517 021b 14 17       		st	AL,@(0x0003,Y)
 518 021c 03 27       		.loc 1 341 0
 339:octet_queue.c ****         /* Pointer into destination buffer */
 340:octet_queue.c ****         uint8 *out = (uint8 *)handle->p_buffer + handle->boundary;
 519                 		X,@(0x0013,Y)
 520 021d 13 1B       		ld	AL,@(0,X)
 521 021e 00 16       		ld	AH,@$XAP_AL
 522 021f 00 00 00 11 		ld	X,@(0x0013,Y)
 523 0221 13 1B       		ld	AL,@(0x0003,X)
 524 0222 03 16       		ld	X,@$XAP_AH
 525 0223 00 00 00 19 		add	X,@$XAP_AL
 526 0225 00 00 00 39 		st	X,@(0x0002,Y)
 527 0227 02 2B       		.loc 1 346 0
 341:octet_queue.c ****         /* How many octets will fit in the remaining buffer */
 342:octet_queue.c ****         uint16 remaining;
 343:octet_queue.c **** 
 344:octet_queue.c ****         /* If the first octet to read is in the MSB */
 345:octet_queue.c ****         if (src_starts_at_odd_octet)
 528                 	001d,Y)
 529 0228 1D 9B       		beq	.L25
 530 0229 00 00 00 00 		.loc 1 351 0
 530      00 F4 
 346:octet_queue.c ****         {
 347:octet_queue.c ****             /* Copy the first octet separately (MemCopyUnPack only copies
 348:octet_queue.c ****              * from whole words)
 349:octet_queue.c ****              */
 350:octet_queue.c ****             *out = (*in & 0xff00) >> 8;
 531                 		X,@(0x0003,Y)
 532 022c 03 1B       		ld	AL,@(0,X)
 533 022d 00 16       		ld	AH,@$XAP_AL
 534 022e 00 00 00 11 		lsr	#0x0008
 535 0230 00 09 08 A4 		ld	AL,@$XAP_AH
 536 0232 00 00 00 15 		ld	X,@(0x0002,Y)
 537 0234 02 1B       		st	AL,@(0,X)
 538 0235 00 26       		.loc 1 354 0
 351:octet_queue.c ****         
 352:octet_queue.c ****             /* Decrement number of octets remaining to be copied */
 353:octet_queue.c ****             data_to_be_queued--;
 539                 	(0x0010,Y)
 540 0236 10 17       		ld	X,@$XAP_AL
 541 0237 00 00 00 19 		add	X,#0xffff
 542 0239 FF 38       		st	X,@(0x0010,Y)
 543 023a 10 2B       		.loc 1 357 0
 354:octet_queue.c ****         
 355:octet_queue.c ****             /* Advance buffer pointers */
 356:octet_queue.c ****             out++;
 544                 	L,@(0x0002,Y)
 545 023b 02 17       		ld	X,@$XAP_AL
 546 023c 00 00 00 19 		add	X,#0x0001
 547 023e 01 38       		st	X,@(0x0002,Y)
 548 023f 02 2B       		.loc 1 358 0
 357:octet_queue.c ****             in++;
 549                 	L,@(0x0003,Y)
 550 0240 03 17       		ld	X,@$XAP_AL
 551 0241 00 00 00 19 		add	X,#0x0001
 552 0243 01 38       		st	X,@(0x0003,Y)
 553 0244 03 2B       		.loc 1 361 0
 358:octet_queue.c ****         
 359:octet_queue.c ****             /* Advance queue boundary */
 360:octet_queue.c ****             handle->boundary++;
 554                 	,@(0x0013,Y)
 555 0245 13 1B       		ld	AL,@(0x0003,X)
 556 0246 03 16       		add	AL,#0x0001
 557 0247 01 34       		ld	X,@(0x0013,Y)
 558 0248 13 1B       		st	AL,@(0x0003,X)
 559 0249 03 26       	.L25:
 560                 		.loc 1 365 0
 361:octet_queue.c ****         }
 362:octet_queue.c **** 
 363:octet_queue.c ****         /* Check whether the buffer will wrap round */    
 364:octet_queue.c ****         remaining = OQCapacity(handle) - handle->boundary;
 561                 	@(0x0013,Y)
 562 024a 13 17       		bsr	OQCapacity
 563 024b 00 00 00 00 		ld	AH,@$XAP_AL
 563      00 9C 
 564 024e 00 00 00 11 		ld	X,@(0x0013,Y)
 565 0250 13 1B       		ld	AL,@(0x0003,X)
 566 0251 03 16       		ld	X,@$XAP_AH
 567 0252 00 00 00 19 		sub	X,@$XAP_AL
 568 0254 00 00 00 59 		st	X,@(0x0001,Y)
 569 0256 01 2B       		.loc 1 366 0
 365:octet_queue.c ****         if (data_to_be_queued >= remaining)
 570                 	0x0010,Y)
 571 0257 10 17       		cmp	AL,@(0x0001,Y)
 572 0258 01 87       		bcs	.L26
 573 0259 00 00 00 00 		.loc 1 369 0
 573      00 FC 
 366:octet_queue.c ****         {
 367:octet_queue.c ****             /* Copy the data from source to destination */
 368:octet_queue.c ****             MemCopyUnPack(out, in, remaining);
 574                 	AL,@(0x0001,Y)
 575 025c 01 17       		st	AL,@(0,Y)
 576 025d 00 27       		ld	AL,@(0x0002,Y)
 577 025e 02 17       		ld	AH,@(0x0003,Y)
 578 025f 03 13       		bsr	MemCopyUnPack
 579 0260 00 00 00 00 		.loc 1 372 0
 579      00 9C 
 369:octet_queue.c **** 
 370:octet_queue.c ****             /* Decrement the number of octets remaining to be copied */
 371:octet_queue.c ****             data_to_be_queued -= remaining;
 580                 	,@(0x0010,Y)
 581 0263 10 17       		sub	AL,@(0x0001,Y)
 582 0264 01 57       		st	AL,@(0x0010,Y)
 583 0265 10 27       		.loc 1 375 0
 372:octet_queue.c ****         
 373:octet_queue.c ****             /* Advance the input pointer */
 374:octet_queue.c ****             in += remaining/2;
 584                 	AL,@(0x0001,Y)
 585 0266 01 17       		ld	AH,@$XAP_AL
 586 0267 00 00 00 11 		lsr	#0x0001
 587 0269 00 09 01 A4 		ld	AL,@(0x0003,Y)
 588 026b 03 17       		ld	X,@$XAP_AL
 589 026c 00 00 00 19 		add	X,@$XAP_AH
 590 026e 00 00 00 39 		st	X,@(0x0003,Y)
 591 0270 03 2B       		.loc 1 378 0
 375:octet_queue.c **** 
 376:octet_queue.c ****             /* Reset the output pointer */
 377:octet_queue.c ****             out = (uint8 *)handle->p_buffer;
 592                 	0x0013,Y)
 593 0271 13 1B       		ld	AL,@(0,X)
 594 0272 00 16       		st	AL,@(0x0002,Y)
 595 0273 02 27       		.loc 1 381 0
 378:octet_queue.c ****         
 379:octet_queue.c ****             /* Reset the queue boundary */
 380:octet_queue.c ****             handle->boundary = 0;
 596                 	X,@(0x0013,Y)
 597 0274 13 1B       		ld	AL,#0x0000
 598 0275 00 14       		st	AL,@(0x0003,X)
 599 0276 03 26       		.loc 1 384 0
 381:octet_queue.c ****                 
 382:octet_queue.c ****             /* If the next octet to read is in the MSB */
 383:octet_queue.c ****             if ((data_to_be_queued > 0) && (remaining & 0x1))
 600                 		@(0x0010,Y)
 601 0277 10 9B       		beq	.L26
 602 0278 00 00 00 00 		ld	AL,@(0x0001,Y)
 602      00 F4 
 603 027b 01 17       		and	AL,#0x0001
 604 027c 01 C4       		tst	@$XAP_AL
 605 027d 00 00 00 99 		beq	.L26
 606 027f 00 00 00 00 		.loc 1 389 0
 606      00 F4 
 384:octet_queue.c ****             {
 385:octet_queue.c ****                 /* Copy the next octet separately (MemCopyUnPack only copies
 386:octet_queue.c ****                  * from whole words)
 387:octet_queue.c ****                  */
 388:octet_queue.c ****                 *out = (*in & 0xff00) >> 8;
 607                 	(0x0003,Y)
 608 0282 03 1B       		ld	AL,@(0,X)
 609 0283 00 16       		ld	AH,@$XAP_AL
 610 0284 00 00 00 11 		lsr	#0x0008
 611 0286 00 09 08 A4 		ld	AL,@$XAP_AH
 612 0288 00 00 00 15 		ld	X,@(0x0002,Y)
 613 028a 02 1B       		st	AL,@(0,X)
 614 028b 00 26       		.loc 1 392 0
 389:octet_queue.c ****         
 390:octet_queue.c ****                 /* Decrement number of octets remaining to be copied */
 391:octet_queue.c ****                 data_to_be_queued--;
 615                 	(0x0010,Y)
 616 028c 10 17       		ld	X,@$XAP_AL
 617 028d 00 00 00 19 		add	X,#0xffff
 618 028f FF 38       		st	X,@(0x0010,Y)
 619 0290 10 2B       		.loc 1 395 0
 392:octet_queue.c ****         
 393:octet_queue.c ****                 /* Advance buffer pointers */
 394:octet_queue.c ****                 out++;
 620                 	L,@(0x0002,Y)
 621 0291 02 17       		ld	X,@$XAP_AL
 622 0292 00 00 00 19 		add	X,#0x0001
 623 0294 01 38       		st	X,@(0x0002,Y)
 624 0295 02 2B       		.loc 1 396 0
 395:octet_queue.c ****                 in++;
 625                 	L,@(0x0003,Y)
 626 0296 03 17       		ld	X,@$XAP_AL
 627 0297 00 00 00 19 		add	X,#0x0001
 628 0299 01 38       		st	X,@(0x0003,Y)
 629 029a 03 2B       		.loc 1 399 0
 396:octet_queue.c ****         
 397:octet_queue.c ****                 /* Advance queue boundary */
 398:octet_queue.c ****                 handle->boundary++;                    
 630                 	,@(0x0013,Y)
 631 029b 13 1B       		ld	AL,@(0x0003,X)
 632 029c 03 16       		add	AL,#0x0001
 633 029d 01 34       		ld	X,@(0x0013,Y)
 634 029e 13 1B       		st	AL,@(0x0003,X)
 635 029f 03 26       	.L26:
 636                 		.loc 1 404 0
 399:octet_queue.c ****             }
 400:octet_queue.c ****         }
 401:octet_queue.c **** 
 402:octet_queue.c ****         /* Copy from source to destination */
 403:octet_queue.c ****         MemCopyUnPack(out, in, data_to_be_queued);
 637                 	@(0x0010,Y)
 638 02a0 10 17       		st	AL,@(0,Y)
 639 02a1 00 27       		ld	AL,@(0x0002,Y)
 640 02a2 02 17       		ld	AH,@(0x0003,Y)
 641 02a3 03 13       		bsr	MemCopyUnPack
 642 02a4 00 00 00 00 		.loc 1 407 0
 642      00 9C 
 404:octet_queue.c **** 
 405:octet_queue.c ****         /* Advance queue boundary */
 406:octet_queue.c ****         handle->boundary += data_to_be_queued;
 643                 	@(0x0013,Y)
 644 02a7 13 1B       		ld	AL,@(0x0003,X)
 645 02a8 03 16       		add	AL,@(0x0010,Y)
 646 02a9 10 37       		ld	X,@(0x0013,Y)
 647 02aa 13 1B       		st	AL,@(0x0003,X)
 648 02ab 03 26       	.L19:
 649                 	.LBE7:
 650                 		.loc 1 411 0
 407:octet_queue.c ****     }
 408:octet_queue.c **** 
 409:octet_queue.c ****     /* Buffer is not empty as we have just queued data */
 410:octet_queue.c ****     handle->empty = FALSE;
 651                 	0x0013,Y)
 652 02ac 13 1B       		ld	AL,#0x0000
 653 02ad 00 14       		st	AL,@(0x0004,X)
 654 02ae 04 26       		.loc 1 413 0
 411:octet_queue.c **** 
 412:octet_queue.c ****     return octets_queued;
 655                 	AL,@(0x0011,Y)
 656 02af 11 17       		st	AL,@(0x0016,Y)
 657 02b0 16 27       	.L4:
 658                 		ld	AL,@(0x0016,Y)
 659 02b1 16 17       		.loc 1 414 0
 413:octet_queue.c **** } /* queueData */
 660                 	e	#0x001c
 661 02b2 1C 0F       	.LFE2:
 662                 		.size	queueData, .-queueData
 663                 		.equ	__size_of_queueData,. - queueData
 664                 		.section	.text.popData,"ax",@progbits
 665                 		.type	popData, @function
 666                 	popData:
 667                 	.LFB3:
 668                 		.loc 1 438 0
 414:octet_queue.c **** 
 415:octet_queue.c **** /*----------------------------------------------------------------------------*
 416:octet_queue.c ****  *  NAME
 417:octet_queue.c ****  *      popData
 418:octet_queue.c ****  *
 419:octet_queue.c ****  *  DESCRIPTION
 420:octet_queue.c ****  *      Pop octets from the start of the queue into a buffer
 421:octet_queue.c ****  *
 422:octet_queue.c ****  *  PARAMETERS
 423:octet_queue.c ****  *      handle [in]             Handle to the octet queue from which data is to
 424:octet_queue.c ****  *                              be read
 425:octet_queue.c ****  *      p_data [in]             Pointer to a buffer where data from the queue is
 426:octet_queue.c ****  *                              to be copied. The size of each element in the
 427:octet_queue.c ****  *                              buffer depends on the data mode of the queue.
 428:octet_queue.c ****  *      data_size_in_octets [in]
 429:octet_queue.c ****  *                              The number of octets to be extracted.
 430:octet_queue.c ****  *
 431:octet_queue.c ****  *  RETURNS
 432:octet_queue.c ****  *      Number of octets actually extracted from the queue
 433:octet_queue.c ****  *----------------------------------------------------------------------------*/
 434:octet_queue.c **** static uint16 popData(OQ_HANDLE  handle,
 435:octet_queue.c ****                       void      *p_data,
 436:octet_queue.c ****                       uint16     data_size_in_octets)
 437:octet_queue.c **** {
 669                 	x0016
 670 0000 16 0B       	.LCFI1:
 671                 		st	AL,@(0x000e,Y)
 672 0001 0E 27       		st	AH,@(0x000f,Y)
 673 0002 0F 23       		.loc 1 441 0
 438:octet_queue.c ****     /* Total available data in the queue, in octets */
 439:octet_queue.c ****     /* (This will be 0 if handle is invalid) */
 440:octet_queue.c ****     const uint16 avlbl_data = OQSize(handle);
 674                 	L,@(0x000e,Y)
 675 0003 0E 17       		bsr	OQSize
 676 0004 00 00 00 00 		st	AL,@(0x000d,Y)
 676      00 9C 
 677 0007 0D 27       		.loc 1 444 0
 441:octet_queue.c ****     
 442:octet_queue.c ****     /* Number of octets of data that are to be fetched */
 443:octet_queue.c ****     const uint16 octets_fetched = MIN(avlbl_data, data_size_in_octets);
 678                 	AL,@(0x000d,Y)
 679 0008 0D 17       		st	AL,@(0x0012,Y)
 680 0009 12 27       		ld	X,@(0x0016,Y)
 681 000a 16 1B       		st	X,@(0x0011,Y)
 682 000b 11 2B       		ld	AL,@(0x0011,Y)
 683 000c 11 17       		cmp	AL,@(0x0012,Y)
 684 000d 12 87       		bcz	.L29
 685 000e 00 00 00 00 		ld	X,@(0x0012,Y)
 685      00 2C 
 686 0011 12 1B       		st	X,@(0x0011,Y)
 687 0012 11 2B       	.L29:
 688                 		ld	AL,@(0x0011,Y)
 689 0013 11 17       		st	AL,@(0x000c,Y)
 690 0014 0C 27       		.loc 1 447 0
 444:octet_queue.c **** 
 445:octet_queue.c ****     /* Number of octets remaining to be fetched */
 446:octet_queue.c ****     uint16 data_to_be_fetched = octets_fetched;
 691                 	0c,Y)
 692 0015 0C 17       		st	AL,@(0x000b,Y)
 693 0016 0B 27       		.loc 1 450 0
 447:octet_queue.c **** 
 448:octet_queue.c ****     /* If there is no data available return now */
 449:octet_queue.c ****     if (data_to_be_fetched == 0)
 694                 	t	@(0x000b,Y)
 695 0017 0B 9B       		bne	.L30
 696 0018 00 00 00 00 		.loc 1 451 0
 696      00 F0 
 450:octet_queue.c ****         return 0;
 697                 		X,#0x0000
 698 001b 00 18       		st	X,@(0x0010,Y)
 699 001c 10 2B       		bra	.L31
 700 001d 00 00 00 00 	.L30:
 700      00 E0 
 701                 		.loc 1 453 0
 451:octet_queue.c **** 
 452:octet_queue.c ****     if (handle->mode == OQDataMode_packed)
 702                 	,@(0x000e,Y)
 703 0020 0E 1B       		ld	AL,@(0x0005,X)
 704 0021 05 16       		cmp	AL,#0x0001
 705 0022 01 84       		bne	.L32
 706 0023 00 00 00 00 	.LBB8:
 706      00 F0 
 707                 		.loc 1 458 0
 453:octet_queue.c ****     {
 454:octet_queue.c ****         /* Octet queue is packed */
 455:octet_queue.c **** 
 456:octet_queue.c ****         /* Pointer into source buffer */
 457:octet_queue.c ****         const uint16 *in = (const uint16 *)handle->p_buffer + handle->start/2;
 708                 	@(0x000e,Y)
 709 0026 0E 1B       		ld	AL,@(0,X)
 710 0027 00 16       		st	AL,@0xfff8
 711 0028 F8 25       		ld	X,@(0x000e,Y)
 712 0029 0E 1B       		ld	AL,@(0x0002,X)
 713 002a 02 16       		ld	AH,@$XAP_AL
 714 002b 00 00 00 11 		lsr	#0x0001
 715 002d 00 09 01 A4 		ld	AL,@$XAP_AH
 716 002f 00 00 00 15 		ld	X,@0xfff8
 717 0031 F8 19       		add	X,@$XAP_AL
 718 0032 00 00 00 39 		st	X,@(0x000a,Y)
 719 0034 0A 2B       		.loc 1 460 0
 458:octet_queue.c ****         /* Pointer into destination buffer */
 459:octet_queue.c ****         uint16 *out = (uint16 *)p_data;
 720                 	00f,Y)
 721 0035 0F 17       		st	AL,@(0x0009,Y)
 722 0036 09 27       		.loc 1 462 0
 460:octet_queue.c ****         /* Flag to indicate whether source octet is from MSB or LSB */
 461:octet_queue.c ****         bool in_msb = handle->start & 0x1;
 723                 		X,@(0x000e,Y)
 724 0037 0E 1B       		ld	AL,@(0x0002,X)
 725 0038 02 16       		ld	X,@$XAP_AL
 726 0039 00 00 00 19 		and	X,#0x0001
 727 003b 01 C8       		st	X,@(0x0008,Y)
 728 003c 08 2B       		.loc 1 467 0
 462:octet_queue.c **** 
 463:octet_queue.c ****         /* If the source and destination buffers are not similarly aligned
 464:octet_queue.c ****          * (first destination octet is always in the LSB)
 465:octet_queue.c ****          */
 466:octet_queue.c ****         if (in_msb)
 729                 	(0x0008,Y)
 730 003d 08 9B       		beq	.L33
 731 003e 00 00 00 00 	.LBB9:
 731      00 F4 
 732                 		.loc 1 471 0
 467:octet_queue.c ****         {
 468:octet_queue.c ****             /* Pointer to first element beyond the buffer */
 469:octet_queue.c ****             const uint16 *const buffer_end = (const uint16 *)handle->p_buffer +
 470:octet_queue.c ****                                                               handle->capacity;
 733                 	X,@(0x000e,Y)
 734 0041 0E 1B       		ld	AL,@(0,X)
 735 0042 00 16       		ld	AH,@$XAP_AL
 736 0043 00 00 00 11 		ld	X,@(0x000e,Y)
 737 0045 0E 1B       		ld	AL,@(0x0001,X)
 738 0046 01 16       		ld	X,@$XAP_AH
 739 0047 00 00 00 19 		add	X,@$XAP_AL
 740 0049 00 00 00 39 		st	X,@(0x0007,Y)
 741 004b 07 2B       		.loc 1 473 0
 471:octet_queue.c ****             /* Flag to indicate whether destination octet is from MSB or LSB */
 472:octet_queue.c ****             bool out_msb = FALSE;   /* Always LSB to start with */
 742                 	x0000
 743 004c 00 14       		st	AL,@(0x0006,Y)
 744 004d 06 27       	.L41:
 745                 	.LBB10:
 746                 		.loc 1 481 0
 473:octet_queue.c **** 
 474:octet_queue.c ****             /* Copy each octet from source to destination one by one */
 475:octet_queue.c ****             do
 476:octet_queue.c ****             {
 477:octet_queue.c ****                 uint16 src_octet;       /* Octet to copy */
 478:octet_queue.c ****             
 479:octet_queue.c ****                 /* Read octet from source */
 480:octet_queue.c ****                 if (in_msb)
 747                 	@(0x0008,Y)
 748 004e 08 9B       		beq	.L34
 749 004f 00 00 00 00 		.loc 1 483 0
 749      00 F4 
 481:octet_queue.c ****                 {
 482:octet_queue.c ****                     src_octet = (*in & 0xff00) >> 8;
 750                 		X,@(0x000a,Y)
 751 0052 0A 1B       		ld	AL,@(0,X)
 752 0053 00 16       		ld	AH,@$XAP_AL
 753 0054 00 00 00 11 		lsr	#0x0008
 754 0056 00 09 08 A4 		st	AH,@(0x0005,Y)
 755 0058 05 23       		.loc 1 484 0
 483:octet_queue.c ****                     in++;   /* Move the input pointer to the next word */
 756                 	,@(0x000a,Y)
 757 0059 0A 17       		ld	X,@$XAP_AL
 758 005a 00 00 00 19 		add	X,#0x0001
 759 005c 01 38       		st	X,@(0x000a,Y)
 760 005d 0A 2B       		bra	.L35
 761 005e 00 00 00 00 	.L34:
 761      00 E0 
 762                 		.loc 1 488 0
 484:octet_queue.c ****                 }
 485:octet_queue.c ****                 else
 486:octet_queue.c ****                 {
 487:octet_queue.c ****                     src_octet = *in & 0x00ff;
 763                 	(0x000a,Y)
 764 0061 0A 1B       		ld	AL,@(0,X)
 765 0062 00 16       		ld	X,@$XAP_AL
 766 0063 00 00 00 19 		and	X,#0x00ff
 767 0065 01 00 FF C8 		st	X,@(0x0005,Y)
 768 0067 05 2B       	.L35:
 769                 		.loc 1 492 0
 488:octet_queue.c ****                 }
 489:octet_queue.c ****             
 490:octet_queue.c ****                 /* Write octet to destination */
 491:octet_queue.c ****                 if (out_msb)
 770                 	0x0006,Y)
 771 0068 06 9B       		beq	.L36
 772 0069 00 00 00 00 		.loc 1 494 0
 772      00 F4 
 492:octet_queue.c ****                 {
 493:octet_queue.c ****                     *out = (*out & 0x00ff) | (src_octet << 8);
 773                 		X,@(0x0009,Y)
 774 006c 09 1B       		ld	AL,@(0,X)
 775 006d 00 16       		ld	X,@$XAP_AL
 776 006e 00 00 00 19 		and	X,#0x00ff
 777 0070 01 00 FF C8 		ld	AL,@(0x0005,Y)
 778 0072 05 17       		asl	#0x0008
 779 0073 08 A0       		or	AL,@$XAP_UXL
 780 0074 00 00 00 B5 		ld	X,@(0x0009,Y)
 781 0076 09 1B       		st	AL,@(0,X)
 782 0077 00 26       		.loc 1 495 0
 494:octet_queue.c ****                     out++;  /* Move the output pointer to the next word */
 783                 	x0009,Y)
 784 0078 09 17       		ld	X,@$XAP_AL
 785 0079 00 00 00 19 		add	X,#0x0001
 786 007b 01 38       		st	X,@(0x0009,Y)
 787 007c 09 2B       		bra	.L37
 788 007d 00 00 00 00 	.L36:
 788      00 E0 
 789                 		.loc 1 499 0
 495:octet_queue.c ****                 }
 496:octet_queue.c ****                 else
 497:octet_queue.c ****                 {
 498:octet_queue.c ****                     *out = (*out & 0xff00) | src_octet;
 790                 	(0x0009,Y)
 791 0080 09 1B       		ld	AL,@(0,X)
 792 0081 00 16       		and	AL,#0xff00
 793 0082 FF 00 00 C4 		or	AL,@(0x0005,Y)
 794 0084 05 B7       		ld	X,@(0x0009,Y)
 795 0085 09 1B       		st	AL,@(0,X)
 796 0086 00 26       	.L37:
 797                 		.loc 1 503 0
 499:octet_queue.c ****                 }
 500:octet_queue.c **** 
 501:octet_queue.c ****                 /* Toggle MSB flags */
 502:octet_queue.c ****                 in_msb = !in_msb;
 798                 	0x0000
 799 0087 00 14       		st	AL,@(0x0013,Y)
 800 0088 13 27       		tst	@(0x0008,Y)
 801 0089 08 9B       		bne	.L38
 802 008a 00 00 00 00 		ld	X,#0x0001
 802      00 F0 
 803 008d 01 18       		st	X,@(0x0013,Y)
 804 008e 13 2B       	.L38:
 805                 		ld	AL,@(0x0013,Y)
 806 008f 13 17       		st	AL,@(0x0008,Y)
 807 0090 08 27       		.loc 1 504 0
 503:octet_queue.c ****                 out_msb = !out_msb;
 808                 	000
 809 0091 00 18       		st	X,@(0x0014,Y)
 810 0092 14 2B       		tst	@(0x0006,Y)
 811 0093 06 9B       		bne	.L39
 812 0094 00 00 00 00 		ld	AL,#0x0001
 812      00 F0 
 813 0097 01 14       		st	AL,@(0x0014,Y)
 814 0098 14 27       	.L39:
 815                 		ld	X,@(0x0014,Y)
 816 0099 14 1B       		st	X,@(0x0006,Y)
 817 009a 06 2B       		.loc 1 513 0
 504:octet_queue.c ****                     
 505:octet_queue.c ****                 /* The above could be optimised given that if in_msb is true,
 506:octet_queue.c ****                  * then out_msb must be false, and vice versa. In fact we do
 507:octet_queue.c ****                  * not need out_msb at all.
 508:octet_queue.c ****                  * It has been left un-optimised to improve readability.
 509:octet_queue.c ****                  */
 510:octet_queue.c ****                     
 511:octet_queue.c ****                 /* Decrement number of octets to be fetched */
 512:octet_queue.c ****                 data_to_be_fetched--;
 818                 	x000b,Y)
 819 009b 0B 17       		ld	X,@$XAP_AL
 820 009c 00 00 00 19 		add	X,#0xffff
 821 009e FF 38       		st	X,@(0x000b,Y)
 822 009f 0B 2B       		.loc 1 516 0
 513:octet_queue.c **** 
 514:octet_queue.c ****                 /* Reset the input pointer if end of buffer reached. */
 515:octet_queue.c ****                 if (in == buffer_end)
 823                 	L,@(0x000a,Y)
 824 00a0 0A 17       		cmp	AL,@(0x0007,Y)
 825 00a1 07 87       		bne	.L40
 826 00a2 00 00 00 00 		.loc 1 518 0
 826      00 F0 
 516:octet_queue.c ****                 {
 517:octet_queue.c ****                     in = (const uint16 *)handle->p_buffer;
 827                 	X,@(0x000e,Y)
 828 00a5 0E 1B       		ld	AL,@(0,X)
 829 00a6 00 16       		st	AL,@(0x000a,Y)
 830 00a7 0A 27       	.L40:
 831                 	.LBE10:
 832                 		.loc 1 520 0
 518:octet_queue.c ****                 }
 519:octet_queue.c ****             } while (data_to_be_fetched > 0);
 833                 	(0x000b,Y)
 834 00a8 0B 9B       		bne	.L41
 835 00a9 00 00 00 00 		bra	.L44
 835      00 F0 
 836 00ac 00 00 00 00 	.L33:
 836      00 E0 
 837                 	.LBE9:
 838                 	.LBB11:
 839                 		.loc 1 525 0
 520:octet_queue.c ****         }
 521:octet_queue.c ****         else /* !in_msb */
 522:octet_queue.c ****         {
 523:octet_queue.c ****             /* How many octets are available before the queue wraps round */
 524:octet_queue.c ****             const uint16 remaining = OQCapacity(handle) - handle->start;
 840                 	@(0x000e,Y)
 841 00af 0E 17       		bsr	OQCapacity
 842 00b0 00 00 00 00 		ld	AH,@$XAP_AL
 842      00 9C 
 843 00b3 00 00 00 11 		ld	X,@(0x000e,Y)
 844 00b5 0E 1B       		ld	AL,@(0x0002,X)
 845 00b6 02 16       		ld	X,@$XAP_AH
 846 00b7 00 00 00 19 		sub	X,@$XAP_AL
 847 00b9 00 00 00 59 		st	X,@(0x0004,Y)
 848 00bb 04 2B       		.loc 1 528 0
 525:octet_queue.c ****             
 526:octet_queue.c ****             /* Check whether the queue will wrap round */
 527:octet_queue.c ****             if (data_to_be_fetched >= remaining)
 849                 	0x000b,Y)
 850 00bc 0B 17       		cmp	AL,@(0x0004,Y)
 851 00bd 04 87       		bcs	.L43
 852 00be 00 00 00 00 		.loc 1 531 0
 852      00 FC 
 528:octet_queue.c ****             {
 529:octet_queue.c ****                 /* Copy the data from source to destination */
 530:octet_queue.c ****                 MemCopy(out, in, remaining/2);
 853                 	AL,@(0x0004,Y)
 854 00c1 04 17       		ld	AH,@$XAP_AL
 855 00c2 00 00 00 11 		lsr	#0x0001
 856 00c4 00 09 01 A4 		ld	AL,@$XAP_AH
 857 00c6 00 00 00 15 		st	AL,@(0,Y)
 858 00c8 00 27       		ld	AL,@(0x0009,Y)
 859 00c9 09 17       		ld	AH,@(0x000a,Y)
 860 00ca 0A 13       		bsr	memcpy
 861 00cb 00 00 00 00 		.loc 1 534 0
 861      00 9C 
 531:octet_queue.c ****                 
 532:octet_queue.c ****                 /* Decrement the number of octets waiting to be copied */
 533:octet_queue.c ****                 data_to_be_fetched -= remaining;
 862                 	0x000b,Y)
 863 00ce 0B 17       		sub	AL,@(0x0004,Y)
 864 00cf 04 57       		st	AL,@(0x000b,Y)
 865 00d0 0B 27       		.loc 1 537 0
 534:octet_queue.c ****                 
 535:octet_queue.c ****                 /* Reset the input pointer */
 536:octet_queue.c ****                 in = (const uint16 *)handle->p_buffer;
 866                 	X,@(0x000e,Y)
 867 00d1 0E 1B       		ld	AL,@(0,X)
 868 00d2 00 16       		st	AL,@(0x000a,Y)
 869 00d3 0A 27       		.loc 1 540 0
 537:octet_queue.c ****                 
 538:octet_queue.c ****                 /* Advance the output pointer */
 539:octet_queue.c ****                 out += remaining/2;
 870                 	AL,@(0x0004,Y)
 871 00d4 04 17       		ld	AH,@$XAP_AL
 872 00d5 00 00 00 11 		lsr	#0x0001
 873 00d7 00 09 01 A4 		ld	AL,@(0x0009,Y)
 874 00d9 09 17       		ld	X,@$XAP_AL
 875 00da 00 00 00 19 		add	X,@$XAP_AH
 876 00dc 00 00 00 39 		st	X,@(0x0009,Y)
 877 00de 09 2B       	.L43:
 878                 		.loc 1 544 0
 540:octet_queue.c ****             }
 541:octet_queue.c **** 
 542:octet_queue.c ****             /* Copy from source to destination */
 543:octet_queue.c ****             MemCopy(out, in, data_to_be_fetched/2);
 879                 	0x000b,Y)
 880 00df 0B 17       		ld	AH,@$XAP_AL
 881 00e0 00 00 00 11 		lsr	#0x0001
 882 00e2 00 09 01 A4 		ld	AL,@$XAP_AH
 883 00e4 00 00 00 15 		st	AL,@(0,Y)
 884 00e6 00 27       		ld	AL,@(0x0009,Y)
 885 00e7 09 17       		ld	AH,@(0x000a,Y)
 886 00e8 0A 13       		bsr	memcpy
 887 00e9 00 00 00 00 		.loc 1 547 0
 887      00 9C 
 544:octet_queue.c **** 
 545:octet_queue.c ****             /* If there is an odd octet remaining to be copied */
 546:octet_queue.c ****             if (data_to_be_fetched & 0x1)
 888                 	0x000b,Y)
 889 00ec 0B 17       		and	AL,#0x0001
 890 00ed 01 C4       		tst	@$XAP_AL
 891 00ee 00 00 00 99 		beq	.L44
 892 00f0 00 00 00 00 		.loc 1 550 0
 892      00 F4 
 547:octet_queue.c ****             {
 548:octet_queue.c ****                 /* Advance buffer pointers */
 549:octet_queue.c ****                 in += data_to_be_fetched/2;
 893                 	L,@(0x000b,Y)
 894 00f3 0B 17       		ld	AH,@$XAP_AL
 895 00f4 00 00 00 11 		lsr	#0x0001
 896 00f6 00 09 01 A4 		ld	AL,@(0x000a,Y)
 897 00f8 0A 17       		ld	X,@$XAP_AL
 898 00f9 00 00 00 19 		add	X,@$XAP_AH
 899 00fb 00 00 00 39 		st	X,@(0x000a,Y)
 900 00fd 0A 2B       		.loc 1 551 0
 550:octet_queue.c ****                 out += data_to_be_fetched/2;
 901                 	(0x000b,Y)
 902 00fe 0B 17       		ld	AH,@$XAP_AL
 903 00ff 00 00 00 11 		lsr	#0x0001
 904 0101 00 09 01 A4 		ld	AL,@(0x0009,Y)
 905 0103 09 17       		ld	X,@$XAP_AL
 906 0104 00 00 00 19 		add	X,@$XAP_AH
 907 0106 00 00 00 39 		st	X,@(0x0009,Y)
 908 0108 09 2B       		.loc 1 554 0
 551:octet_queue.c ****             
 552:octet_queue.c ****                 /* Copy the octet into the LSB leaving the MSB unaltered */
 553:octet_queue.c ****                 *out = (*out & 0xff00) | (*in & 0x00ff);
 909                 	0x0009,Y)
 910 0109 09 1B       		ld	AL,@(0,X)
 911 010a 00 16       		ld	AH,@$XAP_AL
 912 010b 00 00 00 11 		and	AH,#0xff00
 913 010d FF 00 00 C0 		ld	X,@(0x000a,Y)
 914 010f 0A 1B       		ld	AL,@(0,X)
 915 0110 00 16       		and	AL,#0x00ff
 916 0111 01 00 FF C4 		or	AL,@$XAP_AH
 917 0113 00 00 00 B5 		ld	X,@(0x0009,Y)
 918 0115 09 1B       		st	AL,@(0,X)
 919 0116 00 26       		bra	.L44
 920 0117 00 00 00 00 	.L32:
 920      00 E0 
 921                 	.LBE11:
 922                 	.LBE8:
 923                 	.LBB12:
 924                 		.loc 1 563 0
 554:octet_queue.c ****             }
 555:octet_queue.c ****         }
 556:octet_queue.c ****     }
 557:octet_queue.c ****     else /* handle->mode == OQDataMode_unpacked */
 558:octet_queue.c ****     {
 559:octet_queue.c ****         /* Octet queue is unpacked */
 560:octet_queue.c **** 
 561:octet_queue.c ****         /* Pointer into source buffer */
 562:octet_queue.c ****         const uint8 *in = (const uint8 *)handle->p_buffer + handle->start;
 925                 	)
 926 011a 0E 1B       		ld	AL,@(0,X)
 927 011b 00 16       		ld	AH,@$XAP_AL
 928 011c 00 00 00 11 		ld	X,@(0x000e,Y)
 929 011e 0E 1B       		ld	AL,@(0x0002,X)
 930 011f 02 16       		ld	X,@$XAP_AH
 931 0120 00 00 00 19 		add	X,@$XAP_AL
 932 0122 00 00 00 39 		st	X,@(0x0003,Y)
 933 0124 03 2B       		.loc 1 565 0
 563:octet_queue.c ****         /* Pointer into destination buffer */
 564:octet_queue.c ****         uint8 *out = (uint8 *)p_data;
 934                 	0x000f,Y)
 935 0125 0F 17       		st	AL,@(0x0002,Y)
 936 0126 02 27       		.loc 1 567 0
 565:octet_queue.c ****         /* How many octets are available before the queue wraps round */
 566:octet_queue.c ****         const uint16 remaining = OQCapacity(handle) - handle->start;
 937                 		AL,@(0x000e,Y)
 938 0127 0E 17       		bsr	OQCapacity
 939 0128 00 00 00 00 		ld	AH,@$XAP_AL
 939      00 9C 
 940 012b 00 00 00 11 		ld	X,@(0x000e,Y)
 941 012d 0E 1B       		ld	AL,@(0x0002,X)
 942 012e 02 16       		ld	X,@$XAP_AH
 943 012f 00 00 00 19 		sub	X,@$XAP_AL
 944 0131 00 00 00 59 		st	X,@(0x0001,Y)
 945 0133 01 2B       		.loc 1 570 0
 567:octet_queue.c ****             
 568:octet_queue.c ****         /* Check whether the queue will wrap round */
 569:octet_queue.c ****         if (data_to_be_fetched >= remaining)
 946                 	0x000b,Y)
 947 0134 0B 17       		cmp	AL,@(0x0001,Y)
 948 0135 01 87       		bcs	.L45
 949 0136 00 00 00 00 		.loc 1 573 0
 949      00 FC 
 570:octet_queue.c ****         {
 571:octet_queue.c ****             /* Copy the data from source to destination */
 572:octet_queue.c ****             MemCopy(out, in, remaining);
 950                 	AL,@(0x0001,Y)
 951 0139 01 17       		st	AL,@(0,Y)
 952 013a 00 27       		ld	AL,@(0x0002,Y)
 953 013b 02 17       		ld	AH,@(0x0003,Y)
 954 013c 03 13       		bsr	memcpy
 955 013d 00 00 00 00 		.loc 1 576 0
 955      00 9C 
 573:octet_queue.c ****                 
 574:octet_queue.c ****             /* Decrement the number of octets waiting to be copied */
 575:octet_queue.c ****             data_to_be_fetched -= remaining;
 956                 	,@(0x000b,Y)
 957 0140 0B 17       		sub	AL,@(0x0001,Y)
 958 0141 01 57       		st	AL,@(0x000b,Y)
 959 0142 0B 27       		.loc 1 579 0
 576:octet_queue.c ****                 
 577:octet_queue.c ****             /* Reset the input pointer */
 578:octet_queue.c ****             in = (const uint8 *)handle->p_buffer;
 960                 	X,@(0x000e,Y)
 961 0143 0E 1B       		ld	AL,@(0,X)
 962 0144 00 16       		st	AL,@(0x0003,Y)
 963 0145 03 27       		.loc 1 582 0
 579:octet_queue.c ****                 
 580:octet_queue.c ****             /* Advance the output pointer */
 581:octet_queue.c ****             out += remaining;
 964                 	AL,@(0x0002,Y)
 965 0146 02 17       		ld	X,@$XAP_AL
 966 0147 00 00 00 19 		add	X,@(0x0001,Y)
 967 0149 01 3B       		st	X,@(0x0002,Y)
 968 014a 02 2B       	.L45:
 969                 		.loc 1 586 0
 582:octet_queue.c ****         }
 583:octet_queue.c **** 
 584:octet_queue.c ****         /* Copy from source to destination */
 585:octet_queue.c ****         MemCopy(out, in, data_to_be_fetched);
 970                 	,@(0x000b,Y)
 971 014b 0B 17       		st	AL,@(0,Y)
 972 014c 00 27       		ld	AL,@(0x0002,Y)
 973 014d 02 17       		ld	AH,@(0x0003,Y)
 974 014e 03 13       		bsr	memcpy
 975 014f 00 00 00 00 	.L44:
 975      00 9C 
 976                 	.LBE12:
 977                 		.loc 1 592 0
 586:octet_queue.c ****     }
 587:octet_queue.c ****     
 588:octet_queue.c ****     /* Advance queue indices (and optionally fill empty spaces with fill
 589:octet_queue.c ****      * octet)
 590:octet_queue.c ****      */
 591:octet_queue.c ****     OQDecrementSize(handle, octets_fetched);
 978                 	(0x000e,Y)
 979 0152 0E 17       		ld	AH,@(0x000c,Y)
 980 0153 0C 13       		bsr	OQDecrementSize
 981 0154 00 00 00 00 		.loc 1 594 0
 981      00 9C 
 592:octet_queue.c **** 
 593:octet_queue.c ****     return octets_fetched;
 982                 	AL,@(0x000c,Y)
 983 0157 0C 17       		st	AL,@(0x0010,Y)
 984 0158 10 27       	.L31:
 985                 		ld	AL,@(0x0010,Y)
 986 0159 10 17       		.loc 1 595 0
 594:octet_queue.c **** } /* popData */
 987                 	e	#0x0016
 988 015a 16 0F       	.LFE3:
 989                 		.size	popData, .-popData
 990                 		.equ	__size_of_popData,. - popData
 991                 		.section	.text.OQCreate,"ax",@progbits
 992                 		.global	OQCreate
 993                 		.type	OQCreate, @function
 994                 	OQCreate:
 995                 	.LFB4:
 996                 		.loc 1 631 0
 595:octet_queue.c **** 
 596:octet_queue.c **** /*============================================================================*
 597:octet_queue.c ****  *  Public Function Implementations
 598:octet_queue.c ****  *============================================================================*/
 599:octet_queue.c **** 
 600:octet_queue.c **** /*----------------------------------------------------------------------------*
 601:octet_queue.c ****  *  NAME
 602:octet_queue.c ****  *      OQCreate
 603:octet_queue.c ****  *
 604:octet_queue.c ****  *  DESCRIPTION
 605:octet_queue.c ****  *      Create an octet queue on top of a given buffer. Automatically
 606:octet_queue.c ****  *      initialises the buffer with the fill character (since the queue is
 607:octet_queue.c ****  *      emptied upon creation), if buffer filling is enabled (#OQSetFill)
 608:octet_queue.c ****  *      prior to calling this function.
 609:octet_queue.c ****  *
 610:octet_queue.c ****  *  PARAMETERS
 611:octet_queue.c ****  *      p_buffer [in]           Buffer for backing the queue. The queue can only
 612:octet_queue.c ****  *                              function during the life span of the buffer. The
 613:octet_queue.c ****  *                              queue handle will become invalid once the buffer
 614:octet_queue.c ****  *                              is freed.
 615:octet_queue.c ****  *      buffer_capacity [in]    Total capacity of the buffer in number of
 616:octet_queue.c ****  *                              elements - i.e. number of uint8 for unpacked, or
 617:octet_queue.c ****  *                              number of uint16 if packed. Must be a positive
 618:octet_queue.c ****  *                              integer up to MAX_ALLOWED_BUFFER_CAPACITY.
 619:octet_queue.c ****  *      buffer_mode [in]        Mode in which the data is buffered
 620:octet_queue.c ****  *      handle [out]            Octet queue structure, into which the handle
 621:octet_queue.c ****  *                              will be created and copied.
 622:octet_queue.c ****  *
 623:octet_queue.c ****  *  RETURNS
 624:octet_queue.c ****  *      TRUE if success, FALSE if failed
 625:octet_queue.c ****  *----------------------------------------------------------------------------*/
 626:octet_queue.c **** bool OQCreate(void       *p_buffer,
 627:octet_queue.c ****                uint16      buffer_capacity,
 628:octet_queue.c ****                OQDataMode  buffer_mode,
 629:octet_queue.c ****                OQ_HANDLE   handle)
 630:octet_queue.c **** {
 997                 	0005
 998 0000 05 0B       	.LCFI2:
 999                 		st	AL,@(0x0001,Y)
 1000 0001 01 27       		st	AH,@(0x0002,Y)
 1001 0002 02 23       		.loc 1 636 0
 631:octet_queue.c ****     /* If  valid buffer capacity is specified, and data mode is valid */
 632:octet_queue.c ****     const bool ret_val = (handle != NULL) && (p_buffer != NULL) && 
 633:octet_queue.c ****                          (buffer_capacity <= MAX_ALLOWED_BUFFER_CAPACITY) &&
 634:octet_queue.c ****                          (buffer_capacity > 0) &&
 635:octet_queue.c ****                          (buffer_mode < OQDataMode_INVALID);
 1002                 	@(0x0006,Y)
 1003 0003 06 9B       		beq	.L48
 1004 0004 00 00 00 00 		tst	@(0x0001,Y)
 1004      00 F4 
 1005 0007 01 9B       		beq	.L48
 1006 0008 00 00 00 00 		ld	AL,@(0x0002,Y)
 1006      00 F4 
 1007 000b 02 17       		cmp	AL,#0x7fff
 1008 000c 80 00 FF 84 		bcc	.L48
 1009 000e 00 00 00 00 		tst	@(0x0002,Y)
 1009      00 F8 
 1010 0011 02 9B       		beq	.L48
 1011 0012 00 00 00 00 		ld	AL,@(0x0005,Y)
 1011      00 F4 
 1012 0015 05 17       		cmp	AL,#0x0002
 1013 0016 02 84       		bcc	.L48
 1014 0017 00 00 00 00 		ld	AL,#0x0001
 1014      00 F8 
 1015 001a 01 14       		st	AL,@(0x0003,Y)
 1016 001b 03 27       		bra	.L49
 1017 001c 00 00 00 00 	.L48:
 1017      00 E0 
 1018                 		ld	AL,#0x0000
 1019 001f 00 14       		st	AL,@(0x0003,Y)
 1020 0020 03 27       	.L49:
 1021                 		ld	AL,@(0x0003,Y)
 1022 0021 03 17       		st	AL,@(0,Y)
 1023 0022 00 27       		.loc 1 638 0
 636:octet_queue.c **** 
 637:octet_queue.c ****     if (ret_val)
 1024                 		.loc 1 641 0
 1025 0023 00 9B       		ld	X,@(0x0006,Y)
 1026 0024 00 00 00 00 		ld	AL,@(0x0001,Y)
 1026      00 F4 
 638:octet_queue.c ****     {
 639:octet_queue.c ****         /* Initialise the octet queue control structure */
 640:octet_queue.c ****         handle->p_buffer = p_buffer;
 1027                 		AL,@(0,X)
 1028 0027 06 1B       		.loc 1 642 0
 1029 0028 01 17       		ld	X,@(0x0006,Y)
 1030 0029 00 26       		ld	AL,@(0x0002,Y)
 641:octet_queue.c ****         handle->capacity = buffer_capacity;
 1031                 	AL,@(0x0001,X)
 1032 002a 06 1B       		.loc 1 643 0
 1033 002b 02 17       		ld	X,@(0x0006,Y)
 1034 002c 01 26       		ld	AL,@(0x0005,Y)
 642:octet_queue.c ****         handle->mode = buffer_mode;
 1035                 	AL,@(0x0005,X)
 1036 002d 06 1B       		.loc 1 644 0
 1037 002e 05 17       		ld	X,@(0x0006,Y)
 1038 002f 05 26       		ld	AL,#0x0000
 643:octet_queue.c ****         handle->start = 0;
 1039                 	AL,@(0x0002,X)
 1040 0030 06 1B       		.loc 1 645 0
 1041 0031 00 14       		ld	X,@(0x0006,Y)
 1042 0032 02 26       		ld	AL,#0x0000
 644:octet_queue.c ****         handle->boundary = 0;
 1043                 	AL,@(0x0003,X)
 1044 0033 06 1B       		.loc 1 646 0
 1045 0034 00 14       		ld	X,@(0x0006,Y)
 1046 0035 03 26       		ld	AL,#0x0001
 645:octet_queue.c ****         handle->empty = TRUE;
 1047                 	AL,@(0x0004,X)
 1048 0036 06 1B       	.L50:
 1049 0037 01 14       		.loc 1 657 0
 1050 0038 04 26       		ld	AL,@(0,Y)
 1051                 		.loc 1 658 0
 646:octet_queue.c **** #ifdef OQ_ENABLE_BUFFER_FILL
 647:octet_queue.c ****         /* Check whether filling is enabled for this queue */
 648:octet_queue.c ****         if (handle->fill & 0xff00)
 649:octet_queue.c ****         {
 650:octet_queue.c ****             /* Fill the buffer with fill octets */
 651:octet_queue.c ****             FILL_BUFFER(handle->p_buffer, handle->fill, handle->capacity);
 652:octet_queue.c ****         }
 653:octet_queue.c **** #endif
 654:octet_queue.c ****     }
 655:octet_queue.c ****     
 656:octet_queue.c ****     return ret_val;
 1052                 	e	#0x0005
 1053 0039 00 17       	.LFE4:
 657:octet_queue.c **** } /* OQCreate */
 1054                 	size	OQCreate, .-OQCreate
 1055 003a 05 0F       		.global	__size_of_OQCreate
 1056                 		.equ	__size_of_OQCreate,. - OQCreate
 1057                 		.section	.text.OQDestroy,"ax",@progbits
 1058                 		.global	OQDestroy
 1059                 		.type	OQDestroy, @function
 1060                 	OQDestroy:
 1061                 	.LFB5:
 1062                 		.loc 1 674 0
 1063                 		enter	#0x0002
 1064                 	.LCFI3:
 658:octet_queue.c **** 
 659:octet_queue.c **** /*----------------------------------------------------------------------------*
 660:octet_queue.c ****  *  NAME
 661:octet_queue.c ****  *      OQDestroy
 662:octet_queue.c ****  *
 663:octet_queue.c ****  *  DESCRIPTION
 664:octet_queue.c ****  *      Destroy the queue. The handle will no longer be valid.
 665:octet_queue.c ****  *
 666:octet_queue.c ****  *  PARAMETERS
 667:octet_queue.c ****  *      handle [in/out]         Handle to the queue to destroy
 668:octet_queue.c ****  *
 669:octet_queue.c ****  *  RETURNS
 670:octet_queue.c ****  *      Nothing
 671:octet_queue.c ****  *----------------------------------------------------------------------------*/
 672:octet_queue.c **** void OQDestroy(OQ_HANDLE handle)
 673:octet_queue.c **** {
 1065                 	Y)
 1066 0000 02 0B       		.loc 1 675 0
 1067                 		tst	@(0,Y)
 1068 0001 00 27       		beq	.L54
 674:octet_queue.c ****     if (handle != NULL)
 1069                 	c 1 677 0
 1070 0002 00 9B       		ld	X,@(0,Y)
 1071 0003 00 00 00 00 		ld	AL,#0x0000
 1071      00 F4 
 675:octet_queue.c ****     {
 676:octet_queue.c ****         handle->p_buffer = NULL;
 1072                 		AL,@(0,X)
 1073 0006 00 1B       		.loc 1 678 0
 1074 0007 00 14       		ld	X,@(0,Y)
 1075 0008 00 26       		ld	AL,#0x0000
 677:octet_queue.c ****         handle->capacity = 0;
 1076                 	AL,@(0x0001,X)
 1077 0009 00 1B       		.loc 1 679 0
 1078 000a 00 14       		ld	X,@(0,Y)
 1079 000b 01 26       		ld	AL,#0x0001
 678:octet_queue.c ****         handle->empty = TRUE;
 1080                 	AL,@(0x0004,X)
 1081 000c 00 1B       	.L54:
 1082 000d 01 14       		.loc 1 681 0
 1083 000e 04 26       		leave	#0x0002
 1084                 	.LFE5:
 679:octet_queue.c ****     }
 680:octet_queue.c **** } /* OQDestroy */
 1085                 	e	OQDestroy, .-OQDestroy
 1086 000f 02 0F       		.global	__size_of_OQDestroy
 1087                 		.equ	__size_of_OQDestroy,. - OQDestroy
 1088                 		.section	.text.OQIsValid,"ax",@progbits
 1089                 		.global	OQIsValid
 1090                 		.type	OQIsValid, @function
 1091                 	OQIsValid:
 1092                 	.LFB6:
 1093                 		.loc 1 697 0
 1094                 		enter	#0x0003
 1095                 	.LCFI4:
 681:octet_queue.c **** 
 682:octet_queue.c **** /*----------------------------------------------------------------------------*
 683:octet_queue.c ****  *  NAME
 684:octet_queue.c ****  *      OQIsValid
 685:octet_queue.c ****  *
 686:octet_queue.c ****  *  DESCRIPTION
 687:octet_queue.c ****  *      Check that the supplied handle has not been destroyed
 688:octet_queue.c ****  *
 689:octet_queue.c ****  *  PARAMETERS
 690:octet_queue.c ****  *      handle [in]             Handle to the queue to validate
 691:octet_queue.c ****  *
 692:octet_queue.c ****  *  RETURNS
 693:octet_queue.c ****  *      TRUE if the queue is valid, FALSE otherwise
 694:octet_queue.c ****  *----------------------------------------------------------------------------*/
 695:octet_queue.c **** bool OQIsValid(const OQ_HANDLE handle)
 696:octet_queue.c **** {
 1096                 	Y)
 1097 0000 03 0B       		.loc 1 698 0
 1098                 		tst	@(0,Y)
 1099 0001 00 27       		beq	.L56
 697:octet_queue.c ****     return ((handle != NULL) &&
 1100                 	X,@(0,Y)
 1101 0002 00 9B       		ld	AL,@(0,X)
 1102 0003 00 00 00 00 		tst	@$XAP_AL
 1102      00 F4 
 1103 0006 00 1B       		beq	.L56
 1104 0007 00 16       		ld	X,@(0,Y)
 1105 0008 00 00 00 99 		ld	AL,@(0x0001,X)
 1106 000a 00 00 00 00 		tst	@$XAP_AL
 1106      00 F4 
 1107 000d 00 1B       		beq	.L56
 1108 000e 01 16       		ld	AL,#0x0001
 1109 000f 00 00 00 99 		st	AL,@(0x0001,Y)
 1110 0011 00 00 00 00 		bra	.L57
 1110      00 F4 
 1111 0014 01 14       	.L56:
 1112 0015 01 27       		ld	AL,#0x0000
 1113 0016 00 00 00 00 		st	AL,@(0x0001,Y)
 1113      00 E0 
 1114                 	.L57:
 1115 0019 00 14       		ld	AL,@(0x0001,Y)
 1116 001a 01 27       		.loc 1 701 0
 1117                 		leave	#0x0003
 1118 001b 01 17       	.LFE6:
 698:octet_queue.c ****             (handle->p_buffer != NULL) &&
 699:octet_queue.c ****             (handle->capacity > 0));
 700:octet_queue.c **** } /* OQIsValid */
 1119                 	-OQIsValid
 1120 001c 03 0F       		.global	__size_of_OQIsValid
 1121                 		.equ	__size_of_OQIsValid,. - OQIsValid
 1122                 		.section	.text.OQQueueData,"ax",@progbits
 1123                 		.global	OQQueueData
 1124                 		.type	OQQueueData, @function
 1125                 	OQQueueData:
 1126                 	.LFB7:
 1127                 		.loc 1 727 0
 1128                 		enter	#0x0006
 1129                 	.LCFI5:
 701:octet_queue.c **** 
 702:octet_queue.c **** /*----------------------------------------------------------------------------*
 703:octet_queue.c ****  *  NAME
 704:octet_queue.c ****  *      OQQueueData
 705:octet_queue.c ****  *
 706:octet_queue.c ****  *  DESCRIPTION
 707:octet_queue.c ****  *      Queue data into octet queue
 708:octet_queue.c ****  *
 709:octet_queue.c ****  *  PARAMETERS
 710:octet_queue.c ****  *      handle [in]             Handle to the queue
 711:octet_queue.c ****  *      p_data [in]             Buffer holding data to be queued. The buffer
 712:octet_queue.c ****  *                              must be packed in the same way as the queue.
 713:octet_queue.c ****  *                              If the buffer is packed, then the first octet
 714:octet_queue.c ****  *                              will be taken from the LSB of the first word in
 715:octet_queue.c ****  *                              the buffer.
 716:octet_queue.c ****  *      octet_count [in]        The number of octets of data to be queued.
 717:octet_queue.c ****  *                              If there is not enough space in the queue then
 718:octet_queue.c ****  *                              as many octets as will fit will be queued.
 719:octet_queue.c ****  *                              An odd number of octets is acceptable whichever
 720:octet_queue.c ****  *                              packing mode is used.
 721:octet_queue.c ****  *
 722:octet_queue.c ****  *  RETURNS
 723:octet_queue.c ****  *      Number of octets of data actually queued
 724:octet_queue.c ****  *----------------------------------------------------------------------------*/
 725:octet_queue.c **** uint16 OQQueueData(OQ_HANDLE handle, const void *p_data, uint16 octet_count)
 726:octet_queue.c **** {
 1130                 	0003,Y)
 1131 0000 06 0B       		st	AH,@(0x0004,Y)
 1132                 		.loc 1 728 0
 1133 0001 03 27       		ld	X,@(0x0003,Y)
 1134 0002 04 23       		ld	AH,@(0x0005,X)
 727:octet_queue.c ****     return queueData(handle, p_data, octet_count, FALSE, handle->mode);
 1135                 	L,@(0x0006,Y)
 1136 0003 03 1B       		st	AL,@(0,Y)
 1137 0004 05 12       		ld	AL,#0x0000
 1138 0005 06 17       		st	AL,@(0x0001,Y)
 1139 0006 00 27       		st	AH,@(0x0002,Y)
 1140 0007 00 14       		ld	AL,@(0x0003,Y)
 1141 0008 01 27       		ld	AH,@(0x0004,Y)
 1142 0009 02 23       		bsr	queueData
 1143 000a 03 17       		.loc 1 729 0
 1144 000b 04 13       		leave	#0x0006
 1145 000c 00 00 00 00 	.LFE7:
 1145      00 9C 
 728:octet_queue.c **** } /* OQQueueData */
 1146                 	eueData, .-OQQueueData
 1147 000f 06 0F       		.global	__size_of_OQQueueData
 1148                 		.equ	__size_of_OQQueueData,. - OQQueueData
 1149                 		.section	.text.OQPopData,"ax",@progbits
 1150                 		.global	OQPopData
 1151                 		.type	OQPopData, @function
 1152                 	OQPopData:
 1153                 	.LFB8:
 1154                 		.loc 1 755 0
 1155                 		enter	#0x0004
 1156                 	.LCFI6:
 729:octet_queue.c **** 
 730:octet_queue.c **** /*----------------------------------------------------------------------------*
 731:octet_queue.c ****  *  NAME
 732:octet_queue.c ****  *      OQPopData
 733:octet_queue.c ****  *
 734:octet_queue.c ****  *  DESCRIPTION
 735:octet_queue.c ****  *      Extract octets from the head of the queue into a buffer
 736:octet_queue.c ****  *
 737:octet_queue.c ****  *  PARAMETERS
 738:octet_queue.c ****  *      handle [in]             Handle to the queue
 739:octet_queue.c ****  *      p_data [out]            Buffer to which data from the queue is to be
 740:octet_queue.c ****  *                              extracted. The buffer must be packed in the same
 741:octet_queue.c ****  *                              way as the queue. If the buffer is packed, then
 742:octet_queue.c ****  *                              the first octet will be stored in the LSB of the
 743:octet_queue.c ****  *                              first word in the buffer.
 744:octet_queue.c ****  *      octet_count [in]        The number of octets of data to be extracted.
 745:octet_queue.c ****  *                              If there is not enough data in the queue then
 746:octet_queue.c ****  *                              as many octets as are available will be
 747:octet_queue.c ****  *                              extracted. An odd number of octets is acceptable
 748:octet_queue.c ****  *                              whichever packing mode is used.
 749:octet_queue.c ****  *
 750:octet_queue.c ****  *  RETURNS
 751:octet_queue.c ****  *      Number of octets actually extracted from the queue.
 752:octet_queue.c ****  *----------------------------------------------------------------------------*/
 753:octet_queue.c **** uint16 OQPopData(OQ_HANDLE handle, void *p_data, uint16 octet_count)
 754:octet_queue.c **** {
 1157                 	0001,Y)
 1158 0000 04 0B       		st	AH,@(0x0002,Y)
 1159                 		.loc 1 756 0
 1160 0001 01 27       		ld	AL,@(0x0004,Y)
 1161 0002 02 23       		st	AL,@(0,Y)
 755:octet_queue.c ****     return popData(handle, p_data, octet_count);
 1162                 	L,@(0x0001,Y)
 1163 0003 04 17       		ld	AH,@(0x0002,Y)
 1164 0004 00 27       		bsr	popData
 1165 0005 01 17       		.loc 1 757 0
 1166 0006 02 13       		leave	#0x0004
 1167 0007 00 00 00 00 	.LFE8:
 1167      00 9C 
 756:octet_queue.c **** } /* OQPopData */
 1168                 		OQPopData, .-OQPopData
 1169 000a 04 0F       		.global	__size_of_OQPopData
 1170                 		.equ	__size_of_OQPopData,. - OQPopData
 1171                 		.section	.text.OQTransferData,"ax",@progbits
 1172                 		.global	OQTransferData
 1173                 		.type	OQTransferData, @function
 1174                 	OQTransferData:
 1175                 	.LFB9:
 1176                 		.loc 1 788 0
 1177                 		enter	#0x0012
 1178                 	.LCFI7:
 757:octet_queue.c **** 
 758:octet_queue.c **** /*----------------------------------------------------------------------------*
 759:octet_queue.c ****  *  NAME
 760:octet_queue.c ****  *      OQTransferData
 761:octet_queue.c ****  *
 762:octet_queue.c ****  *  DESCRIPTION
 763:octet_queue.c ****  *      Extract data from one octet queue and insert it into another. Queues
 764:octet_queue.c ****  *      need not have identical data packing modes.
 765:octet_queue.c ****  *      Effectively the same as calling OQPopData followed by OQQueueData
 766:octet_queue.c ****  *      without having to create a buffer to hold the data inbetween.
 767:octet_queue.c ****  *
 768:octet_queue.c ****  *  PARAMETERS
 769:octet_queue.c ****  *      from [in]               Handle to the octet queue from which data is to
 770:octet_queue.c ****  *                              be read
 771:octet_queue.c ****  *      to [out]                Handle to the octet queue into which data is to
 772:octet_queue.c ****  *                              be queued
 773:octet_queue.c ****  *      octet_count [in]        The number of octets of data to be transferred.
 774:octet_queue.c ****  *                              If there is not enough data in the source queue
 775:octet_queue.c ****  *                              then only as much data as is available will be
 776:octet_queue.c ****  *                              transferred.
 777:octet_queue.c ****  *                              If there is not enough space in the destination
 778:octet_queue.c ****  *                              queue then only as much data as there is space
 779:octet_queue.c ****  *                              for will be transferred.
 780:octet_queue.c ****  *                              An odd number of octets is acceptable whichever
 781:octet_queue.c ****  *                              packing mode is used.
 782:octet_queue.c ****  *
 783:octet_queue.c ****  *  RETURNS
 784:octet_queue.c ****  *      Number of octets actually transferred.
 785:octet_queue.c ****  *----------------------------------------------------------------------------*/
 786:octet_queue.c **** uint16 OQTransferData(OQ_HANDLE from, OQ_HANDLE to, uint16 octet_count)
 787:octet_queue.c **** {
 1179                 	000a,Y)
 1180 0000 12 0B       		st	AH,@(0x000b,Y)
 1181                 		.loc 1 791 0
 1182 0001 0A 27       		ld	AL,@(0x000b,Y)
 1183 0002 0B 23       		bsr	OQSpace
 788:octet_queue.c ****     /* Available space in the destination queue, in octets */
 789:octet_queue.c ****     /* (This will be 0 if handle is invalid) */
 790:octet_queue.c ****     const uint16 avlbl_space = OQSpace(to);
 1184                 	L,@(0x0009,Y)
 1185 0003 0B 17       		.loc 1 795 0
 1186 0004 00 00 00 00 		ld	AL,@(0x000a,Y)
 1186      00 9C 
 1187 0007 09 27       		bsr	OQSize
 791:octet_queue.c ****     
 792:octet_queue.c ****     /* Total available data in the source queue, in octets */
 793:octet_queue.c ****     /* (This will be 0 if handle is invalid) */
 794:octet_queue.c ****     const uint16 avlbl_data = OQSize(from);
 1188                 	AL,@(0x0008,Y)
 1189 0008 0A 17       		.loc 1 798 0
 1190 0009 00 00 00 00 		ld	AL,@(0x0008,Y)
 1190      00 9C 
 1191 000c 08 27       		st	AL,@(0x000e,Y)
 795:octet_queue.c **** 
 796:octet_queue.c ****     /* Maximum number of octets of data that can be transferred */
 797:octet_queue.c ****     const uint16 octets_moved = MIN(MIN(avlbl_data, avlbl_space), octet_count);
 1192                 	X,@(0x0009,Y)
 1193 000d 08 17       		st	X,@(0x000d,Y)
 1194 000e 0E 27       		ld	AL,@(0x000d,Y)
 1195 000f 09 1B       		cmp	AL,@(0x000e,Y)
 1196 0010 0D 2B       		bcz	.L64
 1197 0011 0D 17       		ld	X,@(0x000e,Y)
 1198 0012 0E 87       		st	X,@(0x000d,Y)
 1199 0013 00 00 00 00 	.L64:
 1199      00 2C 
 1200 0016 0E 1B       		ld	AL,@(0x0012,Y)
 1201 0017 0D 2B       		st	AL,@(0x0010,Y)
 1202                 		ld	X,@(0x000d,Y)
 1203 0018 12 17       		st	X,@(0x000f,Y)
 1204 0019 10 27       		ld	AL,@(0x000f,Y)
 1205 001a 0D 1B       		cmp	AL,@(0x0010,Y)
 1206 001b 0F 2B       		bcz	.L65
 1207 001c 0F 17       		ld	X,@(0x0010,Y)
 1208 001d 10 87       		st	X,@(0x000f,Y)
 1209 001e 00 00 00 00 	.L65:
 1209      00 2C 
 1210 0021 10 1B       		ld	AL,@(0x000f,Y)
 1211 0022 0F 2B       		st	AL,@(0x0007,Y)
 1212                 		.loc 1 801 0
 1213 0023 0F 17       		ld	AL,@(0x0007,Y)
 1214 0024 07 27       		st	AL,@(0x0006,Y)
 798:octet_queue.c **** 
 799:octet_queue.c ****     /* Number of octets remaining to be transferred */
 800:octet_queue.c ****     uint16 data_to_be_moved = octets_moved;
 1215                 	0x000a,Y)
 1216 0025 07 17       		bsr	OQCapacity
 1217 0026 06 27       		ld	AH,@$XAP_AL
 801:octet_queue.c ****     
 802:octet_queue.c ****     /* How many octets are available before the source queue wraps round */
 803:octet_queue.c ****     const uint16 remaining = OQCapacity(from) - from->start;
 1218                 		X,@(0x000a,Y)
 1219 0027 0A 17       		ld	AL,@(0x0002,X)
 1220 0028 00 00 00 00 		ld	X,@$XAP_AH
 1220      00 9C 
 1221 002b 00 00 00 11 		sub	X,@$XAP_AL
 1222 002d 0A 1B       		st	X,@(0x0005,Y)
 1223 002e 02 16       		.loc 1 807 0
 1224 002f 00 00 00 19 		ld	X,@(0x000a,Y)
 1225 0031 00 00 00 59 		ld	AL,@(0x0002,X)
 1226 0033 05 2B       		ld	X,@$XAP_AL
 804:octet_queue.c **** 	
 805:octet_queue.c ****     /* Indicate whether first octet is from MSB (ignored in unpacked mode) */
 806:octet_queue.c ****     bool first_msb = from->start & 0x1;
 1227                 	x0001
 1228 0034 0A 1B       		st	X,@(0x0004,Y)
 1229 0035 02 16       		.loc 1 813 0
 1230 0036 00 00 00 19 		tst	@(0x0006,Y)
 1231 0038 01 C8       		bne	.L66
 1232 0039 04 2B       		.loc 1 814 0
 807:octet_queue.c **** 
 808:octet_queue.c ****     /* Pointer into the source buffer */
 809:octet_queue.c ****     const void *src;
 810:octet_queue.c **** 	
 811:octet_queue.c ****     /* If there is no data to transfer return now */
 812:octet_queue.c ****     if (data_to_be_moved == 0)
 1233                 	,#0x0000
 1234 003a 06 9B       		st	AL,@(0x000c,Y)
 1235 003b 00 00 00 00 		bra	.L67
 1235      00 F0 
 813:octet_queue.c ****         return 0;
 1236                 	6:
 1237 003e 00 14       		.loc 1 817 0
 1238 003f 0C 27       		ld	X,@(0x000a,Y)
 1239 0040 00 00 00 00 		ld	AL,@(0x0005,X)
 1239      00 E0 
 1240                 		cmp	AL,#0x0001
 814:octet_queue.c ****     
 815:octet_queue.c ****     /* Set up the source pointer based on the queue data mode */
 816:octet_queue.c ****     if (from->mode == OQDataMode_packed)
 1241                 	.L68
 1242 0043 0A 1B       		.loc 1 819 0
 1243 0044 05 16       		ld	X,@(0x000a,Y)
 1244 0045 01 84       		ld	AL,@(0,X)
 1245 0046 00 00 00 00 		st	AL,@0xfff8
 1245      00 F0 
 817:octet_queue.c ****     {
 818:octet_queue.c ****         src = (const uint16 *)from->p_buffer + from->start/2;
 1246                 	,@(0x000a,Y)
 1247 0049 0A 1B       		ld	AL,@(0x0002,X)
 1248 004a 00 16       		ld	AH,@$XAP_AL
 1249 004b F8 25       		lsr	#0x0001
 1250 004c 0A 1B       		ld	AL,@$XAP_AH
 1251 004d 02 16       		ld	X,@0xfff8
 1252 004e 00 00 00 11 		add	X,@$XAP_AL
 1253 0050 00 09 01 A4 		st	X,@(0x0003,Y)
 1254 0052 00 00 00 15 		bra	.L69
 1255 0054 F8 19       	.L68:
 1256 0055 00 00 00 39 		.loc 1 823 0
 1257 0057 03 2B       		ld	X,@(0x000a,Y)
 1258 0058 00 00 00 00 		ld	AH,@(0,X)
 1258      00 E0 
 1259                 		ld	X,@(0x000a,Y)
 819:octet_queue.c ****     }
 820:octet_queue.c ****     else
 821:octet_queue.c ****     {
 822:octet_queue.c ****         src = (const uint8 *)from->p_buffer + from->start;
 1260                 	2,X)
 1261 005b 0A 1B       		ld	X,@$XAP_AH
 1262 005c 00 12       		add	X,@$XAP_AL
 1263 005d 0A 1B       		st	X,@(0x0003,Y)
 1264 005e 02 16       	.L69:
 1265 005f 00 00 00 19 		.loc 1 827 0
 1266 0061 00 00 00 39 		ld	AL,@(0x0006,Y)
 1267 0063 03 2B       		cmp	AL,@(0x0005,Y)
 1268                 		bcz	.L70
 823:octet_queue.c ****     }
 824:octet_queue.c ****     
 825:octet_queue.c ****     /* Check whether the source buffer will wrap round */
 826:octet_queue.c ****     if (data_to_be_moved > remaining)
 1269                 	30 0
 1270 0064 06 17       		ld	X,@(0x000a,Y)
 1271 0065 05 87       		ld	AH,@(0x0005,X)
 1272 0066 00 00 00 00 		ld	AL,@(0x0005,Y)
 1272      00 2C 
 827:octet_queue.c ****     {
 828:octet_queue.c ****         /* Copy data from source to destination */
 829:octet_queue.c ****         queueData(to, src, remaining, first_msb, from->mode);
 1273                 	AL,@(0,Y)
 1274 0069 0A 1B       		ld	AL,@(0x0004,Y)
 1275 006a 05 12       		st	AL,@(0x0001,Y)
 1276 006b 05 17       		st	AH,@(0x0002,Y)
 1277 006c 00 27       		ld	AL,@(0x000b,Y)
 1278 006d 04 17       		ld	AH,@(0x0003,Y)
 1279 006e 01 27       		bsr	queueData
 1280 006f 02 23       		.loc 1 833 0
 1281 0070 0B 17       		ld	AL,@(0x0006,Y)
 1282 0071 03 13       		sub	AL,@(0x0005,Y)
 1283 0072 00 00 00 00 		st	AL,@(0x0006,Y)
 1283      00 9C 
 830:octet_queue.c **** 
 831:octet_queue.c ****         /* Decrement the number of octets waiting to be moved */
 832:octet_queue.c ****         data_to_be_moved -= remaining;
 1284                 	 0
 1285 0075 06 17       		ld	X,@(0x000a,Y)
 1286 0076 05 57       		ld	AL,@(0,X)
 1287 0077 06 27       		st	AL,@(0x0003,Y)
 833:octet_queue.c ****         
 834:octet_queue.c ****         /* Reset the input pointer */
 835:octet_queue.c ****         src = from->p_buffer;
 1288                 	c 1 839 0
 1289 0078 0A 1B       		ld	AL,#0x0000
 1290 0079 00 16       		st	AL,@(0x0004,Y)
 1291 007a 03 27       	.L70:
 836:octet_queue.c **** 	    
 837:octet_queue.c ****         /* Update MSB flag */
 838:octet_queue.c ****         first_msb = FALSE;
 1292                 	c 1 843 0
 1293 007b 00 14       		ld	X,@(0x000a,Y)
 1294 007c 04 27       		ld	AH,@(0x0005,X)
 1295                 		ld	AL,@(0x0006,Y)
 839:octet_queue.c ****     }
 840:octet_queue.c **** 
 841:octet_queue.c ****     /* Copy data from source to destination */
 842:octet_queue.c ****     queueData(to, src, data_to_be_moved, first_msb, from->mode);
 1296                 	AL,@(0,Y)
 1297 007d 0A 1B       		ld	AL,@(0x0004,Y)
 1298 007e 05 12       		st	AL,@(0x0001,Y)
 1299 007f 06 17       		st	AH,@(0x0002,Y)
 1300 0080 00 27       		ld	AL,@(0x000b,Y)
 1301 0081 04 17       		ld	AH,@(0x0003,Y)
 1302 0082 01 27       		bsr	queueData
 1303 0083 02 23       		.loc 1 847 0
 1304 0084 0B 17       		ld	AL,@(0x000a,Y)
 1305 0085 03 13       		ld	AH,@(0x0007,Y)
 1306 0086 00 00 00 00 		bsr	OQDecrementSize
 1306      00 9C 
 843:octet_queue.c **** 
 844:octet_queue.c ****     /* Decrement the size of the source to account for data that has
 845:octet_queue.c ****      * been transferred */
 846:octet_queue.c ****     OQDecrementSize(from, octets_moved);
 1307                 	 0
 1308 0089 0A 17       		ld	X,@(0x0007,Y)
 1309 008a 07 13       		st	X,@(0x000c,Y)
 1310 008b 00 00 00 00 	.L67:
 1310      00 9C 
 847:octet_queue.c **** 
 848:octet_queue.c ****     return octets_moved;
 1311                 	AL,@(0x000c,Y)
 1312 008e 07 1B       		.loc 1 850 0
 1313 008f 0C 2B       		leave	#0x0012
 1314                 	.LFE9:
 1315 0090 0C 17       		.size	OQTransferData, .-OQTransferData
 849:octet_queue.c **** } /* OQTransferData */
 1316                 	bal	__size_of_OQTransferData
 1317 0091 12 0F       		.equ	__size_of_OQTransferData,. - OQTransferData
 1318                 		.section	.text.OQSize,"ax",@progbits
 1319                 		.global	OQSize
 1320                 		.type	OQSize, @function
 1321                 	OQSize:
 1322                 	.LFB10:
 1323                 		.loc 1 866 0
 1324                 		enter	#0x0003
 1325                 	.LCFI8:
 1326                 		st	AL,@(0x0001,Y)
 850:octet_queue.c **** 
 851:octet_queue.c **** /*----------------------------------------------------------------------------*
 852:octet_queue.c ****  *  NAME
 853:octet_queue.c ****  *      OQSize
 854:octet_queue.c ****  *
 855:octet_queue.c ****  *  DESCRIPTION
 856:octet_queue.c ****  *      Get the size of the data in an octet queue.
 857:octet_queue.c ****  *
 858:octet_queue.c ****  *  PARAMETERS
 859:octet_queue.c ****  *      handle [in]             Handle to the octet queue
 860:octet_queue.c ****  *
 861:octet_queue.c ****  *  RETURNS
 862:octet_queue.c ****  *      Number of octets queued
 863:octet_queue.c ****  *----------------------------------------------------------------------------*/
 864:octet_queue.c **** uint16 OQSize(const OQ_HANDLE handle)
 865:octet_queue.c **** {
 1327                 	 0
 1328 0000 03 0B       		ld	AL,#0x0000
 1329                 		st	AL,@(0,Y)
 1330 0001 01 27       		.loc 1 870 0
 866:octet_queue.c ****     uint16 data_size = 0;               /* Size of queued data in octets */
 1331                 		@(0x0001,Y)
 1332 0002 00 14       		beq	.L73
 1333 0003 00 27       		ld	X,@(0x0001,Y)
 867:octet_queue.c ****     
 868:octet_queue.c ****     /* If the buffer is not empty */
 869:octet_queue.c ****     if ((handle != NULL) && !handle->empty)
 1334                 		AL,@(0x0004,X)
 1335 0004 01 9B       		tst	@$XAP_AL
 1336 0005 00 00 00 00 		bne	.L73
 1336      00 F4 
 1337 0008 01 1B       		.loc 1 873 0
 1338 0009 04 16       		ld	X,@(0x0001,Y)
 1339 000a 00 00 00 99 		ld	AH,@(0x0002,X)
 1340 000c 00 00 00 00 		ld	X,@(0x0001,Y)
 1340      00 F0 
 870:octet_queue.c ****     {
 871:octet_queue.c ****         /* If the boundary index has rolled over */
 872:octet_queue.c ****         if (handle->start >= handle->boundary)
 1341                 	@(0x0003,X)
 1342 000f 01 1B       		cmp	AH,@$XAP_AL
 1343 0010 02 12       		bcs	.L74
 1344 0011 01 1B       		.loc 1 875 0
 1345 0012 03 16       		ld	AL,@(0x0001,Y)
 1346 0013 00 00 00 81 		bsr	OQCapacity
 1347 0015 00 00 00 00 		ld	AH,@$XAP_AL
 1347      00 FC 
 873:octet_queue.c ****         {
 874:octet_queue.c ****             data_size = OQCapacity(handle) - handle->start + handle->boundary;
 1348                 	(0x0001,Y)
 1349 0018 01 17       		ld	AL,@(0x0002,X)
 1350 0019 00 00 00 00 		sub	AH,@$XAP_AL
 1350      00 9C 
 1351 001c 00 00 00 11 		ld	X,@(0x0001,Y)
 1352 001e 01 1B       		ld	AL,@(0x0003,X)
 1353 001f 02 16       		ld	X,@$XAP_AH
 1354 0020 00 00 00 51 		add	X,@$XAP_AL
 1355 0022 01 1B       		st	X,@(0,Y)
 1356 0023 03 16       		bra	.L73
 1357 0024 00 00 00 19 	.L74:
 1358 0026 00 00 00 39 		.loc 1 879 0
 1359 0028 00 2B       		ld	X,@(0x0001,Y)
 1360 0029 00 00 00 00 		ld	AH,@(0x0003,X)
 1360      00 E0 
 1361                 		ld	X,@(0x0001,Y)
 875:octet_queue.c ****         }
 876:octet_queue.c ****         else
 877:octet_queue.c ****         {
 878:octet_queue.c ****             data_size = handle->boundary - handle->start;
 1362                 	2,X)
 1363 002c 01 1B       		ld	X,@$XAP_AH
 1364 002d 03 12       		sub	X,@$XAP_AL
 1365 002e 01 1B       		st	X,@(0,Y)
 1366 002f 02 16       	.L73:
 1367 0030 00 00 00 19 		.loc 1 883 0
 1368 0032 00 00 00 59 		ld	AL,@(0,Y)
 1369 0034 00 2B       		.loc 1 884 0
 1370                 		leave	#0x0003
 879:octet_queue.c ****         }
 880:octet_queue.c ****     }
 881:octet_queue.c ****     
 882:octet_queue.c ****     return data_size;
 1371                 	.size	OQSize, .-OQSize
 1372 0035 00 17       		.global	__size_of_OQSize
 883:octet_queue.c **** } /* OQSize */
 1373                 	equ	__size_of_OQSize,. - OQSize
 1374 0036 03 0F       		.section	.text.OQIsEmpty,"ax",@progbits
 1375                 		.global	OQIsEmpty
 1376                 		.type	OQIsEmpty, @function
 1377                 	OQIsEmpty:
 1378                 	.LFB11:
 1379                 		.loc 1 900 0
 1380                 		enter	#0x0003
 1381                 	.LCFI9:
 1382                 		st	AL,@(0,Y)
 1383                 		.loc 1 901 0
 884:octet_queue.c **** 
 885:octet_queue.c **** /*----------------------------------------------------------------------------*
 886:octet_queue.c ****  *  NAME
 887:octet_queue.c ****  *      OQIsEmpty
 888:octet_queue.c ****  *
 889:octet_queue.c ****  *  DESCRIPTION
 890:octet_queue.c ****  *      Check if the given queue is empty
 891:octet_queue.c ****  *
 892:octet_queue.c ****  *  PARAMETERS
 893:octet_queue.c ****  *      handle [in]             Handle to the octet queue
 894:octet_queue.c ****  *
 895:octet_queue.c ****  *  RETURNS
 896:octet_queue.c ****  *      TRUE if empty, FALSE otherwise
 897:octet_queue.c ****  *----------------------------------------------------------------------------*/
 898:octet_queue.c **** bool OQIsEmpty(const OQ_HANDLE handle)
 899:octet_queue.c **** {
 1384                 	
 1385 0000 03 0B       		beq	.L77
 1386                 		ld	X,@(0,Y)
 1387 0001 00 27       		ld	AL,@(0x0004,X)
 900:octet_queue.c ****     return ((handle != NULL) && handle->empty);
 1388                 	t	@$XAP_AL
 1389 0002 00 9B       		beq	.L77
 1390 0003 00 00 00 00 		ld	AL,#0x0001
 1390      00 F4 
 1391 0006 00 1B       		st	AL,@(0x0001,Y)
 1392 0007 04 16       		bra	.L78
 1393 0008 00 00 00 99 	.L77:
 1394 000a 00 00 00 00 		ld	AL,#0x0000
 1394      00 F4 
 1395 000d 01 14       		st	AL,@(0x0001,Y)
 1396 000e 01 27       	.L78:
 1397 000f 00 00 00 00 		ld	AL,@(0x0001,Y)
 1397      00 E0 
 1398                 		.loc 1 902 0
 1399 0012 00 14       		leave	#0x0003
 1400 0013 01 27       	.LFE11:
 1401                 		.size	OQIsEmpty, .-OQIsEmpty
 1402 0014 01 17       		.global	__size_of_OQIsEmpty
 901:octet_queue.c **** } /* OQIsEmpty */
 1403                 	_OQIsEmpty,. - OQIsEmpty
 1404 0015 03 0F       		.section	.text.OQIsFull,"ax",@progbits
 1405                 		.global	OQIsFull
 1406                 		.type	OQIsFull, @function
 1407                 	OQIsFull:
 1408                 	.LFB12:
 1409                 		.loc 1 918 0
 1410                 		enter	#0x0003
 1411                 	.LCFI10:
 1412                 		st	AL,@(0,Y)
 1413                 		.loc 1 920 0
 902:octet_queue.c **** 
 903:octet_queue.c **** /*----------------------------------------------------------------------------*
 904:octet_queue.c ****  *  NAME
 905:octet_queue.c ****  *      OQIsFull
 906:octet_queue.c ****  *
 907:octet_queue.c ****  *  DESCRIPTION
 908:octet_queue.c ****  *      Check if the given queue is full
 909:octet_queue.c ****  *
 910:octet_queue.c ****  *  PARAMETERS
 911:octet_queue.c ****  *      handle [in]             Handle to the octet queue
 912:octet_queue.c ****  *
 913:octet_queue.c ****  *  RETURNS
 914:octet_queue.c ****  *      TRUE if full, FALSE otherwise
 915:octet_queue.c ****  *----------------------------------------------------------------------------*/
 916:octet_queue.c **** bool OQIsFull(const OQ_HANDLE handle)
 917:octet_queue.c **** {
 1414                 	
 1415 0000 03 0B       		beq	.L81
 1416                 		ld	X,@(0,Y)
 1417 0001 00 27       		ld	AH,@(0x0002,X)
 918:octet_queue.c ****     /* if buffer rolled over to start and is not empty, it is full */
 919:octet_queue.c ****     return ((handle != NULL) &&
 1418                 		X,@(0,Y)
 1419 0002 00 9B       		ld	AL,@(0x0003,X)
 1420 0003 00 00 00 00 		cmp	AH,@$XAP_AL
 1420      00 F4 
 1421 0006 00 1B       		bne	.L81
 1422 0007 02 12       		ld	X,@(0,Y)
 1423 0008 00 1B       		ld	AL,@(0x0004,X)
 1424 0009 03 16       		tst	@$XAP_AL
 1425 000a 00 00 00 81 		bne	.L81
 1426 000c 00 00 00 00 		ld	AL,#0x0001
 1426      00 F0 
 1427 000f 00 1B       		st	AL,@(0x0001,Y)
 1428 0010 04 16       		bra	.L82
 1429 0011 00 00 00 99 	.L81:
 1430 0013 00 00 00 00 		ld	AL,#0x0000
 1430      00 F0 
 1431 0016 01 14       		st	AL,@(0x0001,Y)
 1432 0017 01 27       	.L82:
 1433 0018 00 00 00 00 		ld	AL,@(0x0001,Y)
 1433      00 E0 
 1434                 		.loc 1 923 0
 1435 001b 00 14       		leave	#0x0003
 1436 001c 01 27       	.LFE12:
 1437                 		.size	OQIsFull, .-OQIsFull
 1438 001d 01 17       		.global	__size_of_OQIsFull
 920:octet_queue.c ****             (handle->start == handle->boundary) &&
 921:octet_queue.c ****             !handle->empty);
 922:octet_queue.c **** } /* OQIsFull */
 1439                 	ull,. - OQIsFull
 1440 001e 03 0F       		.section	.text.OQCapacity,"ax",@progbits
 1441                 		.global	OQCapacity
 1442                 		.type	OQCapacity, @function
 1443                 	OQCapacity:
 1444                 	.LFB13:
 1445                 		.loc 1 939 0
 1446                 		enter	#0x0003
 1447                 	.LCFI11:
 1448                 		st	AL,@(0x0001,Y)
 1449                 		.loc 1 940 0
 923:octet_queue.c **** 
 924:octet_queue.c **** /*----------------------------------------------------------------------------*
 925:octet_queue.c ****  *  NAME
 926:octet_queue.c ****  *      OQCapacity
 927:octet_queue.c ****  *
 928:octet_queue.c ****  *  DESCRIPTION
 929:octet_queue.c ****  *      Get the total capacity of the octet queue
 930:octet_queue.c ****  *
 931:octet_queue.c ****  *  PARAMETERS
 932:octet_queue.c ****  *      handle [in]             Handle to the octet queue
 933:octet_queue.c ****  *
 934:octet_queue.c ****  *  RETURNS
 935:octet_queue.c ****  *      Total capacity of the queue in octets
 936:octet_queue.c ****  *----------------------------------------------------------------------------*/
 937:octet_queue.c **** uint16 OQCapacity(const OQ_HANDLE handle)
 938:octet_queue.c **** {
 1450                 	000
 1451 0000 03 0B       		st	AL,@(0,Y)
 1452                 		.loc 1 942 0
 1453 0001 01 27       		tst	@(0x0001,Y)
 939:octet_queue.c ****     uint16 octet_count = 0;     /* Number of octets the queue can hold */
 1454                 		.L85
 1455 0002 00 14       		.loc 1 945 0
 1456 0003 00 27       		ld	X,@(0x0001,Y)
 940:octet_queue.c **** 
 941:octet_queue.c ****     if (handle != NULL)
 1457                 		AL,@(0x0001,X)
 1458 0004 01 9B       		st	AL,@(0,Y)
 1459 0005 00 00 00 00 		.loc 1 948 0
 1459      00 F4 
 942:octet_queue.c ****     {
 943:octet_queue.c ****         /* Number of elements in the queue */
 944:octet_queue.c ****         octet_count = handle->capacity;
 1460                 		X,@(0x0001,Y)
 1461 0008 01 1B       		ld	AL,@(0x0005,X)
 1462 0009 01 16       		cmp	AL,#0x0001
 1463 000a 00 27       		bne	.L85
 945:octet_queue.c ****         
 946:octet_queue.c ****         /* For packed mode, we can store 2 octets in each element */
 947:octet_queue.c ****         if (handle->mode == OQDataMode_packed)
 1464                 	c 1 950 0
 1465 000b 01 1B       		ld	AL,@(0,Y)
 1466 000c 05 16       		add	AL,@$XAP_AL
 1467 000d 01 84       		st	AL,@(0,Y)
 1468 000e 00 00 00 00 	.L85:
 1468      00 F0 
 948:octet_queue.c ****         {
 949:octet_queue.c ****             octet_count *= 2;
 1469                 	 1 954 0
 1470 0011 00 17       		ld	AL,@(0,Y)
 1471 0012 00 00 00 35 		.loc 1 955 0
 1472 0014 00 27       		leave	#0x0003
 1473                 	.LFE13:
 950:octet_queue.c ****         }
 951:octet_queue.c ****     }
 952:octet_queue.c ****     
 953:octet_queue.c ****     return octet_count;
 1474                 	e	OQCapacity, .-OQCapacity
 1475 0015 00 17       		.global	__size_of_OQCapacity
 954:octet_queue.c **** } /* OQCapacity */
 1476                 	equ	__size_of_OQCapacity,. - OQCapacity
 1477 0016 03 0F       		.section	.text.OQSpace,"ax",@progbits
 1478                 		.global	OQSpace
 1479                 		.type	OQSpace, @function
 1480                 	OQSpace:
 1481                 	.LFB14:
 1482                 		.loc 1 971 0
 1483                 		enter	#0x0003
 1484                 	.LCFI12:
 1485                 		st	AL,@(0,Y)
 1486                 		.loc 1 972 0
 955:octet_queue.c **** 
 956:octet_queue.c **** /*----------------------------------------------------------------------------*
 957:octet_queue.c ****  *  NAME
 958:octet_queue.c ****  *      OQSpace
 959:octet_queue.c ****  *
 960:octet_queue.c ****  *  DESCRIPTION
 961:octet_queue.c ****  *      Available space in an octet queue
 962:octet_queue.c ****  *
 963:octet_queue.c ****  *  PARAMETERS
 964:octet_queue.c ****  *      handle [in]             Handle to the octet queue
 965:octet_queue.c ****  *
 966:octet_queue.c ****  *  RETURNS
 967:octet_queue.c ****  *      Space available in the queue in octets
 968:octet_queue.c ****  *----------------------------------------------------------------------------*/
 969:octet_queue.c **** uint16 OQSpace(const OQ_HANDLE handle)
 970:octet_queue.c **** {
 1487                 	Y)
 1488 0000 03 0B       		bsr	OQCapacity
 1489                 		st	AL,@(0x0001,Y)
 1490 0001 00 27       		ld	AL,@(0,Y)
 971:octet_queue.c ****     return OQCapacity(handle) - OQSize(handle);
 1491                 		OQSize
 1492 0002 00 17       		ld	X,@(0x0001,Y)
 1493 0003 00 00 00 00 		sub	X,@$XAP_AL
 1493      00 9C 
 1494 0006 01 27       		ld	AL,@$XAP_UXL
 1495 0007 00 17       		.loc 1 973 0
 1496 0008 00 00 00 00 		leave	#0x0003
 1496      00 9C 
 1497 000b 01 1B       	.LFE14:
 1498 000c 00 00 00 59 		.size	OQSpace, .-OQSpace
 1499 000e 00 00 00 15 		.global	__size_of_OQSpace
 972:octet_queue.c **** } /* OQSpace */
 1500                 	ize_of_OQSpace,. - OQSpace
 1501 0010 03 0F       		.section	.text.OQClear,"ax",@progbits
 1502                 		.global	OQClear
 1503                 		.type	OQClear, @function
 1504                 	OQClear:
 1505                 	.LFB15:
 1506                 		.loc 1 993 0
 1507                 		enter	#0x0002
 1508                 	.LCFI13:
 1509                 		st	AL,@(0,Y)
 1510                 		.loc 1 994 0
 973:octet_queue.c **** 
 974:octet_queue.c **** /*----------------------------------------------------------------------------*
 975:octet_queue.c ****  *  NAME
 976:octet_queue.c ****  *      OQClear
 977:octet_queue.c ****  *
 978:octet_queue.c ****  *  DESCRIPTION
 979:octet_queue.c ****  *      Clear the data in an octet queue. If buffer filling is enabled for
 980:octet_queue.c ****  *      this octet queue, it fills the empty areas of the buffer with the
 981:octet_queue.c ****  *      fill character configured using #OQSetFill. This actually removes
 982:octet_queue.c ****  *      the data by moving the buffer start index down to coincide with
 983:octet_queue.c ****  *      the buffer end index.
 984:octet_queue.c ****  *
 985:octet_queue.c ****  *  PARAMETERS
 986:octet_queue.c ****  *      handle [in]             Handle to the octet queue
 987:octet_queue.c ****  *
 988:octet_queue.c ****  *  RETURNS
 989:octet_queue.c ****  *      Nothing
 990:octet_queue.c ****  *----------------------------------------------------------------------------*/
 991:octet_queue.c **** void OQClear(OQ_HANDLE handle)
 992:octet_queue.c **** {
 1511                 	
 1512 0000 02 0B       		beq	.L91
 1513                 		ld	X,@(0,Y)
 1514 0001 00 27       		ld	AL,@(0x0004,X)
 993:octet_queue.c ****     if ((handle != NULL) && !handle->empty)
 1515                 	t	@$XAP_AL
 1516 0002 00 9B       		bne	.L91
 1517 0003 00 00 00 00 		.loc 1 997 0
 1517      00 F4 
 1518 0006 00 1B       		ld	X,@(0,Y)
 1519 0007 04 16       		ld	AL,@(0x0003,X)
 1520 0008 00 00 00 99 		ld	X,@(0,Y)
 1521 000a 00 00 00 00 		st	AL,@(0x0002,X)
 1521      00 F0 
 994:octet_queue.c ****     {
 995:octet_queue.c ****         /* Reset the start index of the buffer */
 996:octet_queue.c ****         handle->start = handle->boundary;
 1522                 	 1000 0
 1523 000d 00 1B       		ld	X,@(0,Y)
 1524 000e 03 16       		ld	AL,#0x0001
 1525 000f 00 1B       		st	AL,@(0x0004,X)
 1526 0010 02 26       	.L91:
 997:octet_queue.c ****         
 998:octet_queue.c ****         /* Indicate that the buffer is empty */
 999:octet_queue.c ****         handle->empty = TRUE;
 1527                 	 1 1011 0
 1528 0011 00 1B       		leave	#0x0002
 1529 0012 01 14       	.LFE15:
 1530 0013 04 26       		.size	OQClear, .-OQClear
 1531                 		.global	__size_of_OQClear
1000:octet_queue.c **** 
1001:octet_queue.c **** #ifdef OQ_ENABLE_BUFFER_FILL
1002:octet_queue.c ****         /* Check filling is enabled for this queue */
1003:octet_queue.c ****         if (handle->fill & 0xFF00)
1004:octet_queue.c ****         {
1005:octet_queue.c ****             /* Fill the buffer with fill octets */
1006:octet_queue.c ****             FILL_BUFFER(handle->p_buffer, handle->fill, handle->capacity);
1007:octet_queue.c ****         }
1008:octet_queue.c **** #endif
1009:octet_queue.c ****     }
1010:octet_queue.c **** } /* OQClear */
 1532                 		__size_of_OQClear,. - OQClear
 1533 0014 02 0F       		.section	.text.OQSetFill,"ax",@progbits
 1534                 		.global	OQSetFill
 1535                 		.type	OQSetFill, @function
 1536                 	OQSetFill:
 1537                 	.LFB16:
 1538                 		.loc 1 1040 0
 1539                 		enter	#0x0003
 1540                 	.LCFI14:
 1541                 		st	AL,@(0,Y)
 1542                 		st	AH,@(0x0001,Y)
1011:octet_queue.c **** 
1012:octet_queue.c **** /*----------------------------------------------------------------------------*
1013:octet_queue.c ****  *  NAME
1014:octet_queue.c ****  *      OQSetFill
1015:octet_queue.c ****  *
1016:octet_queue.c ****  *  DESCRIPTION
1017:octet_queue.c ****  *      Enable/Disable buffer filling and set the fill octet for a given octet
1018:octet_queue.c ****  *      queue. Buffer filling enables automatically setting empty areas of the
1019:octet_queue.c ****  *      queue to a specified fill octet.
1020:octet_queue.c ****  *
1021:octet_queue.c ****  *      The queue need not have been created yet. This function is typically
1022:octet_queue.c ****  *      called prior to OQCreate so that when the queue is created it is
1023:octet_queue.c ****  *      automatically filled with the fill octet.
1024:octet_queue.c ****  *
1025:octet_queue.c ****  *      If the buffer filling feature is disabled (by not defining macro
1026:octet_queue.c ****  *      OQ_ENABLE_BUFFER_FILL) calling this function has no effect.
1027:octet_queue.c ****  *
1028:octet_queue.c ****  *  PARAMETERS
1029:octet_queue.c ****  *      handle [in]             Handle to the octet queue
1030:octet_queue.c ****  *      enable [in]             Set to TRUE to enable buffer filling for this
1031:octet_queue.c ****  *                              octet queue, or FALSE to disable it
1032:octet_queue.c ****  *      fill_octet [in]         Octet to be used to fill the empty space in the
1033:octet_queue.c ****  *                              buffer. Only effective when the parameter
1034:octet_queue.c ****  *                              "enable" is set to TRUE.
1035:octet_queue.c ****  *  RETURNS
1036:octet_queue.c ****  *      Nothing
1037:octet_queue.c ****  *----------------------------------------------------------------------------*/
1038:octet_queue.c **** void OQSetFill(OQ_HANDLE handle, bool enable, uint8 fill_octet)
1039:octet_queue.c **** {
 1543                 	7 0
 1544 0000 03 0B       		leave	#0x0003
 1545                 	.LFE16:
 1546 0001 00 27       		.size	OQSetFill, .-OQSetFill
 1547 0002 01 23       		.global	__size_of_OQSetFill
1040:octet_queue.c **** #ifdef OQ_ENABLE_BUFFER_FILL
1041:octet_queue.c ****     if (handle != NULL)
1042:octet_queue.c ****     {
1043:octet_queue.c ****         handle->fill = (((uint16)enable) << 8) | (fill_octet & 0xFF);
1044:octet_queue.c ****     }
1045:octet_queue.c **** #endif
1046:octet_queue.c **** } /* OQSetFill */
 1548                 		__size_of_OQSetFill,. - OQSetFill
 1549 0003 03 0F       		.section	.text.OQRollbackClear,"ax",@progbits
 1550                 		.global	OQRollbackClear
 1551                 		.type	OQRollbackClear, @function
 1552                 	OQRollbackClear:
 1553                 	.LFB17:
 1554                 		.loc 1 1071 0
 1555                 		enter	#0x0002
 1556                 	.LCFI15:
 1557                 		st	AL,@(0,Y)
 1558                 		.loc 1 1072 0
1047:octet_queue.c **** 
1048:octet_queue.c **** /******************************************************************************
1049:octet_queue.c ****  * Interfaces useful for using the queue on a shared memory, for example
1050:octet_queue.c ****  * reading a shared memory area already being filled by external means.
1051:octet_queue.c ****  *****************************************************************************/
1052:octet_queue.c **** 
1053:octet_queue.c **** /*----------------------------------------------------------------------------*
1054:octet_queue.c ****  *  NAME
1055:octet_queue.c ****  *      OQRollbackClear
1056:octet_queue.c ****  *
1057:octet_queue.c ****  *  DESCRIPTION
1058:octet_queue.c ****  *      Same as OQClear, except that it removes the data by moving the buffer
1059:octet_queue.c ****  *      end index up to coincide with the buffer start index. Useful when
1060:octet_queue.c ****  *      the octet queue is used to access a shared buffer, when required to
1061:octet_queue.c ****  *      overwrite any existing data.
1062:octet_queue.c ****  *
1063:octet_queue.c ****  *  PARAMETERS
1064:octet_queue.c ****  *      handle [in]             Handle to the octet queue
1065:octet_queue.c ****  *
1066:octet_queue.c ****  *  RETURNS
1067:octet_queue.c ****  *      Nothing
1068:octet_queue.c ****  *----------------------------------------------------------------------------*/
1069:octet_queue.c **** void OQRollbackClear(OQ_HANDLE handle)
1070:octet_queue.c **** {
 1559                 	
 1560 0000 02 0B       		beq	.L96
 1561                 		ld	X,@(0,Y)
 1562 0001 00 27       		ld	AL,@(0x0004,X)
1071:octet_queue.c ****     if ((handle != NULL) && !handle->empty)
 1563                 	t	@$XAP_AL
 1564 0002 00 9B       		bne	.L96
 1565 0003 00 00 00 00 		.loc 1 1075 0
 1565      00 F4 
 1566 0006 00 1B       		ld	X,@(0,Y)
 1567 0007 04 16       		ld	AL,@(0x0002,X)
 1568 0008 00 00 00 99 		ld	X,@(0,Y)
 1569 000a 00 00 00 00 		st	AL,@(0x0003,X)
 1569      00 F0 
1072:octet_queue.c ****     {
1073:octet_queue.c ****         /* Reset the boundary index of the buffer */
1074:octet_queue.c ****         handle->boundary = handle->start;
 1570                 	 1078 0
 1571 000d 00 1B       		ld	X,@(0,Y)
 1572 000e 02 16       		ld	AL,#0x0001
 1573 000f 00 1B       		st	AL,@(0x0004,X)
 1574 0010 03 26       	.L96:
1075:octet_queue.c ****         
1076:octet_queue.c ****         /* Indicate that the buffer is empty */
1077:octet_queue.c ****         handle->empty = TRUE;
 1575                 	 1 1089 0
 1576 0011 00 1B       		leave	#0x0002
 1577 0012 01 14       	.LFE17:
 1578 0013 04 26       		.size	OQRollbackClear, .-OQRollbackClear
 1579                 		.global	__size_of_OQRollbackClear
1078:octet_queue.c ****         
1079:octet_queue.c **** #ifdef OQ_ENABLE_BUFFER_FILL
1080:octet_queue.c ****         /* Check filling is enabled for this queue */
1081:octet_queue.c ****         if (handle->fill & 0xFF00)
1082:octet_queue.c ****         {
1083:octet_queue.c ****             /* Fill the buffer with fill octets */
1084:octet_queue.c ****             FILL_BUFFER(handle->p_buffer, handle->fill, handle->capacity);
1085:octet_queue.c ****         }
1086:octet_queue.c **** #endif
1087:octet_queue.c ****     }
1088:octet_queue.c **** } /* OQRollbackClear */
 1580                 		__size_of_OQRollbackClear,. - OQRollbackClear
 1581 0014 02 0F       		.section	.text.OQSetSize,"ax",@progbits
 1582                 		.global	OQSetSize
 1583                 		.type	OQSetSize, @function
 1584                 	OQSetSize:
 1585                 	.LFB18:
 1586                 		.loc 1 1115 0
 1587                 		enter	#0x0005
 1588                 	.LCFI16:
 1589                 		st	AL,@(0x0002,Y)
 1590                 		st	AH,@(0x0003,Y)
1089:octet_queue.c **** 
1090:octet_queue.c **** /*----------------------------------------------------------------------------*
1091:octet_queue.c ****  *  NAME
1092:octet_queue.c ****  *      OQSetSize
1093:octet_queue.c ****  *
1094:octet_queue.c ****  *  DESCRIPTION
1095:octet_queue.c ****  *      Adjust the buffer indexes as per the octet_count supplied. The buffer
1096:octet_queue.c ****  *      size can be increased or decreased, there by affecting the boundary or
1097:octet_queue.c ****  *      start index respectively. Useful when octet queue is used to access
1098:octet_queue.c ****  *      a shared buffer, to account for data added/extracted externally.
1099:octet_queue.c ****  *
1100:octet_queue.c ****  *  PARAMETERS
1101:octet_queue.c ****  *      handle [in]             Handle to the octet queue
1102:octet_queue.c ****  *      octet_count [in]        New queue size, in octets
1103:octet_queue.c ****  *
1104:octet_queue.c ****  *  RETURNS
1105:octet_queue.c ****  *      TRUE:  Success. The queue size is set to the specified value. Any
1106:octet_queue.c ****  *             surplus data is removed (if the fill character is set, removed
1107:octet_queue.c ****  *             data is replaced by that character). If the queue size has
1108:octet_queue.c ****  *             increased the end index is simply increased to account for the
1109:octet_queue.c ****  *             new size.
1110:octet_queue.c ****  *
1111:octet_queue.c ****  *      FALSE: Failed.
1112:octet_queue.c ****  *----------------------------------------------------------------------------*/
1113:octet_queue.c **** bool OQSetSize(OQ_HANDLE handle, uint16 octet_count)
1114:octet_queue.c **** {
 1591                 	7 0
 1592 0000 05 0B       		ld	AL,#0x0000
 1593                 		st	AL,@(0x0001,Y)
 1594 0001 02 27       		.loc 1 1121 0
 1595 0002 03 23       		ld	AL,@(0x0002,Y)
1115:octet_queue.c ****     /* Function status */
1116:octet_queue.c ****     bool ret_val = FALSE;
 1596                 	OQCapacity
 1597 0003 00 14       		cmp	AL,@(0x0003,Y)
 1598 0004 01 27       		bcs	.L98
1117:octet_queue.c ****     
1118:octet_queue.c ****     /* Check the new size does not exceed the maximum queue capacity */
1119:octet_queue.c ****     /* (OQCapacity returns 0 if the queue is invalid) */
1120:octet_queue.c ****     if (octet_count <= OQCapacity(handle))
 1599                 	B13:
 1600 0005 02 17       		.loc 1 1123 0
 1601 0006 00 00 00 00 		ld	AL,@(0x0002,Y)
 1601      00 9C 
 1602 0009 03 87       		bsr	OQSize
 1603 000a 00 00 00 00 		st	AL,@(0,Y)
 1603      00 FC 
 1604                 		.loc 1 1125 0
1121:octet_queue.c ****     {
1122:octet_queue.c ****         const uint16 current_size = OQSize(handle);
 1605                 	,@(0,Y)
 1606 000d 02 17       		cmp	AL,@(0x0003,Y)
 1607 000e 00 00 00 00 		bcz	.L99
 1607      00 9C 
 1608 0011 00 27       		.loc 1 1127 0
1123:octet_queue.c ****         
1124:octet_queue.c ****         if (current_size > octet_count)
 1609                 	AH,@(0,Y)
 1610 0012 00 17       		sub	AH,@(0x0003,Y)
 1611 0013 03 87       		ld	AL,@(0x0002,Y)
 1612 0014 00 00 00 00 		bsr	OQDecrementSize
 1612      00 2C 
1125:octet_queue.c ****         {
1126:octet_queue.c ****             OQDecrementSize(handle, current_size - octet_count);
 1613                 		.L100
 1614 0017 00 13       	.L99:
 1615 0018 03 53       		.loc 1 1129 0
 1616 0019 02 17       		ld	AL,@(0,Y)
 1617 001a 00 00 00 00 		cmp	AL,@(0x0003,Y)
 1617      00 9C 
 1618 001d 00 00 00 00 		bcc	.L100
 1618      00 E0 
 1619                 		.loc 1 1131 0
1127:octet_queue.c ****         }
1128:octet_queue.c ****         else if (current_size < octet_count)
 1620                 	@(0x0003,Y)
 1621 0020 00 17       		sub	AH,@(0,Y)
 1622 0021 03 87       		ld	AL,@(0x0002,Y)
 1623 0022 00 00 00 00 		bsr	OQIncrementSize
 1623      00 F8 
1129:octet_queue.c ****         {
1130:octet_queue.c ****             OQIncrementSize(handle, octet_count - current_size);
 1624                 	0:
 1625 0025 03 13       		.loc 1 1134 0
 1626 0026 00 53       		ld	AL,#0x0001
 1627 0027 02 17       		st	AL,@(0x0001,Y)
 1628 0028 00 00 00 00 	.L98:
 1628      00 9C 
 1629                 	.LBE13:
1131:octet_queue.c ****         }
1132:octet_queue.c ****         
1133:octet_queue.c ****         ret_val = TRUE;
 1630                 	1 1137 0
 1631 002b 01 14       		ld	AL,@(0x0001,Y)
 1632 002c 01 27       		.loc 1 1138 0
 1633                 		leave	#0x0005
 1634                 	.LFE18:
1134:octet_queue.c ****     }
1135:octet_queue.c **** 
1136:octet_queue.c ****     return ret_val;
 1635                 	e	OQSetSize, .-OQSetSize
 1636 002d 01 17       		.global	__size_of_OQSetSize
1137:octet_queue.c **** } /* OQSetSize */
 1637                 	equ	__size_of_OQSetSize,. - OQSetSize
 1638 002e 05 0F       		.section	.text.OQIncrementSize,"ax",@progbits
 1639                 		.global	OQIncrementSize
 1640                 		.type	OQIncrementSize, @function
 1641                 	OQIncrementSize:
 1642                 	.LFB19:
 1643                 		.loc 1 1157 0
 1644                 		enter	#0x0005
 1645                 	.LCFI17:
 1646                 		st	AL,@(0x0002,Y)
 1647                 		st	AH,@(0x0003,Y)
1138:octet_queue.c **** 
1139:octet_queue.c **** /*----------------------------------------------------------------------------*
1140:octet_queue.c ****  *  NAME
1141:octet_queue.c ****  *      OQIncrementSize
1142:octet_queue.c ****  *
1143:octet_queue.c ****  *  DESCRIPTION
1144:octet_queue.c ****  *      Adjust the buffer end index to add a given number of octets, without
1145:octet_queue.c ****  *      actually adding those octets. Useful when the octet queue is used
1146:octet_queue.c ****  *      to access a shared buffer, to adjust for the data added externally
1147:octet_queue.c ****  *
1148:octet_queue.c ****  *  PARAMETERS
1149:octet_queue.c ****  *      handle [in]             Handle to the octet queue
1150:octet_queue.c ****  *      octet_count [in]        Number of octets to add
1151:octet_queue.c ****  *
1152:octet_queue.c ****  *  RETURNS
1153:octet_queue.c ****  *      Number of octets actually added to the queue
1154:octet_queue.c ****  *----------------------------------------------------------------------------*/
1155:octet_queue.c **** uint16 OQIncrementSize(OQ_HANDLE handle, uint16 octet_count)
1156:octet_queue.c **** {
 1648                 	9 0
 1649 0000 05 0B       		ld	AL,@(0x0002,Y)
 1650                 		bsr	OQSpace
 1651 0001 02 27       		st	AL,@(0x0001,Y)
 1652 0002 03 23       		.loc 1 1162 0
1157:octet_queue.c ****     /* Available space in the queue in octets, 0 if the queue is invalid */
1158:octet_queue.c ****     const uint16 space = OQSpace(handle);
 1653                 	L,@(0x0003,Y)
 1654 0003 02 17       		cmp	AL,@(0x0001,Y)
 1655 0004 00 00 00 00 		bcz	.L103
 1655      00 9C 
 1656 0007 01 27       		.loc 1 1163 0
1159:octet_queue.c ****     
1160:octet_queue.c ****     /* Check there's enough space left in the queue */
1161:octet_queue.c ****     if (octet_count > space)
 1657                 	AL,@(0x0001,Y)
 1658 0008 03 17       		st	AL,@(0x0003,Y)
 1659 0009 01 87       	.L103:
 1660 000a 00 00 00 00 		.loc 1 1165 0
 1660      00 2C 
1162:octet_queue.c ****         octet_count = space;
 1661                 		@(0x0003,Y)
 1662 000d 01 17       		beq	.L104
 1663 000e 03 27       	.LBB14:
 1664                 		.loc 1 1168 0
1163:octet_queue.c ****     
1164:octet_queue.c ****     if (octet_count > 0)
 1665                 	AL,@(0x0002,Y)
 1666 000f 03 9B       		bsr	OQCapacity
 1667 0010 00 00 00 00 		ld	AH,@$XAP_AL
 1667      00 F4 
 1668                 		ld	X,@(0x0002,Y)
1165:octet_queue.c ****     {
1166:octet_queue.c ****         /* Amount of space left before the buffer wraps round */
1167:octet_queue.c ****         const uint16 remaining = OQCapacity(handle) - handle->boundary;
 1669                 	AL,@(0x0003,X)
 1670 0013 02 17       		ld	X,@$XAP_AH
 1671 0014 00 00 00 00 		sub	X,@$XAP_AL
 1671      00 9C 
 1672 0017 00 00 00 11 		st	X,@(0,Y)
 1673 0019 02 1B       		.loc 1 1171 0
 1674 001a 03 16       		ld	AL,@(0x0003,Y)
 1675 001b 00 00 00 19 		cmp	AL,@(0,Y)
 1676 001d 00 00 00 59 		bcs	.L105
 1677 001f 00 2B       		.loc 1 1172 0
1168:octet_queue.c ****         
1169:octet_queue.c ****         /* Advance the boundary to account for the octets added */
1170:octet_queue.c ****         if (octet_count >= remaining)
 1678                 	0x0003,Y)
 1679 0020 03 17       		sub	AL,@(0,Y)
 1680 0021 00 87       		ld	X,@(0x0002,Y)
 1681 0022 00 00 00 00 		st	AL,@(0x0003,X)
 1681      00 FC 
1171:octet_queue.c ****             handle->boundary = octet_count - remaining;
 1682                 		.L106
 1683 0025 03 17       	.L105:
 1684 0026 00 57       		.loc 1 1174 0
 1685 0027 02 1B       		ld	X,@(0x0002,Y)
 1686 0028 03 26       		ld	AL,@(0x0003,X)
 1687 0029 00 00 00 00 		add	AL,@(0x0003,Y)
 1687      00 E0 
 1688                 		ld	X,@(0x0002,Y)
1172:octet_queue.c ****         else
1173:octet_queue.c ****             handle->boundary += octet_count;
 1689                 	@(0x0003,X)
 1690 002c 02 1B       	.L106:
 1691 002d 03 16       		.loc 1 1177 0
 1692 002e 03 37       		ld	X,@(0x0002,Y)
 1693 002f 02 1B       		ld	AL,#0x0000
 1694 0030 03 26       		st	AL,@(0x0004,X)
 1695                 	.L104:
1174:octet_queue.c ****         
1175:octet_queue.c ****         /* Buffer isn't empty as we have just moved the boundary */
1176:octet_queue.c ****         handle->empty = FALSE;
 1696                 	
 1697 0031 02 1B       		.loc 1 1180 0
 1698 0032 00 14       		ld	AL,@(0x0003,Y)
 1699 0033 04 26       		.loc 1 1181 0
 1700                 		leave	#0x0005
 1701                 	.LFE19:
1177:octet_queue.c ****     }
1178:octet_queue.c **** 
1179:octet_queue.c ****     return octet_count;
 1702                 	e	OQIncrementSize, .-OQIncrementSize
 1703 0034 03 17       		.global	__size_of_OQIncrementSize
1180:octet_queue.c **** } /* OQIncrementSize */
 1704                 	equ	__size_of_OQIncrementSize,. - OQIncrementSize
 1705 0035 05 0F       		.section	.text.OQDecrementSize,"ax",@progbits
 1706                 		.global	OQDecrementSize
 1707                 		.type	OQDecrementSize, @function
 1708                 	OQDecrementSize:
 1709                 	.LFB20:
 1710                 		.loc 1 1202 0
 1711                 		enter	#0x0009
 1712                 	.LCFI18:
 1713                 		st	AL,@(0x0003,Y)
 1714                 		st	AH,@(0x0004,Y)
1181:octet_queue.c **** 
1182:octet_queue.c **** /*----------------------------------------------------------------------------*
1183:octet_queue.c ****  *  NAME
1184:octet_queue.c ****  *      OQDecrementSize
1185:octet_queue.c ****  *
1186:octet_queue.c ****  *  DESCRIPTION
1187:octet_queue.c ****  *      Adjust the buffer start index to remove a given number of octets,
1188:octet_queue.c ****  *      without actually extracting those octets. If buffer filling is
1189:octet_queue.c ****  *      enabled, this also fills the emptied area with the chosen fill
1190:octet_queue.c ****  *      character. Useful when the octet queue is used to access
1191:octet_queue.c ****  *      a shared buffer, to adjust for the data extracted externally.
1192:octet_queue.c ****  *
1193:octet_queue.c ****  *  PARAMETERS
1194:octet_queue.c ****  *      handle [in]             Handle to the octet queue
1195:octet_queue.c ****  *      octet_count [in]        The number of octets to remove
1196:octet_queue.c ****  *
1197:octet_queue.c ****  *  RETURNS
1198:octet_queue.c ****  *      Number of octets actually removed from the queue
1199:octet_queue.c ****  *----------------------------------------------------------------------------*/
1200:octet_queue.c **** uint16 OQDecrementSize(OQ_HANDLE handle, uint16 octet_count)
1201:octet_queue.c **** {
 1715                 	5 0
 1716 0000 09 0B       		ld	AL,@(0x0003,Y)
 1717                 		bsr	OQSize
 1718 0001 03 27       		st	AL,@(0x0002,Y)
 1719 0002 04 23       		.loc 1 1208 0
1202:octet_queue.c ****     /* Total available data in the queue, in octets */
1203:octet_queue.c ****     /* (This will be 0 if handle is invalid) */
1204:octet_queue.c ****     const uint16 avlbl_data = OQSize(handle);
 1720                 	L,@(0x0002,Y)
 1721 0003 03 17       		st	AL,@(0x0007,Y)
 1722 0004 00 00 00 00 		ld	X,@(0x0004,Y)
 1722      00 9C 
 1723 0007 02 27       		st	X,@(0x0006,Y)
1205:octet_queue.c ****     
1206:octet_queue.c ****     /* Number of octets of data that are to be removed */
1207:octet_queue.c ****     const uint16 octets_removed = MIN(avlbl_data, octet_count);
 1724                 	AL,@(0x0006,Y)
 1725 0008 02 17       		cmp	AL,@(0x0007,Y)
 1726 0009 07 27       		bcz	.L109
 1727 000a 04 1B       		ld	X,@(0x0007,Y)
 1728 000b 06 2B       		st	X,@(0x0006,Y)
 1729 000c 06 17       	.L109:
 1730 000d 07 87       		ld	AL,@(0x0006,Y)
 1731 000e 00 00 00 00 		st	AL,@(0x0001,Y)
 1731      00 2C 
 1732 0011 07 1B       		.loc 1 1214 0
 1733 0012 06 2B       		tst	@(0x0001,Y)
 1734                 		bne	.L110
 1735 0013 06 17       		.loc 1 1215 0
 1736 0014 01 27       		ld	X,#0x0000
1208:octet_queue.c ****     
1209:octet_queue.c ****     /* Number of octets between queue head and end of buffer */
1210:octet_queue.c ****     uint16 wrap_size;
1211:octet_queue.c **** 
1212:octet_queue.c ****     /* If there is no data to be removed return now */
1213:octet_queue.c ****     if (octets_removed == 0)
 1737                 	5,Y)
 1738 0015 01 9B       		bra	.L111
 1739 0016 00 00 00 00 	.L110:
 1739      00 F0 
1214:octet_queue.c ****         return 0;
 1740                 	oc 1 1218 0
 1741 0019 00 18       		ld	AL,@(0x0003,Y)
 1742 001a 05 2B       		bsr	OQCapacity
 1743 001b 00 00 00 00 		ld	AH,@$XAP_AL
 1743      00 E0 
 1744                 		ld	X,@(0x0003,Y)
1215:octet_queue.c **** 
1216:octet_queue.c ****     /* Safe to initialise wrap_size now */
1217:octet_queue.c ****     wrap_size = OQCapacity(handle) - handle->start;
 1745                 	L,@(0x0002,X)
 1746 001e 03 17       		ld	X,@$XAP_AH
 1747 001f 00 00 00 00 		sub	X,@$XAP_AL
 1747      00 9C 
 1748 0022 00 00 00 11 		st	X,@(0,Y)
 1749 0024 03 1B       		.loc 1 1310 0
 1750 0025 02 16       		ld	AL,@(0x0001,Y)
 1751 0026 00 00 00 19 		cmp	AL,@(0,Y)
 1752 0028 00 00 00 59 		bcs	.L112
 1753 002a 00 2B       		.loc 1 1311 0
1218:octet_queue.c **** 
1219:octet_queue.c **** #ifdef OQ_ENABLE_BUFFER_FILL
1220:octet_queue.c ****     /* If buffer filling has not been disabled */
1221:octet_queue.c **** 
1222:octet_queue.c ****     /* Check whether buffer filling is enabled for this queue */
1223:octet_queue.c ****     if (handle->fill & 0xff00)
1224:octet_queue.c ****     {
1225:octet_queue.c ****         /* Fill octet */
1226:octet_queue.c ****         const uint16 fill = handle->fill & 0x00ff;
1227:octet_queue.c ****         
1228:octet_queue.c ****         /* Number of octets remaining to be filled */
1229:octet_queue.c ****         uint16 octets_to_be_filled = octets_removed;
1230:octet_queue.c ****     
1231:octet_queue.c ****         /* Check whether the queue is packed or unpacked */
1232:octet_queue.c ****         if (handle->mode == OQDataMode_packed)
1233:octet_queue.c ****         {
1234:octet_queue.c ****             /* Pointer into queue buffer */
1235:octet_queue.c ****             uint16 *ptr = (uint16 *)handle->p_buffer + handle->start/2;
1236:octet_queue.c **** 
1237:octet_queue.c ****             /* How many octets remain before the queue wraps round */
1238:octet_queue.c ****             uint16 remaining = wrap_size;
1239:octet_queue.c **** 
1240:octet_queue.c ****             /* If the first byte is from the MSB, fill that byte */
1241:octet_queue.c ****             if (handle->start & 0x1)
1242:octet_queue.c ****             {
1243:octet_queue.c ****                 /* Insert the fill octet into the MSB */
1244:octet_queue.c ****                 *ptr = (*ptr & 0x00ff) | (fill << 8);
1245:octet_queue.c ****             
1246:octet_queue.c ****                 /* Advance the buffer pointer */
1247:octet_queue.c ****                 ptr++;
1248:octet_queue.c ****             
1249:octet_queue.c ****                 /* Decrement number of octets remaining before queue wraps */
1250:octet_queue.c ****                 remaining--;
1251:octet_queue.c ****             
1252:octet_queue.c ****                 /* Decrement number of octets to be filled */
1253:octet_queue.c ****                 octets_to_be_filled--;
1254:octet_queue.c ****             }
1255:octet_queue.c **** 
1256:octet_queue.c ****             /* Check whether the queue will wrap round */
1257:octet_queue.c ****             if (octets_to_be_filled >= remaining)
1258:octet_queue.c ****             {
1259:octet_queue.c ****                 /* Set the remaining octets in the buffer */
1260:octet_queue.c ****                 FILL_BUFFER(ptr, fill, remaining/2);
1261:octet_queue.c ****                 
1262:octet_queue.c ****                 /* Decrement the number of octets waiting to be filled */
1263:octet_queue.c ****                 octets_to_be_filled -= remaining;
1264:octet_queue.c **** 
1265:octet_queue.c ****                 /* Reset the buffer pointer */
1266:octet_queue.c ****                 ptr = handle->p_buffer;
1267:octet_queue.c ****             }
1268:octet_queue.c **** 
1269:octet_queue.c ****             /* Fill the buffer with the fill octet */
1270:octet_queue.c ****             FILL_BUFFER(ptr, fill, octets_to_be_filled/2);
1271:octet_queue.c **** 
1272:octet_queue.c ****             /* If there is an odd octet remaining to be filled */
1273:octet_queue.c ****             if (octets_to_be_filled & 0x1)
1274:octet_queue.c ****             {
1275:octet_queue.c ****                 /* Advance buffer pointer */
1276:octet_queue.c ****                 ptr += octets_to_be_filled/2;
1277:octet_queue.c ****             
1278:octet_queue.c ****                 /* Fill the octet in the LSB leaving the MSB unaltered */
1279:octet_queue.c ****                 *ptr = (*ptr & 0xff00) | fill;
1280:octet_queue.c ****             }
1281:octet_queue.c ****         }
1282:octet_queue.c ****         else /* handle->mode == OQDataMode_unpacked */
1283:octet_queue.c ****         {
1284:octet_queue.c ****             /* Octet queue is unpacked */
1285:octet_queue.c **** 
1286:octet_queue.c ****             /* Pointer into queue buffer */
1287:octet_queue.c ****             uint8 *ptr = (uint8 *)handle->p_buffer + handle->start;
1288:octet_queue.c ****             
1289:octet_queue.c ****             /* Check whether the queue will wrap round */
1290:octet_queue.c ****             if (octets_to_be_filled >= wrap_size)
1291:octet_queue.c ****             {
1292:octet_queue.c ****                 /* Fill the rest of the buffer */
1293:octet_queue.c ****                 FILL_BUFFER(ptr, fill, wrap_size);
1294:octet_queue.c **** 
1295:octet_queue.c ****                 /* Decrement the number of octets waiting to be filled */
1296:octet_queue.c ****                 octets_to_be_filled -= wrap_size;
1297:octet_queue.c ****                   
1298:octet_queue.c ****                 /* Reset the buffer pointer */
1299:octet_queue.c ****                 ptr = handle->p_buffer;
1300:octet_queue.c ****             }
1301:octet_queue.c **** 
1302:octet_queue.c ****             /* Fill the queue buffer */
1303:octet_queue.c ****             FILL_BUFFER(ptr, fill, octets_to_be_filled);
1304:octet_queue.c ****         }
1305:octet_queue.c ****     }
1306:octet_queue.c **** #endif /* OQ_ENABLE_BUFFER_FILL */
1307:octet_queue.c **** 
1308:octet_queue.c ****     /* Advance queue start index, wrapping when end of buffer is reached */
1309:octet_queue.c ****     if (octets_removed >= wrap_size)
 1754                 	0x0001,Y)
 1755 002b 01 17       		sub	AL,@(0,Y)
 1756 002c 00 87       		ld	X,@(0x0003,Y)
 1757 002d 00 00 00 00 		st	AL,@(0x0002,X)
 1757      00 FC 
1310:octet_queue.c ****         handle->start = octets_removed - wrap_size;
 1758                 		.L113
 1759 0030 01 17       	.L112:
 1760 0031 00 57       		.loc 1 1313 0
 1761 0032 03 1B       		ld	X,@(0x0003,Y)
 1762 0033 02 26       		ld	AL,@(0x0002,X)
 1763 0034 00 00 00 00 		add	AL,@(0x0001,Y)
 1763      00 E0 
 1764                 		ld	X,@(0x0003,Y)
1311:octet_queue.c ****     else
1312:octet_queue.c ****         handle->start += octets_removed;
 1765                 	@(0x0002,X)
 1766 0037 03 1B       	.L113:
 1767 0038 02 16       		.loc 1 1316 0
 1768 0039 01 37       		ld	X,@(0x0003,Y)
 1769 003a 03 1B       		ld	AH,@(0x0002,X)
 1770 003b 02 26       		ld	X,@(0x0003,Y)
 1771                 		ld	AL,@(0x0003,X)
1313:octet_queue.c **** 
1314:octet_queue.c ****     /* Indicate whether the queue is empty */
1315:octet_queue.c ****     if (handle->start == handle->boundary)
 1772                 	,@$XAP_AL
 1773 003c 03 1B       		bne	.L114
 1774 003d 02 12       		.loc 1 1317 0
 1775 003e 03 1B       		ld	X,@(0x0003,Y)
 1776 003f 03 16       		ld	AL,#0x0001
 1777 0040 00 00 00 81 		st	AL,@(0x0004,X)
 1778 0042 00 00 00 00 	.L114:
 1778      00 F0 
1316:octet_queue.c ****         handle->empty = TRUE;
 1779                 	 1320 0
 1780 0045 03 1B       		ld	AL,@(0x0001,Y)
 1781 0046 01 14       		st	AL,@(0x0005,Y)
 1782 0047 04 26       	.L111:
 1783                 		ld	AL,@(0x0005,Y)
1317:octet_queue.c ****     
1318:octet_queue.c ****     /* Return the number of octets the queue size has been decremented by */
1319:octet_queue.c ****     return octets_removed;
 1784                 	 1 1321 0
 1785 0048 01 17       		leave	#0x0009
 1786 0049 05 27       	.LFE20:
 1787                 		.size	OQDecrementSize, .-OQDecrementSize
 1788 004a 05 17       		.global	__size_of_OQDecrementSize
1320:octet_queue.c **** } /* OQDecrementSize */
 1789                 		__size_of_OQDecrementSize,. - OQDecrementSize
 1790 004b 09 0F       		.section	.text.OQGetStartOffset,"ax",@progbits
 1791                 		.global	OQGetStartOffset
 1792                 		.type	OQGetStartOffset, @function
 1793                 	OQGetStartOffset:
 1794                 	.LFB21:
 1795                 		.loc 1 1338 0
 1796                 		enter	#0x0003
 1797                 	.LCFI19:
 1798                 		st	AL,@(0,Y)
 1799                 		.loc 1 1339 0
1321:octet_queue.c **** 
1322:octet_queue.c **** /*----------------------------------------------------------------------------*
1323:octet_queue.c ****  *  NAME
1324:octet_queue.c ****  *      OQGetStartOffset
1325:octet_queue.c ****  *
1326:octet_queue.c ****  *  DESCRIPTION
1327:octet_queue.c ****  *      Get the offset to the head of the queue in octets.
1328:octet_queue.c ****  *
1329:octet_queue.c ****  *  PARAMETERS
1330:octet_queue.c ****  *      handle [in]             Handle to the octet queue
1331:octet_queue.c ****  *
1332:octet_queue.c ****  *  RETURNS
1333:octet_queue.c ****  *      Index of the first octet in the buffer. For an empty queue this is
1334:octet_queue.c ****  *      the index where the first octet will be queued.
1335:octet_queue.c ****  *----------------------------------------------------------------------------*/
1336:octet_queue.c **** uint16 OQGetStartOffset(const OQ_HANDLE handle)
1337:octet_queue.c **** {
 1800                 	
 1801 0000 03 0B       		beq	.L117
 1802                 		ld	X,@(0,Y)
 1803 0001 00 27       		ld	X,@(0x0002,X)
1338:octet_queue.c ****     return (handle != NULL) ? handle->start : 0;
 1804                 		X,@(0x0001,Y)
 1805 0002 00 9B       		bra	.L118
 1806 0003 00 00 00 00 	.L117:
 1806      00 F4 
 1807 0006 00 1B       		ld	AL,#0x0000
 1808 0007 02 1A       		st	AL,@(0x0001,Y)
 1809 0008 01 2B       	.L118:
 1810 0009 00 00 00 00 		ld	AL,@(0x0001,Y)
 1810      00 E0 
 1811                 		.loc 1 1340 0
 1812 000c 00 14       		leave	#0x0003
 1813 000d 01 27       	.LFE21:
 1814                 		.size	OQGetStartOffset, .-OQGetStartOffset
 1815 000e 01 17       		.global	__size_of_OQGetStartOffset
1339:octet_queue.c **** } /* OQGetStartOffset */
 1816                 	_of_OQGetStartOffset,. - OQGetStartOffset
 1817 000f 03 0F       		.section	.text.OQGetEndOffset,"ax",@progbits
 1818                 		.global	OQGetEndOffset
 1819                 		.type	OQGetEndOffset, @function
 1820                 	OQGetEndOffset:
 1821                 	.LFB22:
 1822                 		.loc 1 1357 0
 1823                 		enter	#0x0003
 1824                 	.LCFI20:
 1825                 		st	AL,@(0x0001,Y)
 1826                 		.loc 1 1359 0
1340:octet_queue.c **** 
1341:octet_queue.c **** /*----------------------------------------------------------------------------*
1342:octet_queue.c ****  *  NAME
1343:octet_queue.c ****  *      OQGetEndOffset
1344:octet_queue.c ****  *
1345:octet_queue.c ****  *  DESCRIPTION
1346:octet_queue.c ****  *      Get the offset of the tail of the queue in octets.
1347:octet_queue.c ****  *
1348:octet_queue.c ****  *  PARAMETERS
1349:octet_queue.c ****  *      handle [in]             Handle to the octet queue
1350:octet_queue.c ****  *
1351:octet_queue.c ****  *  RETURNS
1352:octet_queue.c ****  *      Index of the last octet in the buffer. For an empty queue this is
1353:octet_queue.c ****  *      invalid and does not point to any valid data
1354:octet_queue.c ****  *----------------------------------------------------------------------------*/
1355:octet_queue.c **** uint16 OQGetEndOffset(const OQ_HANDLE handle)
1356:octet_queue.c **** {
 1827                 	000
 1828 0000 03 0B       		st	AL,@(0,Y)
 1829                 		.loc 1 1362 0
 1830 0001 01 27       		tst	@(0x0001,Y)
1357:octet_queue.c ****     /* Index of last octet in the queue */
1358:octet_queue.c ****     uint16 end_offset = 0;
 1831                 		.L121
 1832 0002 00 14       		.loc 1 1365 0
 1833 0003 00 27       		ld	X,@(0x0001,Y)
1359:octet_queue.c ****     
1360:octet_queue.c ****     /* Check the queue is valid */
1361:octet_queue.c ****     if (handle != NULL)
 1834                 		AL,@(0x0003,X)
 1835 0004 01 9B       		st	AL,@(0,Y)
 1836 0005 00 00 00 00 		.loc 1 1370 0
 1836      00 F4 
1362:octet_queue.c ****     {
1363:octet_queue.c ****         /* Extract the offset to the end of the queue */
1364:octet_queue.c ****         end_offset = handle->boundary;
 1837                 	t	@(0,Y)
 1838 0008 01 1B       		beq	.L122
 1839 0009 03 16       		.loc 1 1373 0
 1840 000a 00 27       		ld	AL,@(0,Y)
1365:octet_queue.c ****         
1366:octet_queue.c ****         /* The boundary index actually points to the next octet to be filled at
1367:octet_queue.c ****          * the end of the queue. Decrement the index by one to find the most
1368:octet_queue.c ****          * recently queued item */
1369:octet_queue.c ****         if (end_offset > 0)
 1841                 	X,@$XAP_AL
 1842 000b 00 9B       		add	X,#0xffff
 1843 000c 00 00 00 00 		st	X,@(0,Y)
 1843      00 F4 
1370:octet_queue.c ****         {
1371:octet_queue.c ****             /* If the index is not at 0 it can simply be decremented */
1372:octet_queue.c ****             end_offset--;
 1844                 	a	.L121
 1845 000f 00 17       	.L122:
 1846 0010 00 00 00 19 		.loc 1 1378 0
 1847 0012 FF 38       		ld	AL,@(0x0001,Y)
 1848 0013 00 2B       		bsr	OQCapacity
 1849 0014 00 00 00 00 		ld	X,@$XAP_AL
 1849      00 E0 
 1850                 		add	X,#0xffff
1373:octet_queue.c ****         }
1374:octet_queue.c ****         else
1375:octet_queue.c ****         {
1376:octet_queue.c ****             /* Otherwise it needs to wrap round to the maximum index */
1377:octet_queue.c ****             end_offset = OQCapacity(handle) - 1;
 1851                 	(0,Y)
 1852 0017 01 17       	.L121:
 1853 0018 00 00 00 00 		.loc 1 1382 0
 1853      00 9C 
 1854 001b 00 00 00 19 		ld	AL,@(0,Y)
 1855 001d FF 38       		.loc 1 1383 0
 1856 001e 00 2B       		leave	#0x0003
 1857                 	.LFE22:
1378:octet_queue.c ****         }
1379:octet_queue.c ****     }
1380:octet_queue.c **** 
1381:octet_queue.c ****     return end_offset;
 1858                 	OQGetEndOffset, .-OQGetEndOffset
 1859 001f 00 17       		.global	__size_of_OQGetEndOffset
1382:octet_queue.c **** } /* OQGetEndOffset */
 1860                 	equ	__size_of_OQGetEndOffset,. - OQGetEndOffset
 1861 0020 03 0F       		.section	.debug_frame,"",@progbits
 1862                 	.Lframe0:
 1863                 		.4byte	.LECIE0-.LSCIE0
 1864                 	.LSCIE0:
 1865                 		.4byte	0xffffffff
 1866                 		.1byte	0x1
 1867                 		.ascii "\000"
 1868 0000 00 00 00 00 		.1byte	0x1
 1869                 		.1byte	0x7f
 1870 0002 FF FF FF FF 		.1byte	0x3
 1871 0004 01          		.1byte	0xc
 1872 0004 00          		.1byte	0x5
 1873 0005 01          		.1byte	0x0
 1874 0005 7F          		.p2align	2
 1875 0006 03          	.LECIE0:
 1876 0006 0C          	.LSFDE0:
 1877 0007 05          		.4byte	.LEFDE0-.LASFDE0
 1878 0007 00          	.LASFDE0:
 1879                 		.4byte	.Lframe0
 1880                 		.4byte	.LFB2
 1881                 		.4byte	.LFE2-.LFB2
 1882 0008 00 00 00 00 		.1byte	0x4
 1883                 		.4byte	.LCFI0-.LFB2
 1884 000a 00 00 00 00 		.1byte	0xe
 1885 000c 00 00 00 00 		.1byte	0x1c
 1886 000e 00 00 00 00 		.1byte	0x83
 1887 0010 41          		.1byte	0x1
 1888                 		.p2align	2
 1889 0010 0E          	.LEFDE0:
 1890 0011 1C          	.LSFDE2:
 1891 0011 83          		.4byte	.LEFDE2-.LASFDE2
 1892 0012 01          	.LASFDE2:
 1893 0012 00 00 00    		.4byte	.Lframe0
 1894                 		.4byte	.LFB3
 1895                 		.4byte	.LFE3-.LFB3
 1896 0014 00 00 00 00 		.1byte	0x4
 1897                 		.4byte	.LCFI1-.LFB3
 1898 0016 00 00 00 00 		.1byte	0xe
 1899 0018 00 00 00 00 		.1byte	0x16
 1900 001a 00 00 00 00 		.1byte	0x83
 1901 001c 41          		.1byte	0x1
 1902                 		.p2align	2
 1903 001c 0E          	.LEFDE2:
 1904 001d 16          	.LSFDE4:
 1905 001d 83          		.4byte	.LEFDE4-.LASFDE4
 1906 001e 01          	.LASFDE4:
 1907 001e 00 00 00    		.4byte	.Lframe0
 1908                 		.4byte	.LFB4
 1909                 		.4byte	.LFE4-.LFB4
 1910 0020 00 00 00 00 		.1byte	0x4
 1911                 		.4byte	.LCFI2-.LFB4
 1912 0022 00 00 00 00 		.1byte	0xe
 1913 0024 00 00 00 00 		.1byte	0x5
 1914 0026 00 00 00 00 		.1byte	0x83
 1915 0028 41          		.1byte	0x1
 1916                 		.p2align	2
 1917 0028 0E          	.LEFDE4:
 1918 0029 05          	.LSFDE6:
 1919 0029 83          		.4byte	.LEFDE6-.LASFDE6
 1920 002a 01          	.LASFDE6:
 1921 002a 00 00 00    		.4byte	.Lframe0
 1922                 		.4byte	.LFB5
 1923                 		.4byte	.LFE5-.LFB5
 1924 002c 00 00 00 00 		.1byte	0x4
 1925                 		.4byte	.LCFI3-.LFB5
 1926 002e 00 00 00 00 		.1byte	0xe
 1927 0030 00 00 00 00 		.1byte	0x2
 1928 0032 00 00 00 00 		.1byte	0x83
 1929 0034 41          		.1byte	0x1
 1930                 		.p2align	2
 1931 0034 0E          	.LEFDE6:
 1932 0035 02          	.LSFDE8:
 1933 0035 83          		.4byte	.LEFDE8-.LASFDE8
 1934 0036 01          	.LASFDE8:
 1935 0036 00 00 00    		.4byte	.Lframe0
 1936                 		.4byte	.LFB6
 1937                 		.4byte	.LFE6-.LFB6
 1938 0038 00 00 00 00 		.1byte	0x4
 1939                 		.4byte	.LCFI4-.LFB6
 1940 003a 00 00 00 00 		.1byte	0xe
 1941 003c 00 00 00 00 		.1byte	0x3
 1942 003e 00 00 00 00 		.1byte	0x83
 1943 0040 41          		.1byte	0x1
 1944                 		.p2align	2
 1945 0040 0E          	.LEFDE8:
 1946 0041 03          	.LSFDE10:
 1947 0041 83          		.4byte	.LEFDE10-.LASFDE10
 1948 0042 01          	.LASFDE10:
 1949 0042 00 00 00    		.4byte	.Lframe0
 1950                 		.4byte	.LFB7
 1951                 		.4byte	.LFE7-.LFB7
 1952 0044 00 00 00 00 		.1byte	0x4
 1953                 		.4byte	.LCFI5-.LFB7
 1954 0046 00 00 00 00 		.1byte	0xe
 1955 0048 00 00 00 00 		.1byte	0x6
 1956 004a 00 00 00 00 		.1byte	0x83
 1957 004c 41          		.1byte	0x1
 1958                 		.p2align	2
 1959 004c 0E          	.LEFDE10:
 1960 004d 06          	.LSFDE12:
 1961 004d 83          		.4byte	.LEFDE12-.LASFDE12
 1962 004e 01          	.LASFDE12:
 1963 004e 00 00 00    		.4byte	.Lframe0
 1964                 		.4byte	.LFB8
 1965                 		.4byte	.LFE8-.LFB8
 1966 0050 00 00 00 00 		.1byte	0x4
 1967                 		.4byte	.LCFI6-.LFB8
 1968 0052 00 00 00 00 		.1byte	0xe
 1969 0054 00 00 00 00 		.1byte	0x4
 1970 0056 00 00 00 00 		.1byte	0x83
 1971 0058 41          		.1byte	0x1
 1972                 		.p2align	2
 1973 0058 0E          	.LEFDE12:
 1974 0059 04          	.LSFDE14:
 1975 0059 83          		.4byte	.LEFDE14-.LASFDE14
 1976 005a 01          	.LASFDE14:
 1977 005a 00 00 00    		.4byte	.Lframe0
 1978                 		.4byte	.LFB9
 1979                 		.4byte	.LFE9-.LFB9
 1980 005c 00 00 00 00 		.1byte	0x4
 1981                 		.4byte	.LCFI7-.LFB9
 1982 005e 00 00 00 00 		.1byte	0xe
 1983 0060 00 00 00 00 		.1byte	0x12
 1984 0062 00 00 00 00 		.1byte	0x83
 1985 0064 41          		.1byte	0x1
 1986                 		.p2align	2
 1987 0064 0E          	.LEFDE14:
 1988 0065 12          	.LSFDE16:
 1989 0065 83          		.4byte	.LEFDE16-.LASFDE16
 1990 0066 01          	.LASFDE16:
 1991 0066 00 00 00    		.4byte	.Lframe0
 1992                 		.4byte	.LFB10
 1993                 		.4byte	.LFE10-.LFB10
 1994 0068 00 00 00 00 		.1byte	0x4
 1995                 		.4byte	.LCFI8-.LFB10
 1996 006a 00 00 00 00 		.1byte	0xe
 1997 006c 00 00 00 00 		.1byte	0x3
 1998 006e 00 00 00 00 		.1byte	0x83
 1999 0070 41          		.1byte	0x1
 2000                 		.p2align	2
 2001 0070 0E          	.LEFDE16:
 2002 0071 03          	.LSFDE18:
 2003 0071 83          		.4byte	.LEFDE18-.LASFDE18
 2004 0072 01          	.LASFDE18:
 2005 0072 00 00 00    		.4byte	.Lframe0
 2006                 		.4byte	.LFB11
 2007                 		.4byte	.LFE11-.LFB11
 2008 0074 00 00 00 00 		.1byte	0x4
 2009                 		.4byte	.LCFI9-.LFB11
 2010 0076 00 00 00 00 		.1byte	0xe
 2011 0078 00 00 00 00 		.1byte	0x3
 2012 007a 00 00 00 00 		.1byte	0x83
 2013 007c 41          		.1byte	0x1
 2014                 		.p2align	2
 2015 007c 0E          	.LEFDE18:
 2016 007d 03          	.LSFDE20:
 2017 007d 83          		.4byte	.LEFDE20-.LASFDE20
 2018 007e 01          	.LASFDE20:
 2019 007e 00 00 00    		.4byte	.Lframe0
 2020                 		.4byte	.LFB12
 2021                 		.4byte	.LFE12-.LFB12
 2022 0080 00 00 00 00 		.1byte	0x4
 2023                 		.4byte	.LCFI10-.LFB12
 2024 0082 00 00 00 00 		.1byte	0xe
 2025 0084 00 00 00 00 		.1byte	0x3
 2026 0086 00 00 00 00 		.1byte	0x83
 2027 0088 41          		.1byte	0x1
 2028                 		.p2align	2
 2029 0088 0E          	.LEFDE20:
 2030 0089 03          	.LSFDE22:
 2031 0089 83          		.4byte	.LEFDE22-.LASFDE22
 2032 008a 01          	.LASFDE22:
 2033 008a 00 00 00    		.4byte	.Lframe0
 2034                 		.4byte	.LFB13
 2035                 		.4byte	.LFE13-.LFB13
 2036 008c 00 00 00 00 		.1byte	0x4
 2037                 		.4byte	.LCFI11-.LFB13
 2038 008e 00 00 00 00 		.1byte	0xe
 2039 0090 00 00 00 00 		.1byte	0x3
 2040 0092 00 00 00 00 		.1byte	0x83
 2041 0094 41          		.1byte	0x1
 2042                 		.p2align	2
 2043 0094 0E          	.LEFDE22:
 2044 0095 03          	.LSFDE24:
 2045 0095 83          		.4byte	.LEFDE24-.LASFDE24
 2046 0096 01          	.LASFDE24:
 2047 0096 00 00 00    		.4byte	.Lframe0
 2048                 		.4byte	.LFB14
 2049                 		.4byte	.LFE14-.LFB14
 2050 0098 00 00 00 00 		.1byte	0x4
 2051                 		.4byte	.LCFI12-.LFB14
 2052 009a 00 00 00 00 		.1byte	0xe
 2053 009c 00 00 00 00 		.1byte	0x3
 2054 009e 00 00 00 00 		.1byte	0x83
 2055 00a0 41          		.1byte	0x1
 2056                 		.p2align	2
 2057 00a0 0E          	.LEFDE24:
 2058 00a1 03          	.LSFDE26:
 2059 00a1 83          		.4byte	.LEFDE26-.LASFDE26
 2060 00a2 01          	.LASFDE26:
 2061 00a2 00 00 00    		.4byte	.Lframe0
 2062                 		.4byte	.LFB15
 2063                 		.4byte	.LFE15-.LFB15
 2064 00a4 00 00 00 00 		.1byte	0x4
 2065                 		.4byte	.LCFI13-.LFB15
 2066 00a6 00 00 00 00 		.1byte	0xe
 2067 00a8 00 00 00 00 		.1byte	0x2
 2068 00aa 00 00 00 00 		.1byte	0x83
 2069 00ac 41          		.1byte	0x1
 2070                 		.p2align	2
 2071 00ac 0E          	.LEFDE26:
 2072 00ad 02          	.LSFDE28:
 2073 00ad 83          		.4byte	.LEFDE28-.LASFDE28
 2074 00ae 01          	.LASFDE28:
 2075 00ae 00 00 00    		.4byte	.Lframe0
 2076                 		.4byte	.LFB16
 2077                 		.4byte	.LFE16-.LFB16
 2078 00b0 00 00 00 00 		.1byte	0x4
 2079                 		.4byte	.LCFI14-.LFB16
 2080 00b2 00 00 00 00 		.1byte	0xe
 2081 00b4 00 00 00 00 		.1byte	0x3
 2082 00b6 00 00 00 04 		.1byte	0x83
 2083 00b8 41          		.1byte	0x1
 2084                 		.p2align	2
 2085 00b8 0E          	.LEFDE28:
 2086 00b9 03          	.LSFDE30:
 2087 00b9 83          		.4byte	.LEFDE30-.LASFDE30
 2088 00ba 01          	.LASFDE30:
 2089 00ba 00 00 00    		.4byte	.Lframe0
 2090                 		.4byte	.LFB17
 2091                 		.4byte	.LFE17-.LFB17
 2092 00bc 00 00 00 00 		.1byte	0x4
 2093                 		.4byte	.LCFI15-.LFB17
 2094 00be 00 00 00 00 		.1byte	0xe
 2095 00c0 00 00 00 00 		.1byte	0x2
 2096 00c2 00 00 00 00 		.1byte	0x83
 2097 00c4 41          		.1byte	0x1
 2098                 		.p2align	2
 2099 00c4 0E          	.LEFDE30:
 2100 00c5 02          	.LSFDE32:
 2101 00c5 83          		.4byte	.LEFDE32-.LASFDE32
 2102 00c6 01          	.LASFDE32:
 2103 00c6 00 00 00    		.4byte	.Lframe0
 2104                 		.4byte	.LFB18
 2105                 		.4byte	.LFE18-.LFB18
 2106 00c8 00 00 00 00 		.1byte	0x4
 2107                 		.4byte	.LCFI16-.LFB18
 2108 00ca 00 00 00 00 		.1byte	0xe
 2109 00cc 00 00 00 00 		.1byte	0x5
 2110 00ce 00 00 00 00 		.1byte	0x83
 2111 00d0 41          		.1byte	0x1
 2112                 		.p2align	2
 2113 00d0 0E          	.LEFDE32:
 2114 00d1 05          	.LSFDE34:
 2115 00d1 83          		.4byte	.LEFDE34-.LASFDE34
 2116 00d2 01          	.LASFDE34:
 2117 00d2 00 00 00    		.4byte	.Lframe0
 2118                 		.4byte	.LFB19
 2119                 		.4byte	.LFE19-.LFB19
 2120 00d4 00 00 00 00 		.1byte	0x4
 2121                 		.4byte	.LCFI17-.LFB19
 2122 00d6 00 00 00 00 		.1byte	0xe
 2123 00d8 00 00 00 00 		.1byte	0x5
 2124 00da 00 00 00 00 		.1byte	0x83
 2125 00dc 41          		.1byte	0x1
 2126                 		.p2align	2
 2127 00dc 0E          	.LEFDE34:
 2128 00dd 05          	.LSFDE36:
 2129 00dd 83          		.4byte	.LEFDE36-.LASFDE36
 2130 00de 01          	.LASFDE36:
 2131 00de 00 00 00    		.4byte	.Lframe0
 2132                 		.4byte	.LFB20
 2133                 		.4byte	.LFE20-.LFB20
 2134 00e0 00 00 00 00 		.1byte	0x4
 2135                 		.4byte	.LCFI18-.LFB20
 2136 00e2 00 00 00 00 		.1byte	0xe
 2137 00e4 00 00 00 00 		.1byte	0x9
 2138 00e6 00 00 00 00 		.1byte	0x83
 2139 00e8 41          		.1byte	0x1
 2140                 		.p2align	2
 2141 00e8 0E          	.LEFDE36:
 2142 00e9 09          	.LSFDE38:
 2143 00e9 83          		.4byte	.LEFDE38-.LASFDE38
 2144 00ea 01          	.LASFDE38:
 2145 00ea 00 00 00    		.4byte	.Lframe0
 2146                 		.4byte	.LFB21
 2147                 		.4byte	.LFE21-.LFB21
 2148 00ec 00 00 00 00 		.1byte	0x4
 2149                 		.4byte	.LCFI19-.LFB21
 2150 00ee 00 00 00 00 		.1byte	0xe
 2151 00f0 00 00 00 00 		.1byte	0x3
 2152 00f2 00 00 00 00 		.1byte	0x83
 2153 00f4 41          		.1byte	0x1
 2154                 		.p2align	2
 2155 00f4 0E          	.LEFDE38:
 2156 00f5 03          	.LSFDE40:
 2157 00f5 83          		.4byte	.LEFDE40-.LASFDE40
 2158 00f6 01          	.LASFDE40:
 2159 00f6 00 00 00    		.4byte	.Lframe0
 2160                 		.4byte	.LFB22
 2161                 		.4byte	.LFE22-.LFB22
 2162 00f8 00 00 00 00 		.1byte	0x4
 2163                 		.4byte	.LCFI20-.LFB22
 2164 00fa 00 00 00 00 		.1byte	0xe
 2165 00fc 00 00 00 00 		.1byte	0x3
 2166 00fe 00 00 00 00 		.1byte	0x83
 2167 0100 41          		.1byte	0x1
 2168                 		.p2align	2
 2169 0100 0E          	.LEFDE40:
 2170 0101 03          		.text
 2171 0101 83          	.Letext0:
 2172 0102 01          		.section	.debug_loc,"",@progbits
 2173 0102 00 00 00    	.Ldebug_loc0:
 2174                 	.LLST0:
 2175                 		.4byte	.LFB2
 2176                 		.4byte	.LCFI0
 2177                 		.2byte	0x1
 2178                 		.1byte	0x55
 2179                 		.4byte	.LCFI0
 2180 0000 00 00 00 00 		.4byte	.LFE2
 2181 0002 00 00 00 00 		.2byte	0x2
 2182 0004 00 01       		.1byte	0x75
 2183 0005 55          		.1byte	0x1c
 2184 0005 00 00 00 00 		.4byte	0x0
 2185 0007 00 00 00 00 		.4byte	0x0
 2186 0009 00 02       	.LLST1:
 2187 000a 75          		.4byte	.LFB3
 2188 000b 1C          		.4byte	.LCFI1
 2189 000b 00 00 00 00 		.2byte	0x1
 2190 000d 00 00 00 00 		.1byte	0x55
 2191                 		.4byte	.LCFI1
 2192 000f 00 00 00 00 		.4byte	.LFE3
 2193 0011 00 00 00 00 		.2byte	0x2
 2194 0013 00 01       		.1byte	0x75
 2195 0014 55          		.1byte	0x16
 2196 0015 00 00 00 00 		.4byte	0x0
 2197 0017 00 00 00 00 		.4byte	0x0
 2198 0019 00 02       	.LLST2:
 2199 001a 75          		.4byte	.LFB4
 2200 001a 16          		.4byte	.LCFI2
 2201 001b 00 00 00 00 		.2byte	0x1
 2202 001d 00 00 00 00 		.1byte	0x55
 2203                 		.4byte	.LCFI2
 2204 001f 00 00 00 00 		.4byte	.LFE4
 2205 0021 00 00 00 00 		.2byte	0x2
 2206 0023 00 01       		.1byte	0x75
 2207 0024 55          		.1byte	0x5
 2208 0024 00 00 00 00 		.4byte	0x0
 2209 0026 00 00 00 00 		.4byte	0x0
 2210 0028 00 02       	.LLST3:
 2211 0029 75          		.4byte	.LFB5
 2212 002a 05          		.4byte	.LCFI3
 2213 002a 00 00 00 00 		.2byte	0x1
 2214 002c 00 00 00 00 		.1byte	0x55
 2215                 		.4byte	.LCFI3
 2216 002e 00 00 00 00 		.4byte	.LFE5
 2217 0030 00 00 00 00 		.2byte	0x2
 2218 0032 00 01       		.1byte	0x75
 2219 0033 55          		.1byte	0x2
 2220 0034 00 00 00 00 		.4byte	0x0
 2221 0036 00 00 00 00 		.4byte	0x0
 2222 0038 00 02       	.LLST4:
 2223 0039 75          		.4byte	.LFB6
 2224 0039 02          		.4byte	.LCFI4
 2225 003a 00 00 00 00 		.2byte	0x1
 2226 003c 00 00 00 00 		.1byte	0x55
 2227                 		.4byte	.LCFI4
 2228 003e 00 00 00 00 		.4byte	.LFE6
 2229 0040 00 00 00 00 		.2byte	0x2
 2230 0042 00 01       		.1byte	0x75
 2231 0043 55          		.1byte	0x3
 2232 0043 00 00 00 00 		.4byte	0x0
 2233 0045 00 00 00 00 		.4byte	0x0
 2234 0047 00 02       	.LLST5:
 2235 0048 75          		.4byte	.LFB7
 2236 0049 03          		.4byte	.LCFI5
 2237 0049 00 00 00 00 		.2byte	0x1
 2238 004b 00 00 00 00 		.1byte	0x55
 2239                 		.4byte	.LCFI5
 2240 004d 00 00 00 00 		.4byte	.LFE7
 2241 004f 00 00 00 00 		.2byte	0x2
 2242 0051 00 01       		.1byte	0x75
 2243 0052 55          		.1byte	0x6
 2244 0053 00 00 00 00 		.4byte	0x0
 2245 0055 00 00 00 00 		.4byte	0x0
 2246 0057 00 02       	.LLST6:
 2247 0058 75          		.4byte	.LFB8
 2248 0058 06          		.4byte	.LCFI6
 2249 0059 00 00 00 00 		.2byte	0x1
 2250 005b 00 00 00 00 		.1byte	0x55
 2251                 		.4byte	.LCFI6
 2252 005d 00 00 00 00 		.4byte	.LFE8
 2253 005f 00 00 00 00 		.2byte	0x2
 2254 0061 00 01       		.1byte	0x75
 2255 0062 55          		.1byte	0x4
 2256 0062 00 00 00 00 		.4byte	0x0
 2257 0064 00 00 00 00 		.4byte	0x0
 2258 0066 00 02       	.LLST7:
 2259 0067 75          		.4byte	.LFB9
 2260 0068 04          		.4byte	.LCFI7
 2261 0068 00 00 00 00 		.2byte	0x1
 2262 006a 00 00 00 00 		.1byte	0x55
 2263                 		.4byte	.LCFI7
 2264 006c 00 00 00 00 		.4byte	.LFE9
 2265 006e 00 00 00 00 		.2byte	0x2
 2266 0070 00 01       		.1byte	0x75
 2267 0071 55          		.1byte	0x12
 2268 0072 00 00 00 00 		.4byte	0x0
 2269 0074 00 00 00 00 		.4byte	0x0
 2270 0076 00 02       	.LLST8:
 2271 0077 75          		.4byte	.LFB10
 2272 0077 12          		.4byte	.LCFI8
 2273 0078 00 00 00 00 		.2byte	0x1
 2274 007a 00 00 00 00 		.1byte	0x55
 2275                 		.4byte	.LCFI8
 2276 007c 00 00 00 00 		.4byte	.LFE10
 2277 007e 00 00 00 00 		.2byte	0x2
 2278 0080 00 01       		.1byte	0x75
 2279 0081 55          		.1byte	0x3
 2280 0081 00 00 00 00 		.4byte	0x0
 2281 0083 00 00 00 00 		.4byte	0x0
 2282 0085 00 02       	.LLST9:
 2283 0086 75          		.4byte	.LFB11
 2284 0087 03          		.4byte	.LCFI9
 2285 0087 00 00 00 00 		.2byte	0x1
 2286 0089 00 00 00 00 		.1byte	0x55
 2287                 		.4byte	.LCFI9
 2288 008b 00 00 00 00 		.4byte	.LFE11
 2289 008d 00 00 00 00 		.2byte	0x2
 2290 008f 00 01       		.1byte	0x75
 2291 0090 55          		.1byte	0x3
 2292 0091 00 00 00 00 		.4byte	0x0
 2293 0093 00 00 00 00 		.4byte	0x0
 2294 0095 00 02       	.LLST10:
 2295 0096 75          		.4byte	.LFB12
 2296 0096 03          		.4byte	.LCFI10
 2297 0097 00 00 00 00 		.2byte	0x1
 2298 0099 00 00 00 00 		.1byte	0x55
 2299                 		.4byte	.LCFI10
 2300 009b 00 00 00 00 		.4byte	.LFE12
 2301 009d 00 00 00 00 		.2byte	0x2
 2302 009f 00 01       		.1byte	0x75
 2303 00a0 55          		.1byte	0x3
 2304 00a0 00 00 00 00 		.4byte	0x0
 2305 00a2 00 00 00 00 		.4byte	0x0
 2306 00a4 00 02       	.LLST11:
 2307 00a5 75          		.4byte	.LFB13
 2308 00a6 03          		.4byte	.LCFI11
 2309 00a6 00 00 00 00 		.2byte	0x1
 2310 00a8 00 00 00 00 		.1byte	0x55
 2311                 		.4byte	.LCFI11
 2312 00aa 00 00 00 00 		.4byte	.LFE13
 2313 00ac 00 00 00 00 		.2byte	0x2
 2314 00ae 00 01       		.1byte	0x75
 2315 00af 55          		.1byte	0x3
 2316 00b0 00 00 00 00 		.4byte	0x0
 2317 00b2 00 00 00 00 		.4byte	0x0
 2318 00b4 00 02       	.LLST12:
 2319 00b5 75          		.4byte	.LFB14
 2320 00b5 03          		.4byte	.LCFI12
 2321 00b6 00 00 00 00 		.2byte	0x1
 2322 00b8 00 00 00 00 		.1byte	0x55
 2323                 		.4byte	.LCFI12
 2324 00ba 00 00 00 00 		.4byte	.LFE14
 2325 00bc 00 00 00 00 		.2byte	0x2
 2326 00be 00 01       		.1byte	0x75
 2327 00bf 55          		.1byte	0x3
 2328 00bf 00 00 00 00 		.4byte	0x0
 2329 00c1 00 00 00 00 		.4byte	0x0
 2330 00c3 00 02       	.LLST13:
 2331 00c4 75          		.4byte	.LFB15
 2332 00c5 03          		.4byte	.LCFI13
 2333 00c5 00 00 00 00 		.2byte	0x1
 2334 00c7 00 00 00 00 		.1byte	0x55
 2335                 		.4byte	.LCFI13
 2336 00c9 00 00 00 00 		.4byte	.LFE15
 2337 00cb 00 00 00 00 		.2byte	0x2
 2338 00cd 00 01       		.1byte	0x75
 2339 00ce 55          		.1byte	0x2
 2340 00cf 00 00 00 00 		.4byte	0x0
 2341 00d1 00 00 00 00 		.4byte	0x0
 2342 00d3 00 02       	.LLST14:
 2343 00d4 75          		.4byte	.LFB16
 2344 00d4 02          		.4byte	.LCFI14
 2345 00d5 00 00 00 00 		.2byte	0x1
 2346 00d7 00 00 00 00 		.1byte	0x55
 2347                 		.4byte	.LCFI14
 2348 00d9 00 00 00 00 		.4byte	.LFE16
 2349 00db 00 00 00 00 		.2byte	0x2
 2350 00dd 00 01       		.1byte	0x75
 2351 00de 55          		.1byte	0x3
 2352 00de 00 00 00 00 		.4byte	0x0
 2353 00e0 00 00 00 00 		.4byte	0x0
 2354 00e2 00 02       	.LLST15:
 2355 00e3 75          		.4byte	.LFB17
 2356 00e4 03          		.4byte	.LCFI15
 2357 00e4 00 00 00 00 		.2byte	0x1
 2358 00e6 00 00 00 00 		.1byte	0x55
 2359                 		.4byte	.LCFI15
 2360 00e8 00 00 00 00 		.4byte	.LFE17
 2361 00ea 00 00 00 00 		.2byte	0x2
 2362 00ec 00 01       		.1byte	0x75
 2363 00ed 55          		.1byte	0x2
 2364 00ee 00 00 00 00 		.4byte	0x0
 2365 00f0 00 00 00 00 		.4byte	0x0
 2366 00f2 00 02       	.LLST16:
 2367 00f3 75          		.4byte	.LFB18
 2368 00f3 02          		.4byte	.LCFI16
 2369 00f4 00 00 00 00 		.2byte	0x1
 2370 00f6 00 00 00 00 		.1byte	0x55
 2371                 		.4byte	.LCFI16
 2372 00f8 00 00 00 00 		.4byte	.LFE18
 2373 00fa 00 00 00 00 		.2byte	0x2
 2374 00fc 00 01       		.1byte	0x75
 2375 00fd 55          		.1byte	0x5
 2376 00fd 00 00 00 00 		.4byte	0x0
 2377 00ff 00 00 00 00 		.4byte	0x0
 2378 0101 00 02       	.LLST17:
 2379 0102 75          		.4byte	.LFB19
 2380 0103 05          		.4byte	.LCFI17
 2381 0103 00 00 00 00 		.2byte	0x1
 2382 0105 00 00 00 00 		.1byte	0x55
 2383                 		.4byte	.LCFI17
 2384 0107 00 00 00 00 		.4byte	.LFE19
 2385 0109 00 00 00 00 		.2byte	0x2
 2386 010b 00 01       		.1byte	0x75
 2387 010c 55          		.1byte	0x5
 2388 010d 00 00 00 00 		.4byte	0x0
 2389 010f 00 00 00 00 		.4byte	0x0
 2390 0111 00 02       	.LLST18:
 2391 0112 75          		.4byte	.LFB20
 2392 0112 05          		.4byte	.LCFI18
 2393 0113 00 00 00 00 		.2byte	0x1
 2394 0115 00 00 00 00 		.1byte	0x55
 2395                 		.4byte	.LCFI18
 2396 0117 00 00 00 00 		.4byte	.LFE20
 2397 0119 00 00 00 00 		.2byte	0x2
 2398 011b 00 01       		.1byte	0x75
 2399 011c 55          		.1byte	0x9
 2400 011c 00 00 00 00 		.4byte	0x0
 2401 011e 00 00 00 00 		.4byte	0x0
 2402 0120 00 02       	.LLST19:
 2403 0121 75          		.4byte	.LFB21
 2404 0122 09          		.4byte	.LCFI19
 2405 0122 00 00 00 00 		.2byte	0x1
 2406 0124 00 00 00 00 		.1byte	0x55
 2407                 		.4byte	.LCFI19
 2408 0126 00 00 00 00 		.4byte	.LFE21
 2409 0128 00 00 00 00 		.2byte	0x2
 2410 012a 00 01       		.1byte	0x75
 2411 012b 55          		.1byte	0x3
 2412 012c 00 00 00 00 		.4byte	0x0
 2413 012e 00 00 00 00 		.4byte	0x0
 2414 0130 00 02       	.LLST20:
 2415 0131 75          		.4byte	.LFB22
 2416 0131 03          		.4byte	.LCFI20
 2417 0132 00 00 00 00 		.2byte	0x1
 2418 0134 00 00 00 00 		.1byte	0x55
 2419                 		.4byte	.LCFI20
 2420 0136 00 00 00 00 		.4byte	.LFE22
 2421 0138 00 00 00 00 		.2byte	0x2
 2422 013a 00 01       		.1byte	0x75
 2423 013b 55          		.1byte	0x3
 2424 013b 00 00 00 00 		.4byte	0x0
 2425 013d 00 00 00 00 		.4byte	0x0
 2426 013f 00 02       		.file 2 "C:/CSR_uEnergy_SDK-2.3.0.31/tools/include/CSR101x_A05/types.h"
 2427 0140 75          		.file 3 "octet_queue.h"
 2428 0141 03          		.section	.debug_info
 2429 0141 00 00 00 00 		.4byte	0x991
 2430 0143 00 00 00 00 		.2byte	0x2
 2431                 		.4byte	.Ldebug_abbrev0
 2432                 		.1byte	0x4
 2433                 		.1byte	0x1
 2434 0000 00 00 09 91 		.4byte	.LASF75
 2435 0002 00 02       		.1byte	0x1
 2436 0003 00 00 00 00 		.4byte	.LASF76
 2437 0005 04          		.4byte	.LASF77
 2438 0005 01          		.4byte	0x0
 2439 0006 00 00 00 00 		.4byte	0x0
 2440 0008 01          		.4byte	.Ldebug_ranges0+0x0
 2441 0008 00 00 00 00 		.4byte	.Ldebug_line0
 2442 000a 00 00 00 00 		.1byte	0x2
 2443 000c 00 00 00 00 		.4byte	.LASF0
 2444 000e 00 00 00 00 		.1byte	0x2
 2445 0010 00 00 00 00 		.1byte	0x1e
 2446 0012 00 00 00 00 		.4byte	0x34
 2447 0014 02          		.1byte	0x3
 2448 0015 00 00 00 00 		.1byte	0x2
 2449 0017 02          		.1byte	0x8
 2450 0017 1E          		.4byte	.LASF2
 2451 0018 00 00 00 34 		.1byte	0x2
 2452 001a 03          		.4byte	.LASF1
 2453 001a 02          		.1byte	0x2
 2454 001b 08          		.1byte	0x1f
 2455 001b 00 00 00 00 		.4byte	0x46
 2456 001d 02          		.1byte	0x3
 2457 001e 00 00 00 00 		.1byte	0x2
 2458 0020 02          		.1byte	0x7
 2459 0020 1F          		.4byte	.LASF3
 2460 0021 00 00 00 46 		.1byte	0x3
 2461 0023 03          		.1byte	0x4
 2462 0023 02          		.1byte	0x7
 2463 0024 07          		.4byte	.LASF4
 2464 0024 00 00 00 00 		.1byte	0x3
 2465 0026 03          		.1byte	0x2
 2466 0027 04          		.1byte	0x6
 2467 0027 07          		.4byte	.LASF5
 2468 0028 00 00 00 00 		.1byte	0x3
 2469 002a 03          		.1byte	0x2
 2470 002a 02          		.1byte	0x5
 2471 002b 06          		.4byte	.LASF6
 2472 002b 00 00 00 00 		.1byte	0x3
 2473 002d 03          		.1byte	0x4
 2474 002e 02          		.1byte	0x5
 2475 002e 05          		.4byte	.LASF7
 2476 002f 00 00 00 00 		.1byte	0x2
 2477 0031 03          		.4byte	.LASF8
 2478 0031 04          		.1byte	0x2
 2479 0032 05          		.1byte	0x2a
 2480 0032 00 00 00 00 		.4byte	0x74
 2481 0034 02          		.1byte	0x3
 2482 0035 00 00 00 00 		.1byte	0x2
 2483 0037 02          		.1byte	0x7
 2484 0037 2A          		.4byte	.LASF9
 2485 0038 00 00 00 74 		.1byte	0x4
 2486 003a 03          		.1byte	0x2
 2487 003a 02          		.1byte	0x3
 2488 003b 07          		.1byte	0x2b
 2489 003b 00 00 00 00 		.4byte	0x96
 2490 003d 04          		.1byte	0x5
 2491 003e 02          		.4byte	.LASF10
 2492 003e 03          		.1byte	0x0
 2493 003f 2B          		.1byte	0x5
 2494 003f 00 00 00 96 		.4byte	.LASF11
 2495 0041 05          		.1byte	0x1
 2496 0042 00 00 00 00 		.1byte	0x5
 2497 0044 00          		.4byte	.LASF12
 2498 0044 05          		.1byte	0x2
 2499 0045 00 00 00 00 		.1byte	0x0
 2500 0047 01          		.1byte	0x2
 2501 0047 05          		.4byte	.LASF13
 2502 0048 00 00 00 00 		.1byte	0x3
 2503 004a 02          		.1byte	0x3a
 2504 004a 00          		.4byte	0x7b
 2505 004b 02          		.1byte	0x6
 2506 004b 00 00 00 00 		.4byte	.LASF78
 2507 004d 03          		.1byte	0xc
 2508 004e 3A          		.1byte	0x3
 2509 004e 00 00 00 7B 		.1byte	0x3e
 2510 0050 06          		.4byte	0x102
 2511 0051 00 00 00 00 		.1byte	0x7
 2512 0053 0C          		.4byte	.LASF14
 2513 0053 03          		.1byte	0x3
 2514 0054 3E          		.1byte	0x42
 2515 0054 00 00 01 02 		.4byte	0x102
 2516 0056 07          		.1byte	0x2
 2517 0057 00 00 00 00 		.1byte	0x23
 2518 0059 03          		.1byte	0x0
 2519 0059 42          		.1byte	0x7
 2520 005a 00 00 01 02 		.4byte	.LASF15
 2521 005c 02          		.1byte	0x3
 2522 005c 23          		.1byte	0x49
 2523 005d 00          		.4byte	0x3b
 2524 005d 07          		.1byte	0x2
 2525 005e 00 00 00 00 		.1byte	0x23
 2526 0060 03          		.1byte	0x1
 2527 0060 49          		.1byte	0x7
 2528 0061 00 00 00 3B 		.4byte	.LASF16
 2529 0063 02          		.1byte	0x3
 2530 0063 23          		.1byte	0x52
 2531 0064 01          		.4byte	0x3b
 2532 0064 07          		.1byte	0x2
 2533 0065 00 00 00 00 		.1byte	0x23
 2534 0067 03          		.1byte	0x2
 2535 0067 52          		.1byte	0x7
 2536 0068 00 00 00 3B 		.4byte	.LASF17
 2537 006a 02          		.1byte	0x3
 2538 006a 23          		.1byte	0x5b
 2539 006b 02          		.4byte	0x3b
 2540 006b 07          		.1byte	0x2
 2541 006c 00 00 00 00 		.1byte	0x23
 2542 006e 03          		.1byte	0x3
 2543 006e 5B          		.1byte	0x7
 2544 006f 00 00 00 3B 		.4byte	.LASF18
 2545 0071 02          		.1byte	0x3
 2546 0071 23          		.1byte	0x61
 2547 0072 03          		.4byte	0x69
 2548 0072 07          		.1byte	0x2
 2549 0073 00 00 00 00 		.1byte	0x23
 2550 0075 03          		.1byte	0x4
 2551 0075 61          		.1byte	0x7
 2552 0076 00 00 00 69 		.4byte	.LASF19
 2553 0078 02          		.1byte	0x3
 2554 0078 23          		.1byte	0x73
 2555 0079 04          		.4byte	0x96
 2556 0079 07          		.1byte	0x2
 2557 007a 00 00 00 00 		.1byte	0x23
 2558 007c 03          		.1byte	0x5
 2559 007c 73          		.1byte	0x0
 2560 007d 00 00 00 96 		.1byte	0x8
 2561 007f 02          		.1byte	0x2
 2562 007f 23          		.1byte	0x2
 2563 0080 05          		.4byte	.LASF20
 2564 0080 00          		.1byte	0x3
 2565 0081 08          		.1byte	0x74
 2566 0081 02          		.4byte	0xa1
 2567 0082 02          		.1byte	0x2
 2568 0082 00 00 00 00 		.4byte	.LASF21
 2569 0084 03          		.1byte	0x3
 2570 0085 74          		.1byte	0x77
 2571 0085 00 00 00 A1 		.4byte	0x11a
 2572 0087 02          		.1byte	0x9
 2573 0088 00 00 00 00 		.1byte	0x2
 2574 008a 03          		.4byte	0x104
 2575 008a 77          		.1byte	0xa
 2576 008b 00 00 01 1A 		.4byte	.LASF34
 2577 008d 09          		.1byte	0x1
 2578 008d 02          		.1byte	0x64
 2579 008e 00 00 01 04 		.1byte	0x1
 2580 0090 0A          		.4byte	0x3b
 2581 0090 00 00 00 00 		.4byte	.LFB2
 2582 0092 01          		.4byte	.LFE2
 2583 0093 64          		.4byte	.LLST0
 2584 0093 01          		.4byte	0x2cd
 2585 0094 00 00 00 3B 		.1byte	0xb
 2586 0096 00 00 00 00 		.4byte	.LASF22
 2587 0098 00 00 00 00 		.1byte	0x1
 2588 009a 00 00 00 00 		.1byte	0x5f
 2589 009c 00 00 02 CD 		.4byte	0x10f
 2590 009e 0B          		.1byte	0x2
 2591 009e 00 00 00 00 		.1byte	0x76
 2592 00a0 01          		.1byte	0x13
 2593 00a1 5F          		.1byte	0xb
 2594 00a1 00 00 01 0F 		.4byte	.LASF23
 2595 00a3 02          		.1byte	0x1
 2596 00a4 76          		.1byte	0x60
 2597 00a4 13          		.4byte	0x2cd
 2598 00a5 0B          		.1byte	0x2
 2599 00a5 00 00 00 00 		.1byte	0x76
 2600 00a7 01          		.1byte	0x14
 2601 00a8 60          		.1byte	0xb
 2602 00a8 00 00 02 CD 		.4byte	.LASF24
 2603 00aa 02          		.1byte	0x1
 2604 00ab 76          		.1byte	0x61
 2605 00ab 14          		.4byte	0x3b
 2606 00ac 0B          		.1byte	0x2
 2607 00ac 00 00 00 00 		.1byte	0x91
 2608 00ae 01          		.1byte	0x0
 2609 00af 61          		.1byte	0xb
 2610 00af 00 00 00 3B 		.4byte	.LASF25
 2611 00b1 02          		.1byte	0x1
 2612 00b2 91          		.1byte	0x62
 2613 00b2 00          		.4byte	0x69
 2614 00b3 0B          		.1byte	0x2
 2615 00b3 00 00 00 00 		.1byte	0x91
 2616 00b5 01          		.1byte	0x1
 2617 00b6 62          		.1byte	0xb
 2618 00b6 00 00 00 69 		.4byte	.LASF26
 2619 00b8 02          		.1byte	0x1
 2620 00b9 91          		.1byte	0x63
 2621 00b9 01          		.4byte	0x96
 2622 00ba 0B          		.1byte	0x2
 2623 00ba 00 00 00 00 		.1byte	0x91
 2624 00bc 01          		.1byte	0x2
 2625 00bd 63          		.1byte	0xc
 2626 00bd 00 00 00 96 		.4byte	.LASF27
 2627 00bf 02          		.1byte	0x1
 2628 00c0 91          		.1byte	0x67
 2629 00c0 02          		.4byte	0x2d4
 2630 00c1 0C          		.1byte	0x2
 2631 00c1 00 00 00 00 		.1byte	0x76
 2632 00c3 01          		.1byte	0x12
 2633 00c4 67          		.1byte	0xc
 2634 00c4 00 00 02 D4 		.4byte	.LASF28
 2635 00c6 02          		.1byte	0x1
 2636 00c7 76          		.1byte	0x6a
 2637 00c7 12          		.4byte	0x2d4
 2638 00c8 0C          		.1byte	0x2
 2639 00c8 00 00 00 00 		.1byte	0x76
 2640 00ca 01          		.1byte	0x11
 2641 00cb 6A          		.1byte	0xc
 2642 00cb 00 00 02 D4 		.4byte	.LASF29
 2643 00cd 02          		.1byte	0x1
 2644 00ce 76          		.1byte	0x6d
 2645 00ce 11          		.4byte	0x3b
 2646 00cf 0C          		.1byte	0x2
 2647 00cf 00 00 00 00 		.1byte	0x76
 2648 00d1 01          		.1byte	0x10
 2649 00d2 6D          		.1byte	0xd
 2650 00d2 00 00 00 3B 		.4byte	.LBB2
 2651 00d4 02          		.4byte	.LBE2
 2652 00d5 76          		.4byte	0x225
 2653 00d5 10          		.1byte	0xe
 2654 00d6 0D          		.ascii "in\000"
 2655 00d6 00 00 00 00 		.1byte	0x1
 2656 00d8 00 00 00 00 		.1byte	0x77
 2657 00da 00 00 02 25 		.4byte	0x2d9
 2658 00dc 0E          		.1byte	0x2
 2659 00dd 69 6E 00    		.1byte	0x76
 2660 00de 01          		.1byte	0xf
 2661 00df 77          		.1byte	0xe
 2662 00df 00 00 02 D9 		.ascii "out\000"
 2663 00e1 02          		.1byte	0x1
 2664 00e2 76          		.1byte	0x79
 2665 00e2 0F          		.4byte	0x2df
 2666 00e3 0E          		.1byte	0x2
 2667 00e3 6F 75 74 00 		.1byte	0x76
 2668 00e5 01          		.1byte	0xe
 2669 00e6 79          		.1byte	0xc
 2670 00e6 00 00 02 DF 		.4byte	.LASF30
 2671 00e8 02          		.1byte	0x1
 2672 00e9 76          		.1byte	0x7b
 2673 00e9 0E          		.4byte	0x69
 2674 00ea 0C          		.1byte	0x2
 2675 00ea 00 00 00 00 		.1byte	0x76
 2676 00ec 01          		.1byte	0xd
 2677 00ed 7B          		.1byte	0xc
 2678 00ed 00 00 00 69 		.4byte	.LASF31
 2679 00ef 02          		.1byte	0x1
 2680 00f0 76          		.1byte	0x7d
 2681 00f0 0D          		.4byte	0x69
 2682 00f1 0C          		.1byte	0x2
 2683 00f1 00 00 00 00 		.1byte	0x76
 2684 00f3 01          		.1byte	0xc
 2685 00f4 7D          		.1byte	0xd
 2686 00f4 00 00 00 69 		.4byte	.LBB3
 2687 00f6 02          		.4byte	.LBE3
 2688 00f7 76          		.4byte	0x20c
 2689 00f7 0C          		.1byte	0xc
 2690 00f8 0D          		.4byte	.LASF32
 2691 00f8 00 00 00 00 		.1byte	0x1
 2692 00fa 00 00 00 00 		.1byte	0x85
 2693 00fc 00 00 02 0C 		.4byte	0x3b
 2694 00fe 0C          		.1byte	0x2
 2695 00ff 00 00 00 00 		.1byte	0x76
 2696 0101 01          		.1byte	0xb
 2697 0101 85          		.1byte	0x0
 2698 0102 00 00 00 3B 		.1byte	0xf
 2699 0104 02          		.4byte	.LBB4
 2700 0104 76          		.4byte	.LBE4
 2701 0105 0B          		.1byte	0xc
 2702 0105 00          		.4byte	.LASF33
 2703 0106 0F          		.1byte	0x1
 2704 0106 00 00 00 00 		.1byte	0xb7
 2705 0108 00 00 00 00 		.4byte	0x3b
 2706 010a 0C          		.1byte	0x2
 2707 010b 00 00 00 00 		.1byte	0x76
 2708 010d 01          		.1byte	0xa
 2709 010d B7          		.1byte	0x0
 2710 010e 00 00 00 3B 		.1byte	0x0
 2711 0110 02          		.1byte	0xd
 2712 0110 76          		.4byte	.LBB5
 2713 0111 0A          		.4byte	.LBE5
 2714 0111 00          		.4byte	0x25c
 2715 0112 00          		.1byte	0xe
 2716 0112 0D          		.ascii "in\000"
 2717 0113 00 00 00 00 		.1byte	0x1
 2718 0115 00 00 00 00 		.1byte	0xf6
 2719 0117 00 00 02 5C 		.4byte	0x2e5
 2720 0119 0E          		.1byte	0x2
 2721 0119 69 6E 00    		.1byte	0x76
 2722 011b 01          		.1byte	0x9
 2723 011b F6          		.1byte	0xe
 2724 011c 00 00 02 E5 		.ascii "out\000"
 2725 011e 02          		.1byte	0x1
 2726 011e 76          		.1byte	0xf8
 2727 011f 09          		.4byte	0x2f0
 2728 011f 0E          		.1byte	0x2
 2729 0120 6F 75 74 00 		.1byte	0x76
 2730 0122 01          		.1byte	0x8
 2731 0122 F8          		.1byte	0xc
 2732 0123 00 00 02 F0 		.4byte	.LASF33
 2733 0125 02          		.1byte	0x1
 2734 0125 76          		.1byte	0xfa
 2735 0126 08          		.4byte	0x2d4
 2736 0126 0C          		.1byte	0x2
 2737 0127 00 00 00 00 		.1byte	0x76
 2738 0129 01          		.1byte	0x7
 2739 0129 FA          		.1byte	0x0
 2740 012a 00 00 02 D4 		.1byte	0xd
 2741 012c 02          		.4byte	.LBB6
 2742 012c 76          		.4byte	.LBE6
 2743 012d 07          		.4byte	0x296
 2744 012d 00          		.1byte	0x10
 2745 012e 0D          		.ascii "in\000"
 2746 012e 00 00 00 00 		.1byte	0x1
 2747 0130 00 00 00 00 		.2byte	0x119
 2748 0132 00 00 02 96 		.4byte	0x2e5
 2749 0134 10          		.1byte	0x2
 2750 0135 69 6E 00    		.1byte	0x76
 2751 0136 01          		.1byte	0x6
 2752 0137 01 19       		.1byte	0x10
 2753 0138 00 00 02 E5 		.ascii "out\000"
 2754 013a 02          		.1byte	0x1
 2755 013a 76          		.2byte	0x11b
 2756 013b 06          		.4byte	0x2df
 2757 013b 10          		.1byte	0x2
 2758 013c 6F 75 74 00 		.1byte	0x76
 2759 013e 01          		.1byte	0x5
 2760 013e 01 1B       		.1byte	0x11
 2761 013f 00 00 02 DF 		.4byte	.LASF33
 2762 0141 02          		.1byte	0x1
 2763 0142 76          		.2byte	0x11d
 2764 0142 05          		.4byte	0x3b
 2765 0143 11          		.1byte	0x2
 2766 0143 00 00 00 00 		.1byte	0x76
 2767 0145 01          		.1byte	0x4
 2768 0146 01 1D       		.1byte	0x0
 2769 0147 00 00 00 3B 		.1byte	0xf
 2770 0149 02          		.4byte	.LBB7
 2771 0149 76          		.4byte	.LBE7
 2772 014a 04          		.1byte	0x10
 2773 014a 00          		.ascii "in\000"
 2774 014b 0F          		.1byte	0x1
 2775 014b 00 00 00 00 		.2byte	0x153
 2776 014d 00 00 00 00 		.4byte	0x2d9
 2777 014f 10          		.1byte	0x2
 2778 0150 69 6E 00    		.1byte	0x76
 2779 0151 01          		.1byte	0x3
 2780 0152 01 53       		.1byte	0x10
 2781 0153 00 00 02 D9 		.ascii "out\000"
 2782 0155 02          		.1byte	0x1
 2783 0155 76          		.2byte	0x155
 2784 0156 03          		.4byte	0x2f0
 2785 0156 10          		.1byte	0x2
 2786 0157 6F 75 74 00 		.1byte	0x76
 2787 0159 01          		.1byte	0x2
 2788 0159 01 55       		.1byte	0x11
 2789 015a 00 00 02 F0 		.4byte	.LASF33
 2790 015c 02          		.1byte	0x1
 2791 015d 76          		.2byte	0x157
 2792 015d 02          		.4byte	0x3b
 2793 015e 11          		.1byte	0x2
 2794 015e 00 00 00 00 		.1byte	0x76
 2795 0160 01          		.1byte	0x1
 2796 0161 01 57       		.1byte	0x0
 2797 0162 00 00 00 3B 		.1byte	0x0
 2798 0164 02          		.1byte	0x9
 2799 0164 76          		.1byte	0x2
 2800 0165 01          		.4byte	0x2d3
 2801 0165 00          		.1byte	0x12
 2802 0166 00          		.1byte	0x13
 2803 0166 09          		.4byte	0x3b
 2804 0167 02          		.1byte	0x9
 2805 0167 00 00 02 D3 		.1byte	0x2
 2806 0169 12          		.4byte	0x2d4
 2807 016a 13          		.1byte	0x9
 2808 016a 00 00 00 3B 		.1byte	0x2
 2809 016c 09          		.4byte	0x3b
 2810 016d 02          		.1byte	0x9
 2811 016d 00 00 02 D4 		.1byte	0x2
 2812 016f 09          		.4byte	0x2eb
 2813 0170 02          		.1byte	0x13
 2814 0170 00 00 00 3B 		.4byte	0x29
 2815 0172 09          		.1byte	0x9
 2816 0173 02          		.1byte	0x2
 2817 0173 00 00 02 EB 		.4byte	0x29
 2818 0175 13          		.1byte	0x14
 2819 0176 00 00 00 29 		.4byte	.LASF35
 2820 0178 09          		.1byte	0x1
 2821 0178 02          		.2byte	0x1b6
 2822 0179 00 00 00 29 		.1byte	0x1
 2823 017b 14          		.4byte	0x3b
 2824 017b 00 00 00 00 		.4byte	.LFB3
 2825 017d 01          		.4byte	.LFE3
 2826 017e 01 B6       		.4byte	.LLST1
 2827 017f 01          		.4byte	0x43c
 2828 017f 00 00 00 3B 		.1byte	0x15
 2829 0181 00 00 00 00 		.4byte	.LASF22
 2830 0183 00 00 00 00 		.1byte	0x1
 2831 0185 00 00 00 00 		.2byte	0x1b3
 2832 0187 00 00 04 3C 		.4byte	0x10f
 2833 0189 15          		.1byte	0x2
 2834 018a 00 00 00 00 		.1byte	0x76
 2835 018c 01          		.1byte	0xe
 2836 018c 01 B3       		.1byte	0x15
 2837 018d 00 00 01 0F 		.4byte	.LASF23
 2838 018f 02          		.1byte	0x1
 2839 0190 76          		.2byte	0x1b4
 2840 0190 0E          		.4byte	0x102
 2841 0191 15          		.1byte	0x2
 2842 0191 00 00 00 00 		.1byte	0x76
 2843 0193 01          		.1byte	0xf
 2844 0194 01 B4       		.1byte	0x15
 2845 0195 00 00 01 02 		.4byte	.LASF24
 2846 0197 02          		.1byte	0x1
 2847 0197 76          		.2byte	0x1b5
 2848 0198 0F          		.4byte	0x3b
 2849 0198 15          		.1byte	0x2
 2850 0199 00 00 00 00 		.1byte	0x91
 2851 019b 01          		.1byte	0x0
 2852 019b 01 B5       		.1byte	0x11
 2853 019c 00 00 00 3B 		.4byte	.LASF36
 2854 019e 02          		.1byte	0x1
 2855 019f 91          		.2byte	0x1b9
 2856 019f 00          		.4byte	0x2d4
 2857 01a0 11          		.1byte	0x2
 2858 01a0 00 00 00 00 		.1byte	0x76
 2859 01a2 01          		.1byte	0xd
 2860 01a3 01 B9       		.1byte	0x11
 2861 01a4 00 00 02 D4 		.4byte	.LASF37
 2862 01a6 02          		.1byte	0x1
 2863 01a6 76          		.2byte	0x1bc
 2864 01a7 0D          		.4byte	0x2d4
 2865 01a7 11          		.1byte	0x2
 2866 01a8 00 00 00 00 		.1byte	0x76
 2867 01aa 01          		.1byte	0xc
 2868 01aa 01 BC       		.1byte	0x11
 2869 01ab 00 00 02 D4 		.4byte	.LASF38
 2870 01ad 02          		.1byte	0x1
 2871 01ae 76          		.2byte	0x1bf
 2872 01ae 0C          		.4byte	0x3b
 2873 01af 11          		.1byte	0x2
 2874 01af 00 00 00 00 		.1byte	0x76
 2875 01b1 01          		.1byte	0xb
 2876 01b2 01 BF       		.1byte	0xd
 2877 01b3 00 00 00 3B 		.4byte	.LBB8
 2878 01b5 02          		.4byte	.LBE8
 2879 01b5 76          		.4byte	0x405
 2880 01b6 0B          		.1byte	0x10
 2881 01b6 0D          		.ascii "in\000"
 2882 01b7 00 00 00 00 		.1byte	0x1
 2883 01b9 00 00 00 00 		.2byte	0x1ca
 2884 01bb 00 00 04 05 		.4byte	0x2d9
 2885 01bd 10          		.1byte	0x2
 2886 01bd 69 6E 00    		.1byte	0x76
 2887 01bf 01          		.1byte	0xa
 2888 01bf 01 CA       		.1byte	0x10
 2889 01c0 00 00 02 D9 		.ascii "out\000"
 2890 01c2 02          		.1byte	0x1
 2891 01c3 76          		.2byte	0x1cc
 2892 01c3 0A          		.4byte	0x2df
 2893 01c4 10          		.1byte	0x2
 2894 01c4 6F 75 74 00 		.1byte	0x76
 2895 01c6 01          		.1byte	0x9
 2896 01c7 01 CC       		.1byte	0x11
 2897 01c8 00 00 02 DF 		.4byte	.LASF30
 2898 01ca 02          		.1byte	0x1
 2899 01ca 76          		.2byte	0x1ce
 2900 01cb 09          		.4byte	0x69
 2901 01cb 11          		.1byte	0x2
 2902 01cc 00 00 00 00 		.1byte	0x76
 2903 01ce 01          		.1byte	0x8
 2904 01ce 01 CE       		.1byte	0xd
 2905 01cf 00 00 00 69 		.4byte	.LBB9
 2906 01d1 02          		.4byte	.LBE9
 2907 01d2 76          		.4byte	0x3eb
 2908 01d2 08          		.1byte	0x11
 2909 01d3 0D          		.4byte	.LASF39
 2910 01d3 00 00 00 00 		.1byte	0x1
 2911 01d5 00 00 00 00 		.2byte	0x1d6
 2912 01d7 00 00 03 EB 		.4byte	0x43c
 2913 01d9 11          		.1byte	0x2
 2914 01da 00 00 00 00 		.1byte	0x76
 2915 01dc 01          		.1byte	0x7
 2916 01dc 01 D6       		.1byte	0x11
 2917 01dd 00 00 04 3C 		.4byte	.LASF31
 2918 01df 02          		.1byte	0x1
 2919 01e0 76          		.2byte	0x1d9
 2920 01e0 07          		.4byte	0x69
 2921 01e1 11          		.1byte	0x2
 2922 01e1 00 00 00 00 		.1byte	0x76
 2923 01e3 01          		.1byte	0x6
 2924 01e4 01 D9       		.1byte	0xf
 2925 01e5 00 00 00 69 		.4byte	.LBB10
 2926 01e7 02          		.4byte	.LBE10
 2927 01e7 76          		.1byte	0x11
 2928 01e8 06          		.4byte	.LASF32
 2929 01e8 0F          		.1byte	0x1
 2930 01e9 00 00 00 00 		.2byte	0x1de
 2931 01eb 00 00 00 00 		.4byte	0x3b
 2932 01ed 11          		.1byte	0x2
 2933 01ed 00 00 00 00 		.1byte	0x76
 2934 01ef 01          		.1byte	0x5
 2935 01f0 01 DE       		.1byte	0x0
 2936 01f1 00 00 00 3B 		.1byte	0x0
 2937 01f3 02          		.1byte	0xf
 2938 01f3 76          		.4byte	.LBB11
 2939 01f4 05          		.4byte	.LBE11
 2940 01f4 00          		.1byte	0x11
 2941 01f5 00          		.4byte	.LASF33
 2942 01f5 0F          		.1byte	0x1
 2943 01f6 00 00 00 00 		.2byte	0x20d
 2944 01f8 00 00 00 00 		.4byte	0x2d4
 2945 01fa 11          		.1byte	0x2
 2946 01fa 00 00 00 00 		.1byte	0x76
 2947 01fc 01          		.1byte	0x4
 2948 01fd 02 0D       		.1byte	0x0
 2949 01fe 00 00 02 D4 		.1byte	0x0
 2950 0200 02          		.1byte	0xf
 2951 0200 76          		.4byte	.LBB12
 2952 0201 04          		.4byte	.LBE12
 2953 0201 00          		.1byte	0x10
 2954 0202 00          		.ascii "in\000"
 2955 0202 0F          		.1byte	0x1
 2956 0203 00 00 00 00 		.2byte	0x233
 2957 0205 00 00 00 00 		.4byte	0x2e5
 2958 0207 10          		.1byte	0x2
 2959 0207 69 6E 00    		.1byte	0x76
 2960 0209 01          		.1byte	0x3
 2961 0209 02 33       		.1byte	0x10
 2962 020a 00 00 02 E5 		.ascii "out\000"
 2963 020c 02          		.1byte	0x1
 2964 020d 76          		.2byte	0x235
 2965 020d 03          		.4byte	0x2f0
 2966 020e 10          		.1byte	0x2
 2967 020e 6F 75 74 00 		.1byte	0x76
 2968 0210 01          		.1byte	0x2
 2969 0211 02 35       		.1byte	0x11
 2970 0212 00 00 02 F0 		.4byte	.LASF33
 2971 0214 02          		.1byte	0x1
 2972 0214 76          		.2byte	0x237
 2973 0215 02          		.4byte	0x2d4
 2974 0215 11          		.1byte	0x2
 2975 0216 00 00 00 00 		.1byte	0x76
 2976 0218 01          		.1byte	0x1
 2977 0218 02 37       		.1byte	0x0
 2978 0219 00 00 02 D4 		.1byte	0x0
 2979 021b 02          		.1byte	0x13
 2980 021c 76          		.4byte	0x2d9
 2981 021c 01          		.1byte	0x16
 2982 021d 00          		.1byte	0x1
 2983 021d 00          		.4byte	.LASF43
 2984 021e 13          		.1byte	0x1
 2985 021e 00 00 02 D9 		.2byte	0x277
 2986 0220 16          		.1byte	0x1
 2987 0221 01          		.4byte	0x69
 2988 0221 00 00 00 00 		.4byte	.LFB4
 2989 0223 01          		.4byte	.LFE4
 2990 0224 02 77       		.4byte	.LLST2
 2991 0225 01          		.4byte	0x4ab
 2992 0225 00 00 00 69 		.1byte	0x15
 2993 0227 00 00 00 00 		.4byte	.LASF14
 2994 0229 00 00 00 00 		.1byte	0x1
 2995 022b 00 00 00 00 		.2byte	0x273
 2996 022d 00 00 04 AB 		.4byte	0x102
 2997 022f 15          		.1byte	0x2
 2998 0230 00 00 00 00 		.1byte	0x76
 2999 0232 01          		.1byte	0x1
 3000 0232 02 73       		.1byte	0x15
 3001 0233 00 00 01 02 		.4byte	.LASF40
 3002 0235 02          		.1byte	0x1
 3003 0236 76          		.2byte	0x274
 3004 0236 01          		.4byte	0x3b
 3005 0237 15          		.1byte	0x2
 3006 0237 00 00 00 00 		.1byte	0x76
 3007 0239 01          		.1byte	0x2
 3008 023a 02 74       		.1byte	0x15
 3009 023b 00 00 00 3B 		.4byte	.LASF41
 3010 023d 02          		.1byte	0x1
 3011 023d 76          		.2byte	0x275
 3012 023e 02          		.4byte	0x96
 3013 023e 15          		.1byte	0x2
 3014 023f 00 00 00 00 		.1byte	0x91
 3015 0241 01          		.1byte	0x0
 3016 0241 02 75       		.1byte	0x15
 3017 0242 00 00 00 96 		.4byte	.LASF22
 3018 0244 02          		.1byte	0x1
 3019 0245 91          		.2byte	0x276
 3020 0245 00          		.4byte	0x10f
 3021 0246 15          		.1byte	0x2
 3022 0246 00 00 00 00 		.1byte	0x91
 3023 0248 01          		.1byte	0x1
 3024 0249 02 76       		.1byte	0x11
 3025 024a 00 00 01 0F 		.4byte	.LASF42
 3026 024c 02          		.1byte	0x1
 3027 024c 91          		.2byte	0x279
 3028 024d 01          		.4byte	0x4ab
 3029 024d 11          		.1byte	0x2
 3030 024e 00 00 00 00 		.1byte	0x76
 3031 0250 01          		.1byte	0x0
 3032 0250 02 79       		.1byte	0x0
 3033 0251 00 00 04 AB 		.1byte	0x13
 3034 0253 02          		.4byte	0x69
 3035 0254 76          		.1byte	0x17
 3036 0254 00          		.1byte	0x1
 3037 0255 00          		.4byte	.LASF60
 3038 0255 13          		.1byte	0x1
 3039 0256 00 00 00 69 		.2byte	0x2a2
 3040 0258 17          		.1byte	0x1
 3041 0258 01          		.4byte	.LFB5
 3042 0259 00 00 00 00 		.4byte	.LFE5
 3043 025b 01          		.4byte	.LLST3
 3044 025b 02 A2       		.4byte	0x4da
 3045 025c 01          		.1byte	0x15
 3046 025d 00 00 00 00 		.4byte	.LASF22
 3047 025f 00 00 00 00 		.1byte	0x1
 3048 0261 00 00 00 00 		.2byte	0x2a1
 3049 0263 00 00 04 DA 		.4byte	0x10f
 3050 0265 15          		.1byte	0x2
 3051 0265 00 00 00 00 		.1byte	0x76
 3052 0267 01          		.1byte	0x0
 3053 0268 02 A1       		.1byte	0x0
 3054 0269 00 00 01 0F 		.1byte	0x16
 3055 026b 02          		.1byte	0x1
 3056 026b 76          		.4byte	.LASF44
 3057 026c 00          		.1byte	0x1
 3058 026c 00          		.2byte	0x2b9
 3059 026d 16          		.1byte	0x1
 3060 026d 01          		.4byte	0x69
 3061 026e 00 00 00 00 		.4byte	.LFB6
 3062 0270 01          		.4byte	.LFE6
 3063 0270 02 B9       		.4byte	.LLST4
 3064 0271 01          		.4byte	0x508
 3065 0272 00 00 00 69 		.1byte	0x15
 3066 0274 00 00 00 00 		.4byte	.LASF22
 3067 0276 00 00 00 00 		.1byte	0x1
 3068 0278 00 00 00 00 		.2byte	0x2b8
 3069 027a 00 00 05 08 		.4byte	0x508
 3070 027c 15          		.1byte	0x2
 3071 027c 00 00 00 00 		.1byte	0x76
 3072 027e 01          		.1byte	0x0
 3073 027f 02 B8       		.1byte	0x0
 3074 0280 00 00 05 08 		.1byte	0x13
 3075 0282 02          		.4byte	0x10f
 3076 0282 76          		.1byte	0x16
 3077 0283 00          		.1byte	0x1
 3078 0283 00          		.4byte	.LASF45
 3079 0284 13          		.1byte	0x1
 3080 0284 00 00 01 0F 		.2byte	0x2d7
 3081 0286 16          		.1byte	0x1
 3082 0287 01          		.4byte	0x3b
 3083 0287 00 00 00 00 		.4byte	.LFB7
 3084 0289 01          		.4byte	.LFE7
 3085 028a 02 D7       		.4byte	.LLST5
 3086 028b 01          		.4byte	0x559
 3087 028b 00 00 00 3B 		.1byte	0x15
 3088 028d 00 00 00 00 		.4byte	.LASF22
 3089 028f 00 00 00 00 		.1byte	0x1
 3090 0291 00 00 00 00 		.2byte	0x2d6
 3091 0293 00 00 05 59 		.4byte	0x10f
 3092 0295 15          		.1byte	0x2
 3093 0296 00 00 00 00 		.1byte	0x76
 3094 0298 01          		.1byte	0x3
 3095 0298 02 D6       		.1byte	0x15
 3096 0299 00 00 01 0F 		.4byte	.LASF23
 3097 029b 02          		.1byte	0x1
 3098 029c 76          		.2byte	0x2d6
 3099 029c 03          		.4byte	0x2cd
 3100 029d 15          		.1byte	0x2
 3101 029d 00 00 00 00 		.1byte	0x76
 3102 029f 01          		.1byte	0x4
 3103 02a0 02 D6       		.1byte	0x15
 3104 02a1 00 00 02 CD 		.4byte	.LASF46
 3105 02a3 02          		.1byte	0x1
 3106 02a3 76          		.2byte	0x2d6
 3107 02a4 04          		.4byte	0x3b
 3108 02a4 15          		.1byte	0x2
 3109 02a5 00 00 00 00 		.1byte	0x91
 3110 02a7 01          		.1byte	0x0
 3111 02a7 02 D6       		.1byte	0x0
 3112 02a8 00 00 00 3B 		.1byte	0x16
 3113 02aa 02          		.1byte	0x1
 3114 02ab 91          		.4byte	.LASF47
 3115 02ab 00          		.1byte	0x1
 3116 02ac 00          		.2byte	0x2f3
 3117 02ac 16          		.1byte	0x1
 3118 02ad 01          		.4byte	0x3b
 3119 02ad 00 00 00 00 		.4byte	.LFB8
 3120 02af 01          		.4byte	.LFE8
 3121 02b0 02 F3       		.4byte	.LLST6
 3122 02b1 01          		.4byte	0x5a5
 3123 02b1 00 00 00 3B 		.1byte	0x15
 3124 02b3 00 00 00 00 		.4byte	.LASF22
 3125 02b5 00 00 00 00 		.1byte	0x1
 3126 02b7 00 00 00 00 		.2byte	0x2f2
 3127 02b9 00 00 05 A5 		.4byte	0x10f
 3128 02bb 15          		.1byte	0x2
 3129 02bc 00 00 00 00 		.1byte	0x76
 3130 02be 01          		.1byte	0x1
 3131 02be 02 F2       		.1byte	0x15
 3132 02bf 00 00 01 0F 		.4byte	.LASF23
 3133 02c1 02          		.1byte	0x1
 3134 02c2 76          		.2byte	0x2f2
 3135 02c2 01          		.4byte	0x102
 3136 02c3 15          		.1byte	0x2
 3137 02c3 00 00 00 00 		.1byte	0x76
 3138 02c5 01          		.1byte	0x2
 3139 02c6 02 F2       		.1byte	0x15
 3140 02c7 00 00 01 02 		.4byte	.LASF46
 3141 02c9 02          		.1byte	0x1
 3142 02c9 76          		.2byte	0x2f2
 3143 02ca 02          		.4byte	0x3b
 3144 02ca 15          		.1byte	0x2
 3145 02cb 00 00 00 00 		.1byte	0x91
 3146 02cd 01          		.1byte	0x0
 3147 02cd 02 F2       		.1byte	0x0
 3148 02ce 00 00 00 3B 		.1byte	0x16
 3149 02d0 02          		.1byte	0x1
 3150 02d1 91          		.4byte	.LASF48
 3151 02d1 00          		.1byte	0x1
 3152 02d2 00          		.2byte	0x314
 3153 02d2 16          		.1byte	0x1
 3154 02d3 01          		.4byte	0x3b
 3155 02d3 00 00 00 00 		.4byte	.LFB9
 3156 02d5 01          		.4byte	.LFE9
 3157 02d6 03 14       		.4byte	.LLST7
 3158 02d7 01          		.4byte	0x659
 3159 02d7 00 00 00 3B 		.1byte	0x15
 3160 02d9 00 00 00 00 		.4byte	.LASF49
 3161 02db 00 00 00 00 		.1byte	0x1
 3162 02dd 00 00 00 00 		.2byte	0x313
 3163 02df 00 00 06 59 		.4byte	0x10f
 3164 02e1 15          		.1byte	0x2
 3165 02e2 00 00 00 00 		.1byte	0x76
 3166 02e4 01          		.1byte	0xa
 3167 02e4 03 13       		.1byte	0x18
 3168 02e5 00 00 01 0F 		.ascii "to\000"
 3169 02e7 02          		.1byte	0x1
 3170 02e8 76          		.2byte	0x313
 3171 02e8 0A          		.4byte	0x10f
 3172 02e9 18          		.1byte	0x2
 3173 02e9 74 6F 00    		.1byte	0x76
 3174 02eb 01          		.1byte	0xb
 3175 02eb 03 13       		.1byte	0x15
 3176 02ec 00 00 01 0F 		.4byte	.LASF46
 3177 02ee 02          		.1byte	0x1
 3178 02ef 76          		.2byte	0x313
 3179 02ef 0B          		.4byte	0x3b
 3180 02f0 15          		.1byte	0x2
 3181 02f0 00 00 00 00 		.1byte	0x91
 3182 02f2 01          		.1byte	0x0
 3183 02f3 03 13       		.1byte	0x11
 3184 02f4 00 00 00 3B 		.4byte	.LASF50
 3185 02f6 02          		.1byte	0x1
 3186 02f6 91          		.2byte	0x317
 3187 02f7 00          		.4byte	0x2d4
 3188 02f7 11          		.1byte	0x2
 3189 02f8 00 00 00 00 		.1byte	0x76
 3190 02fa 01          		.1byte	0x9
 3191 02fa 03 17       		.1byte	0x11
 3192 02fb 00 00 02 D4 		.4byte	.LASF36
 3193 02fd 02          		.1byte	0x1
 3194 02fe 76          		.2byte	0x31b
 3195 02fe 09          		.4byte	0x2d4
 3196 02ff 11          		.1byte	0x2
 3197 02ff 00 00 00 00 		.1byte	0x76
 3198 0301 01          		.1byte	0x8
 3199 0302 03 1B       		.1byte	0x11
 3200 0303 00 00 02 D4 		.4byte	.LASF51
 3201 0305 02          		.1byte	0x1
 3202 0305 76          		.2byte	0x31e
 3203 0306 08          		.4byte	0x2d4
 3204 0306 11          		.1byte	0x2
 3205 0307 00 00 00 00 		.1byte	0x76
 3206 0309 01          		.1byte	0x7
 3207 0309 03 1E       		.1byte	0x11
 3208 030a 00 00 02 D4 		.4byte	.LASF52
 3209 030c 02          		.1byte	0x1
 3210 030d 76          		.2byte	0x321
 3211 030d 07          		.4byte	0x3b
 3212 030e 11          		.1byte	0x2
 3213 030e 00 00 00 00 		.1byte	0x76
 3214 0310 01          		.1byte	0x6
 3215 0311 03 21       		.1byte	0x11
 3216 0312 00 00 00 3B 		.4byte	.LASF33
 3217 0314 02          		.1byte	0x1
 3218 0314 76          		.2byte	0x324
 3219 0315 06          		.4byte	0x2d4
 3220 0315 11          		.1byte	0x2
 3221 0316 00 00 00 00 		.1byte	0x76
 3222 0318 01          		.1byte	0x5
 3223 0318 03 24       		.1byte	0x11
 3224 0319 00 00 02 D4 		.4byte	.LASF53
 3225 031b 02          		.1byte	0x1
 3226 031c 76          		.2byte	0x327
 3227 031c 05          		.4byte	0x69
 3228 031d 11          		.1byte	0x2
 3229 031d 00 00 00 00 		.1byte	0x76
 3230 031f 01          		.1byte	0x4
 3231 0320 03 27       		.1byte	0x10
 3232 0321 00 00 00 69 		.ascii "src\000"
 3233 0323 02          		.1byte	0x1
 3234 0323 76          		.2byte	0x32a
 3235 0324 04          		.4byte	0x2cd
 3236 0324 10          		.1byte	0x2
 3237 0325 73 72 63 00 		.1byte	0x76
 3238 0327 01          		.1byte	0x3
 3239 0327 03 2A       		.1byte	0x0
 3240 0328 00 00 02 CD 		.1byte	0x16
 3241 032a 02          		.1byte	0x1
 3242 032b 76          		.4byte	.LASF54
 3243 032b 03          		.1byte	0x1
 3244 032c 00          		.2byte	0x362
 3245 032c 16          		.1byte	0x1
 3246 032d 01          		.4byte	0x3b
 3247 032d 00 00 00 00 		.4byte	.LFB10
 3248 032f 01          		.4byte	.LFE10
 3249 0330 03 62       		.4byte	.LLST8
 3250 0331 01          		.4byte	0x696
 3251 0331 00 00 00 3B 		.1byte	0x15
 3252 0333 00 00 00 00 		.4byte	.LASF22
 3253 0335 00 00 00 00 		.1byte	0x1
 3254 0337 00 00 00 00 		.2byte	0x361
 3255 0339 00 00 06 96 		.4byte	0x508
 3256 033b 15          		.1byte	0x2
 3257 033c 00 00 00 00 		.1byte	0x76
 3258 033e 01          		.1byte	0x1
 3259 033e 03 61       		.1byte	0x11
 3260 033f 00 00 05 08 		.4byte	.LASF55
 3261 0341 02          		.1byte	0x1
 3262 0342 76          		.2byte	0x363
 3263 0342 01          		.4byte	0x3b
 3264 0343 11          		.1byte	0x2
 3265 0343 00 00 00 00 		.1byte	0x76
 3266 0345 01          		.1byte	0x0
 3267 0346 03 63       		.1byte	0x0
 3268 0347 00 00 00 3B 		.1byte	0x16
 3269 0349 02          		.1byte	0x1
 3270 0349 76          		.4byte	.LASF56
 3271 034a 00          		.1byte	0x1
 3272 034a 00          		.2byte	0x384
 3273 034b 16          		.1byte	0x1
 3274 034b 01          		.4byte	0x69
 3275 034c 00 00 00 00 		.4byte	.LFB11
 3276 034e 01          		.4byte	.LFE11
 3277 034e 03 84       		.4byte	.LLST9
 3278 034f 01          		.4byte	0x6c4
 3279 0350 00 00 00 69 		.1byte	0x15
 3280 0352 00 00 00 00 		.4byte	.LASF22
 3281 0354 00 00 00 00 		.1byte	0x1
 3282 0356 00 00 00 00 		.2byte	0x383
 3283 0358 00 00 06 C4 		.4byte	0x508
 3284 035a 15          		.1byte	0x2
 3285 035a 00 00 00 00 		.1byte	0x76
 3286 035c 01          		.1byte	0x0
 3287 035d 03 83       		.1byte	0x0
 3288 035e 00 00 05 08 		.1byte	0x16
 3289 0360 02          		.1byte	0x1
 3290 0360 76          		.4byte	.LASF57
 3291 0361 00          		.1byte	0x1
 3292 0361 00          		.2byte	0x396
 3293 0362 16          		.1byte	0x1
 3294 0362 01          		.4byte	0x69
 3295 0363 00 00 00 00 		.4byte	.LFB12
 3296 0365 01          		.4byte	.LFE12
 3297 0365 03 96       		.4byte	.LLST10
 3298 0366 01          		.4byte	0x6f2
 3299 0367 00 00 00 69 		.1byte	0x15
 3300 0369 00 00 00 00 		.4byte	.LASF22
 3301 036b 00 00 00 00 		.1byte	0x1
 3302 036d 00 00 00 00 		.2byte	0x395
 3303 036f 00 00 06 F2 		.4byte	0x508
 3304 0371 15          		.1byte	0x2
 3305 0371 00 00 00 00 		.1byte	0x76
 3306 0373 01          		.1byte	0x0
 3307 0374 03 95       		.1byte	0x0
 3308 0375 00 00 05 08 		.1byte	0x16
 3309 0377 02          		.1byte	0x1
 3310 0377 76          		.4byte	.LASF58
 3311 0378 00          		.1byte	0x1
 3312 0378 00          		.2byte	0x3ab
 3313 0379 16          		.1byte	0x1
 3314 0379 01          		.4byte	0x3b
 3315 037a 00 00 00 00 		.4byte	.LFB13
 3316 037c 01          		.4byte	.LFE13
 3317 037c 03 AB       		.4byte	.LLST11
 3318 037d 01          		.4byte	0x72f
 3319 037e 00 00 00 3B 		.1byte	0x15
 3320 0380 00 00 00 00 		.4byte	.LASF22
 3321 0382 00 00 00 00 		.1byte	0x1
 3322 0384 00 00 00 00 		.2byte	0x3aa
 3323 0386 00 00 07 2F 		.4byte	0x508
 3324 0388 15          		.1byte	0x2
 3325 0388 00 00 00 00 		.1byte	0x76
 3326 038a 01          		.1byte	0x1
 3327 038b 03 AA       		.1byte	0x11
 3328 038c 00 00 05 08 		.4byte	.LASF46
 3329 038e 02          		.1byte	0x1
 3330 038e 76          		.2byte	0x3ac
 3331 038f 01          		.4byte	0x3b
 3332 038f 11          		.1byte	0x2
 3333 0390 00 00 00 00 		.1byte	0x76
 3334 0392 01          		.1byte	0x0
 3335 0392 03 AC       		.1byte	0x0
 3336 0393 00 00 00 3B 		.1byte	0x16
 3337 0395 02          		.1byte	0x1
 3338 0396 76          		.4byte	.LASF59
 3339 0396 00          		.1byte	0x1
 3340 0397 00          		.2byte	0x3cb
 3341 0397 16          		.1byte	0x1
 3342 0398 01          		.4byte	0x3b
 3343 0398 00 00 00 00 		.4byte	.LFB14
 3344 039a 01          		.4byte	.LFE14
 3345 039b 03 CB       		.4byte	.LLST12
 3346 039c 01          		.4byte	0x75d
 3347 039c 00 00 00 3B 		.1byte	0x15
 3348 039e 00 00 00 00 		.4byte	.LASF22
 3349 03a0 00 00 00 00 		.1byte	0x1
 3350 03a2 00 00 00 00 		.2byte	0x3ca
 3351 03a4 00 00 07 5D 		.4byte	0x508
 3352 03a6 15          		.1byte	0x2
 3353 03a7 00 00 00 00 		.1byte	0x76
 3354 03a9 01          		.1byte	0x0
 3355 03a9 03 CA       		.1byte	0x0
 3356 03aa 00 00 05 08 		.1byte	0x17
 3357 03ac 02          		.1byte	0x1
 3358 03ad 76          		.4byte	.LASF61
 3359 03ad 00          		.1byte	0x1
 3360 03ae 00          		.2byte	0x3e1
 3361 03ae 17          		.1byte	0x1
 3362 03af 01          		.4byte	.LFB15
 3363 03af 00 00 00 00 		.4byte	.LFE15
 3364 03b1 01          		.4byte	.LLST13
 3365 03b2 03 E1       		.4byte	0x787
 3366 03b3 01          		.1byte	0x15
 3367 03b3 00 00 00 00 		.4byte	.LASF22
 3368 03b5 00 00 00 00 		.1byte	0x1
 3369 03b7 00 00 00 00 		.2byte	0x3e0
 3370 03b9 00 00 07 87 		.4byte	0x10f
 3371 03bb 15          		.1byte	0x2
 3372 03bc 00 00 00 00 		.1byte	0x76
 3373 03be 01          		.1byte	0x0
 3374 03be 03 E0       		.1byte	0x0
 3375 03bf 00 00 01 0F 		.1byte	0x17
 3376 03c1 02          		.1byte	0x1
 3377 03c2 76          		.4byte	.LASF62
 3378 03c2 00          		.1byte	0x1
 3379 03c3 00          		.2byte	0x410
 3380 03c3 17          		.1byte	0x1
 3381 03c4 01          		.4byte	.LFB16
 3382 03c4 00 00 00 00 		.4byte	.LFE16
 3383 03c6 01          		.4byte	.LLST14
 3384 03c7 04 10       		.4byte	0x7cf
 3385 03c8 01          		.1byte	0x15
 3386 03c8 00 00 00 00 		.4byte	.LASF22
 3387 03ca 00 00 00 00 		.1byte	0x1
 3388 03cc 00 00 00 00 		.2byte	0x40f
 3389 03ce 00 00 07 CF 		.4byte	0x10f
 3390 03d0 15          		.1byte	0x2
 3391 03d1 00 00 00 00 		.1byte	0x76
 3392 03d3 01          		.1byte	0x0
 3393 03d3 04 0F       		.1byte	0x15
 3394 03d4 00 00 01 0F 		.4byte	.LASF63
 3395 03d6 02          		.1byte	0x1
 3396 03d7 76          		.2byte	0x40f
 3397 03d7 00          		.4byte	0x69
 3398 03d8 15          		.1byte	0x2
 3399 03d8 00 00 00 00 		.1byte	0x76
 3400 03da 01          		.1byte	0x1
 3401 03db 04 0F       		.1byte	0x15
 3402 03dc 00 00 00 69 		.4byte	.LASF64
 3403 03de 02          		.1byte	0x1
 3404 03de 76          		.2byte	0x40f
 3405 03df 01          		.4byte	0x29
 3406 03df 15          		.1byte	0x2
 3407 03e0 00 00 00 00 		.1byte	0x91
 3408 03e2 01          		.1byte	0x0
 3409 03e2 04 0F       		.1byte	0x0
 3410 03e3 00 00 00 29 		.1byte	0x17
 3411 03e5 02          		.1byte	0x1
 3412 03e6 91          		.4byte	.LASF65
 3413 03e6 00          		.1byte	0x1
 3414 03e7 00          		.2byte	0x42f
 3415 03e7 17          		.1byte	0x1
 3416 03e8 01          		.4byte	.LFB17
 3417 03e8 00 00 00 00 		.4byte	.LFE17
 3418 03ea 01          		.4byte	.LLST15
 3419 03eb 04 2F       		.4byte	0x7f9
 3420 03ec 01          		.1byte	0x15
 3421 03ec 00 00 00 00 		.4byte	.LASF22
 3422 03ee 00 00 00 00 		.1byte	0x1
 3423 03f0 00 00 00 00 		.2byte	0x42e
 3424 03f2 00 00 07 F9 		.4byte	0x10f
 3425 03f4 15          		.1byte	0x2
 3426 03f5 00 00 00 00 		.1byte	0x76
 3427 03f7 01          		.1byte	0x0
 3428 03f7 04 2E       		.1byte	0x0
 3429 03f8 00 00 01 0F 		.1byte	0x16
 3430 03fa 02          		.1byte	0x1
 3431 03fb 76          		.4byte	.LASF66
 3432 03fb 00          		.1byte	0x1
 3433 03fc 00          		.2byte	0x45b
 3434 03fc 16          		.1byte	0x1
 3435 03fd 01          		.4byte	0x69
 3436 03fd 00 00 00 00 		.4byte	.LFB18
 3437 03ff 01          		.4byte	.LFE18
 3438 0400 04 5B       		.4byte	.LLST16
 3439 0401 01          		.4byte	0x85e
 3440 0401 00 00 00 69 		.1byte	0x15
 3441 0403 00 00 00 00 		.4byte	.LASF22
 3442 0405 00 00 00 00 		.1byte	0x1
 3443 0407 00 00 00 00 		.2byte	0x45a
 3444 0409 00 00 08 5E 		.4byte	0x10f
 3445 040b 15          		.1byte	0x2
 3446 040c 00 00 00 00 		.1byte	0x76
 3447 040e 01          		.1byte	0x2
 3448 040e 04 5A       		.1byte	0x15
 3449 040f 00 00 01 0F 		.4byte	.LASF46
 3450 0411 02          		.1byte	0x1
 3451 0412 76          		.2byte	0x45a
 3452 0412 02          		.4byte	0x3b
 3453 0413 15          		.1byte	0x2
 3454 0413 00 00 00 00 		.1byte	0x76
 3455 0415 01          		.1byte	0x3
 3456 0416 04 5A       		.1byte	0x11
 3457 0417 00 00 00 3B 		.4byte	.LASF42
 3458 0419 02          		.1byte	0x1
 3459 0419 76          		.2byte	0x45d
 3460 041a 03          		.4byte	0x69
 3461 041a 11          		.1byte	0x2
 3462 041b 00 00 00 00 		.1byte	0x76
 3463 041d 01          		.1byte	0x1
 3464 041d 04 5D       		.1byte	0xf
 3465 041e 00 00 00 69 		.4byte	.LBB13
 3466 0420 02          		.4byte	.LBE13
 3467 0421 76          		.1byte	0x11
 3468 0421 01          		.4byte	.LASF67
 3469 0422 0F          		.1byte	0x1
 3470 0422 00 00 00 00 		.2byte	0x463
 3471 0424 00 00 00 00 		.4byte	0x2d4
 3472 0426 11          		.1byte	0x2
 3473 0427 00 00 00 00 		.1byte	0x76
 3474 0429 01          		.1byte	0x0
 3475 0429 04 63       		.1byte	0x0
 3476 042a 00 00 02 D4 		.1byte	0x0
 3477 042c 02          		.1byte	0x16
 3478 042d 76          		.1byte	0x1
 3479 042d 00          		.4byte	.LASF68
 3480 042e 00          		.1byte	0x1
 3481 042e 00          		.2byte	0x485
 3482 042f 16          		.1byte	0x1
 3483 042f 01          		.4byte	0x3b
 3484 0430 00 00 00 00 		.4byte	.LFB19
 3485 0432 01          		.4byte	.LFE19
 3486 0432 04 85       		.4byte	.LLST17
 3487 0433 01          		.4byte	0x8c3
 3488 0434 00 00 00 3B 		.1byte	0x15
 3489 0436 00 00 00 00 		.4byte	.LASF22
 3490 0438 00 00 00 00 		.1byte	0x1
 3491 043a 00 00 00 00 		.2byte	0x484
 3492 043c 00 00 08 C3 		.4byte	0x10f
 3493 043e 15          		.1byte	0x2
 3494 043e 00 00 00 00 		.1byte	0x76
 3495 0440 01          		.1byte	0x2
 3496 0441 04 84       		.1byte	0x15
 3497 0442 00 00 01 0F 		.4byte	.LASF46
 3498 0444 02          		.1byte	0x1
 3499 0444 76          		.2byte	0x484
 3500 0445 02          		.4byte	0x3b
 3501 0445 15          		.1byte	0x2
 3502 0446 00 00 00 00 		.1byte	0x76
 3503 0448 01          		.1byte	0x3
 3504 0448 04 84       		.1byte	0x11
 3505 0449 00 00 00 3B 		.4byte	.LASF27
 3506 044b 02          		.1byte	0x1
 3507 044c 76          		.2byte	0x487
 3508 044c 03          		.4byte	0x2d4
 3509 044d 11          		.1byte	0x2
 3510 044d 00 00 00 00 		.1byte	0x76
 3511 044f 01          		.1byte	0x1
 3512 0450 04 87       		.1byte	0xf
 3513 0451 00 00 02 D4 		.4byte	.LBB14
 3514 0453 02          		.4byte	.LBE14
 3515 0453 76          		.1byte	0x11
 3516 0454 01          		.4byte	.LASF33
 3517 0454 0F          		.1byte	0x1
 3518 0455 00 00 00 00 		.2byte	0x490
 3519 0457 00 00 00 00 		.4byte	0x2d4
 3520 0459 11          		.1byte	0x2
 3521 0459 00 00 00 00 		.1byte	0x76
 3522 045b 01          		.1byte	0x0
 3523 045c 04 90       		.1byte	0x0
 3524 045d 00 00 02 D4 		.1byte	0x0
 3525 045f 02          		.1byte	0x16
 3526 045f 76          		.1byte	0x1
 3527 0460 00          		.4byte	.LASF69
 3528 0460 00          		.1byte	0x1
 3529 0461 00          		.2byte	0x4b2
 3530 0461 16          		.1byte	0x1
 3531 0462 01          		.4byte	0x3b
 3532 0462 00 00 00 00 		.4byte	.LFB20
 3533 0464 01          		.4byte	.LFE20
 3534 0465 04 B2       		.4byte	.LLST18
 3535 0466 01          		.4byte	0x92d
 3536 0466 00 00 00 3B 		.1byte	0x15
 3537 0468 00 00 00 00 		.4byte	.LASF22
 3538 046a 00 00 00 00 		.1byte	0x1
 3539 046c 00 00 00 00 		.2byte	0x4b1
 3540 046e 00 00 09 2D 		.4byte	0x10f
 3541 0470 15          		.1byte	0x2
 3542 0471 00 00 00 00 		.1byte	0x76
 3543 0473 01          		.1byte	0x3
 3544 0473 04 B1       		.1byte	0x15
 3545 0474 00 00 01 0F 		.4byte	.LASF46
 3546 0476 02          		.1byte	0x1
 3547 0477 76          		.2byte	0x4b1
 3548 0477 03          		.4byte	0x3b
 3549 0478 15          		.1byte	0x2
 3550 0478 00 00 00 00 		.1byte	0x76
 3551 047a 01          		.1byte	0x4
 3552 047b 04 B1       		.1byte	0x11
 3553 047c 00 00 00 3B 		.4byte	.LASF36
 3554 047e 02          		.1byte	0x1
 3555 047e 76          		.2byte	0x4b5
 3556 047f 04          		.4byte	0x2d4
 3557 047f 11          		.1byte	0x2
 3558 0480 00 00 00 00 		.1byte	0x76
 3559 0482 01          		.1byte	0x2
 3560 0482 04 B5       		.1byte	0x11
 3561 0483 00 00 02 D4 		.4byte	.LASF70
 3562 0485 02          		.1byte	0x1
 3563 0486 76          		.2byte	0x4b8
 3564 0486 02          		.4byte	0x2d4
 3565 0487 11          		.1byte	0x2
 3566 0487 00 00 00 00 		.1byte	0x76
 3567 0489 01          		.1byte	0x1
 3568 048a 04 B8       		.1byte	0x11
 3569 048b 00 00 02 D4 		.4byte	.LASF71
 3570 048d 02          		.1byte	0x1
 3571 048d 76          		.2byte	0x4bb
 3572 048e 01          		.4byte	0x3b
 3573 048e 11          		.1byte	0x2
 3574 048f 00 00 00 00 		.1byte	0x76
 3575 0491 01          		.1byte	0x0
 3576 0491 04 BB       		.1byte	0x0
 3577 0492 00 00 00 3B 		.1byte	0x16
 3578 0494 02          		.1byte	0x1
 3579 0495 76          		.4byte	.LASF72
 3580 0495 00          		.1byte	0x1
 3581 0496 00          		.2byte	0x53a
 3582 0496 16          		.1byte	0x1
 3583 0497 01          		.4byte	0x3b
 3584 0497 00 00 00 00 		.4byte	.LFB21
 3585 0499 01          		.4byte	.LFE21
 3586 049a 05 3A       		.4byte	.LLST19
 3587 049b 01          		.4byte	0x95b
 3588 049b 00 00 00 3B 		.1byte	0x15
 3589 049d 00 00 00 00 		.4byte	.LASF22
 3590 049f 00 00 00 00 		.1byte	0x1
 3591 04a1 00 00 00 00 		.2byte	0x539
 3592 04a3 00 00 09 5B 		.4byte	0x508
 3593 04a5 15          		.1byte	0x2
 3594 04a6 00 00 00 00 		.1byte	0x76
 3595 04a8 01          		.1byte	0x0
 3596 04a8 05 39       		.1byte	0x0
 3597 04a9 00 00 05 08 		.1byte	0x19
 3598 04ab 02          		.1byte	0x1
 3599 04ac 76          		.4byte	.LASF73
 3600 04ac 00          		.1byte	0x1
 3601 04ad 00          		.2byte	0x54d
 3602 04ad 19          		.1byte	0x1
 3603 04ae 01          		.4byte	0x3b
 3604 04ae 00 00 00 00 		.4byte	.LFB22
 3605 04b0 01          		.4byte	.LFE22
 3606 04b1 05 4D       		.4byte	.LLST20
 3607 04b2 01          		.1byte	0x15
 3608 04b2 00 00 00 3B 		.4byte	.LASF22
 3609 04b4 00 00 00 00 		.1byte	0x1
 3610 04b6 00 00 00 00 		.2byte	0x54c
 3611 04b8 00 00 00 00 		.4byte	0x508
 3612 04ba 15          		.1byte	0x2
 3613 04bb 00 00 00 00 		.1byte	0x76
 3614 04bd 01          		.1byte	0x1
 3615 04bd 05 4C       		.1byte	0x11
 3616 04be 00 00 05 08 		.4byte	.LASF74
 3617 04c0 02          		.1byte	0x1
 3618 04c1 76          		.2byte	0x54f
 3619 04c1 01          		.4byte	0x3b
 3620 04c2 11          		.1byte	0x2
 3621 04c2 00 00 00 00 		.1byte	0x76
 3622 04c4 01          		.1byte	0x0
 3623 04c5 05 4F       		.1byte	0x0
 3624 04c6 00 00 00 3B 		.1byte	0x0
 3625 04c8 02          		.section	.debug_abbrev
 3626 04c8 76          		.1byte	0x1
 3627 04c9 00          		.1byte	0x11
 3628 04c9 00          		.1byte	0x1
 3629 04ca 00          		.1byte	0x25
 3630                 		.1byte	0xe
 3631 0000 01          		.1byte	0x13
 3632 0000 11          		.1byte	0xb
 3633 0001 01          		.1byte	0x3
 3634 0001 25          		.1byte	0xe
 3635 0002 0E          		.1byte	0x1b
 3636 0002 13          		.1byte	0xe
 3637 0003 0B          		.1byte	0x11
 3638 0003 03          		.1byte	0x1
 3639 0004 0E          		.1byte	0x52
 3640 0004 1B          		.1byte	0x1
 3641 0005 0E          		.1byte	0x55
 3642 0005 11          		.1byte	0x6
 3643 0006 01          		.1byte	0x10
 3644 0006 52          		.1byte	0x6
 3645 0007 01          		.1byte	0x0
 3646 0007 55          		.1byte	0x0
 3647 0008 06          		.1byte	0x2
 3648 0008 10          		.1byte	0x16
 3649 0009 06          		.1byte	0x0
 3650 0009 00          		.1byte	0x3
 3651 000a 00          		.1byte	0xe
 3652 000a 02          		.1byte	0x3a
 3653 000b 16          		.1byte	0xb
 3654 000b 00          		.1byte	0x3b
 3655 000c 03          		.1byte	0xb
 3656 000c 0E          		.1byte	0x49
 3657 000d 3A          		.1byte	0x13
 3658 000d 0B          		.1byte	0x0
 3659 000e 3B          		.1byte	0x0
 3660 000e 0B          		.1byte	0x3
 3661 000f 49          		.1byte	0x24
 3662 000f 13          		.1byte	0x0
 3663 0010 00          		.1byte	0xb
 3664 0010 00          		.1byte	0xb
 3665 0011 03          		.1byte	0x3e
 3666 0011 24          		.1byte	0xb
 3667 0012 00          		.1byte	0x3
 3668 0012 0B          		.1byte	0xe
 3669 0013 0B          		.1byte	0x0
 3670 0013 3E          		.1byte	0x0
 3671 0014 0B          		.1byte	0x4
 3672 0014 03          		.1byte	0x4
 3673 0015 0E          		.1byte	0x1
 3674 0015 00          		.1byte	0xb
 3675 0016 00          		.1byte	0xb
 3676 0016 04          		.1byte	0x3a
 3677 0017 04          		.1byte	0xb
 3678 0017 01          		.1byte	0x3b
 3679 0018 0B          		.1byte	0xb
 3680 0018 0B          		.1byte	0x1
 3681 0019 3A          		.1byte	0x13
 3682 0019 0B          		.1byte	0x0
 3683 001a 3B          		.1byte	0x0
 3684 001a 0B          		.1byte	0x5
 3685 001b 01          		.1byte	0x28
 3686 001b 13          		.1byte	0x0
 3687 001c 00          		.1byte	0x3
 3688 001c 00          		.1byte	0xe
 3689 001d 05          		.1byte	0x1c
 3690 001d 28          		.1byte	0xd
 3691 001e 00          		.1byte	0x0
 3692 001e 03          		.1byte	0x0
 3693 001f 0E          		.1byte	0x6
 3694 001f 1C          		.1byte	0x13
 3695 0020 0D          		.1byte	0x1
 3696 0020 00          		.1byte	0x3
 3697 0021 00          		.1byte	0xe
 3698 0021 06          		.1byte	0xb
 3699 0022 13          		.1byte	0xb
 3700 0022 01          		.1byte	0x3a
 3701 0023 03          		.1byte	0xb
 3702 0023 0E          		.1byte	0x3b
 3703 0024 0B          		.1byte	0xb
 3704 0024 0B          		.1byte	0x1
 3705 0025 3A          		.1byte	0x13
 3706 0025 0B          		.1byte	0x0
 3707 0026 3B          		.1byte	0x0
 3708 0026 0B          		.1byte	0x7
 3709 0027 01          		.1byte	0xd
 3710 0027 13          		.1byte	0x0
 3711 0028 00          		.1byte	0x3
 3712 0028 00          		.1byte	0xe
 3713 0029 07          		.1byte	0x3a
 3714 0029 0D          		.1byte	0xb
 3715 002a 00          		.1byte	0x3b
 3716 002a 03          		.1byte	0xb
 3717 002b 0E          		.1byte	0x49
 3718 002b 3A          		.1byte	0x13
 3719 002c 0B          		.1byte	0x38
 3720 002c 3B          		.1byte	0xa
 3721 002d 0B          		.1byte	0x0
 3722 002d 49          		.1byte	0x0
 3723 002e 13          		.1byte	0x8
 3724 002e 38          		.1byte	0xf
 3725 002f 0A          		.1byte	0x0
 3726 002f 00          		.1byte	0xb
 3727 0030 00          		.1byte	0xb
 3728 0030 08          		.1byte	0x0
 3729 0031 0F          		.1byte	0x0
 3730 0031 00          		.1byte	0x9
 3731 0032 0B          		.1byte	0xf
 3732 0032 0B          		.1byte	0x0
 3733 0033 00          		.1byte	0xb
 3734 0033 00          		.1byte	0xb
 3735 0034 09          		.1byte	0x49
 3736 0034 0F          		.1byte	0x13
 3737 0035 00          		.1byte	0x0
 3738 0035 0B          		.1byte	0x0
 3739 0036 0B          		.1byte	0xa
 3740 0036 49          		.1byte	0x2e
 3741 0037 13          		.1byte	0x1
 3742 0037 00          		.1byte	0x3
 3743 0038 00          		.1byte	0xe
 3744 0038 0A          		.1byte	0x3a
 3745 0039 2E          		.1byte	0xb
 3746 0039 01          		.1byte	0x3b
 3747 003a 03          		.1byte	0xb
 3748 003a 0E          		.1byte	0x27
 3749 003b 3A          		.1byte	0xc
 3750 003b 0B          		.1byte	0x49
 3751 003c 3B          		.1byte	0x13
 3752 003c 0B          		.1byte	0x11
 3753 003d 27          		.1byte	0x1
 3754 003d 0C          		.1byte	0x12
 3755 003e 49          		.1byte	0x1
 3756 003e 13          		.1byte	0x40
 3757 003f 11          		.1byte	0x6
 3758 003f 01          		.1byte	0x1
 3759 0040 12          		.1byte	0x13
 3760 0040 01          		.1byte	0x0
 3761 0041 40          		.1byte	0x0
 3762 0041 06          		.1byte	0xb
 3763 0042 01          		.1byte	0x5
 3764 0042 13          		.1byte	0x0
 3765 0043 00          		.1byte	0x3
 3766 0043 00          		.1byte	0xe
 3767 0044 0B          		.1byte	0x3a
 3768 0044 05          		.1byte	0xb
 3769 0045 00          		.1byte	0x3b
 3770 0045 03          		.1byte	0xb
 3771 0046 0E          		.1byte	0x49
 3772 0046 3A          		.1byte	0x13
 3773 0047 0B          		.1byte	0x2
 3774 0047 3B          		.1byte	0xa
 3775 0048 0B          		.1byte	0x0
 3776 0048 49          		.1byte	0x0
 3777 0049 13          		.1byte	0xc
 3778 0049 02          		.1byte	0x34
 3779 004a 0A          		.1byte	0x0
 3780 004a 00          		.1byte	0x3
 3781 004b 00          		.1byte	0xe
 3782 004b 0C          		.1byte	0x3a
 3783 004c 34          		.1byte	0xb
 3784 004c 00          		.1byte	0x3b
 3785 004d 03          		.1byte	0xb
 3786 004d 0E          		.1byte	0x49
 3787 004e 3A          		.1byte	0x13
 3788 004e 0B          		.1byte	0x2
 3789 004f 3B          		.1byte	0xa
 3790 004f 0B          		.1byte	0x0
 3791 0050 49          		.1byte	0x0
 3792 0050 13          		.1byte	0xd
 3793 0051 02          		.1byte	0xb
 3794 0051 0A          		.1byte	0x1
 3795 0052 00          		.1byte	0x11
 3796 0052 00          		.1byte	0x1
 3797 0053 0D          		.1byte	0x12
 3798 0053 0B          		.1byte	0x1
 3799 0054 01          		.1byte	0x1
 3800 0054 11          		.1byte	0x13
 3801 0055 01          		.1byte	0x0
 3802 0055 12          		.1byte	0x0
 3803 0056 01          		.1byte	0xe
 3804 0056 01          		.1byte	0x34
 3805 0057 13          		.1byte	0x0
 3806 0057 00          		.1byte	0x3
 3807 0058 00          		.1byte	0x8
 3808 0058 0E          		.1byte	0x3a
 3809 0059 34          		.1byte	0xb
 3810 0059 00          		.1byte	0x3b
 3811 005a 03          		.1byte	0xb
 3812 005a 08          		.1byte	0x49
 3813 005b 3A          		.1byte	0x13
 3814 005b 0B          		.1byte	0x2
 3815 005c 3B          		.1byte	0xa
 3816 005c 0B          		.1byte	0x0
 3817 005d 49          		.1byte	0x0
 3818 005d 13          		.1byte	0xf
 3819 005e 02          		.1byte	0xb
 3820 005e 0A          		.1byte	0x1
 3821 005f 00          		.1byte	0x11
 3822 005f 00          		.1byte	0x1
 3823 0060 0F          		.1byte	0x12
 3824 0060 0B          		.1byte	0x1
 3825 0061 01          		.1byte	0x0
 3826 0061 11          		.1byte	0x0
 3827 0062 01          		.1byte	0x10
 3828 0062 12          		.1byte	0x34
 3829 0063 01          		.1byte	0x0
 3830 0063 00          		.1byte	0x3
 3831 0064 00          		.1byte	0x8
 3832 0064 10          		.1byte	0x3a
 3833 0065 34          		.1byte	0xb
 3834 0065 00          		.1byte	0x3b
 3835 0066 03          		.1byte	0x5
 3836 0066 08          		.1byte	0x49
 3837 0067 3A          		.1byte	0x13
 3838 0067 0B          		.1byte	0x2
 3839 0068 3B          		.1byte	0xa
 3840 0068 05          		.1byte	0x0
 3841 0069 49          		.1byte	0x0
 3842 0069 13          		.1byte	0x11
 3843 006a 02          		.1byte	0x34
 3844 006a 0A          		.1byte	0x0
 3845 006b 00          		.1byte	0x3
 3846 006b 00          		.1byte	0xe
 3847 006c 11          		.1byte	0x3a
 3848 006c 34          		.1byte	0xb
 3849 006d 00          		.1byte	0x3b
 3850 006d 03          		.1byte	0x5
 3851 006e 0E          		.1byte	0x49
 3852 006e 3A          		.1byte	0x13
 3853 006f 0B          		.1byte	0x2
 3854 006f 3B          		.1byte	0xa
 3855 0070 05          		.1byte	0x0
 3856 0070 49          		.1byte	0x0
 3857 0071 13          		.1byte	0x12
 3858 0071 02          		.1byte	0x26
 3859 0072 0A          		.1byte	0x0
 3860 0072 00          		.1byte	0x0
 3861 0073 00          		.1byte	0x0
 3862 0073 12          		.1byte	0x13
 3863 0074 26          		.1byte	0x26
 3864 0074 00          		.1byte	0x0
 3865 0075 00          		.1byte	0x49
 3866 0075 00          		.1byte	0x13
 3867 0076 13          		.1byte	0x0
 3868 0076 26          		.1byte	0x0
 3869 0077 00          		.1byte	0x14
 3870 0077 49          		.1byte	0x2e
 3871 0078 13          		.1byte	0x1
 3872 0078 00          		.1byte	0x3
 3873 0079 00          		.1byte	0xe
 3874 0079 14          		.1byte	0x3a
 3875 007a 2E          		.1byte	0xb
 3876 007a 01          		.1byte	0x3b
 3877 007b 03          		.1byte	0x5
 3878 007b 0E          		.1byte	0x27
 3879 007c 3A          		.1byte	0xc
 3880 007c 0B          		.1byte	0x49
 3881 007d 3B          		.1byte	0x13
 3882 007d 05          		.1byte	0x11
 3883 007e 27          		.1byte	0x1
 3884 007e 0C          		.1byte	0x12
 3885 007f 49          		.1byte	0x1
 3886 007f 13          		.1byte	0x40
 3887 0080 11          		.1byte	0x6
 3888 0080 01          		.1byte	0x1
 3889 0081 12          		.1byte	0x13
 3890 0081 01          		.1byte	0x0
 3891 0082 40          		.1byte	0x0
 3892 0082 06          		.1byte	0x15
 3893 0083 01          		.1byte	0x5
 3894 0083 13          		.1byte	0x0
 3895 0084 00          		.1byte	0x3
 3896 0084 00          		.1byte	0xe
 3897 0085 15          		.1byte	0x3a
 3898 0085 05          		.1byte	0xb
 3899 0086 00          		.1byte	0x3b
 3900 0086 03          		.1byte	0x5
 3901 0087 0E          		.1byte	0x49
 3902 0087 3A          		.1byte	0x13
 3903 0088 0B          		.1byte	0x2
 3904 0088 3B          		.1byte	0xa
 3905 0089 05          		.1byte	0x0
 3906 0089 49          		.1byte	0x0
 3907 008a 13          		.1byte	0x16
 3908 008a 02          		.1byte	0x2e
 3909 008b 0A          		.1byte	0x1
 3910 008b 00          		.1byte	0x3f
 3911 008c 00          		.1byte	0xc
 3912 008c 16          		.1byte	0x3
 3913 008d 2E          		.1byte	0xe
 3914 008d 01          		.1byte	0x3a
 3915 008e 3F          		.1byte	0xb
 3916 008e 0C          		.1byte	0x3b
 3917 008f 03          		.1byte	0x5
 3918 008f 0E          		.1byte	0x27
 3919 0090 3A          		.1byte	0xc
 3920 0090 0B          		.1byte	0x49
 3921 0091 3B          		.1byte	0x13
 3922 0091 05          		.1byte	0x11
 3923 0092 27          		.1byte	0x1
 3924 0092 0C          		.1byte	0x12
 3925 0093 49          		.1byte	0x1
 3926 0093 13          		.1byte	0x40
 3927 0094 11          		.1byte	0x6
 3928 0094 01          		.1byte	0x1
 3929 0095 12          		.1byte	0x13
 3930 0095 01          		.1byte	0x0
 3931 0096 40          		.1byte	0x0
 3932 0096 06          		.1byte	0x17
 3933 0097 01          		.1byte	0x2e
 3934 0097 13          		.1byte	0x1
 3935 0098 00          		.1byte	0x3f
 3936 0098 00          		.1byte	0xc
 3937 0099 17          		.1byte	0x3
 3938 0099 2E          		.1byte	0xe
 3939 009a 01          		.1byte	0x3a
 3940 009a 3F          		.1byte	0xb
 3941 009b 0C          		.1byte	0x3b
 3942 009b 03          		.1byte	0x5
 3943 009c 0E          		.1byte	0x27
 3944 009c 3A          		.1byte	0xc
 3945 009d 0B          		.1byte	0x11
 3946 009d 3B          		.1byte	0x1
 3947 009e 05          		.1byte	0x12
 3948 009e 27          		.1byte	0x1
 3949 009f 0C          		.1byte	0x40
 3950 009f 11          		.1byte	0x6
 3951 00a0 01          		.1byte	0x1
 3952 00a0 12          		.1byte	0x13
 3953 00a1 01          		.1byte	0x0
 3954 00a1 40          		.1byte	0x0
 3955 00a2 06          		.1byte	0x18
 3956 00a2 01          		.1byte	0x5
 3957 00a3 13          		.1byte	0x0
 3958 00a3 00          		.1byte	0x3
 3959 00a4 00          		.1byte	0x8
 3960 00a4 18          		.1byte	0x3a
 3961 00a5 05          		.1byte	0xb
 3962 00a5 00          		.1byte	0x3b
 3963 00a6 03          		.1byte	0x5
 3964 00a6 08          		.1byte	0x49
 3965 00a7 3A          		.1byte	0x13
 3966 00a7 0B          		.1byte	0x2
 3967 00a8 3B          		.1byte	0xa
 3968 00a8 05          		.1byte	0x0
 3969 00a9 49          		.1byte	0x0
 3970 00a9 13          		.1byte	0x19
 3971 00aa 02          		.1byte	0x2e
 3972 00aa 0A          		.1byte	0x1
 3973 00ab 00          		.1byte	0x3f
 3974 00ab 00          		.1byte	0xc
 3975 00ac 19          		.1byte	0x3
 3976 00ac 2E          		.1byte	0xe
 3977 00ad 01          		.1byte	0x3a
 3978 00ad 3F          		.1byte	0xb
 3979 00ae 0C          		.1byte	0x3b
 3980 00ae 03          		.1byte	0x5
 3981 00af 0E          		.1byte	0x27
 3982 00af 3A          		.1byte	0xc
 3983 00b0 0B          		.1byte	0x49
 3984 00b0 3B          		.1byte	0x13
 3985 00b1 05          		.1byte	0x11
 3986 00b1 27          		.1byte	0x1
 3987 00b2 0C          		.1byte	0x12
 3988 00b2 49          		.1byte	0x1
 3989 00b3 13          		.1byte	0x40
 3990 00b3 11          		.1byte	0x6
 3991 00b4 01          		.1byte	0x0
 3992 00b4 12          		.1byte	0x0
 3993 00b5 01          		.1byte	0x0
 3994 00b5 40          		.section	.debug_pubnames,"",@progbits
 3995 00b6 06          		.4byte	0x135
 3996 00b6 00          		.2byte	0x2
 3997 00b7 00          		.4byte	.Ldebug_info0
 3998 00b7 00          		.4byte	0x995
 3999                 		.4byte	0x441
 4000 0000 00 00 01 35 		.ascii "OQCreate\000"
 4001 0002 00 02       		.4byte	0x4b0
 4002 0003 00 00 00 00 		.ascii "OQDestroy\000"
 4003 0005 00 00 09 95 		.4byte	0x4da
 4004 0007 00 00 04 41 		.ascii "OQIsValid\000"
 4005 0009 4F 51 43 72 		.4byte	0x50d
 4005      65 61 74 65 
 4005      00 
 4006 000d 00 00 04 B0 		.ascii "OQQueueData\000"
 4007 000f 4F 51 44 65 		.4byte	0x559
 4007      73 74 72 6F 
 4007      79 00 
 4008 0014 00 00 04 DA 		.ascii "OQPopData\000"
 4009 0016 4F 51 49 73 		.4byte	0x5a5
 4009      56 61 6C 69 
 4009      64 00 
 4010 001b 00 00 05 0D 		.ascii "OQTransferData\000"
 4011 001d 4F 51 51 75 		.4byte	0x659
 4011      65 75 65 44 
 4011      61 74 61 00 
 4012 0023 00 00 05 59 		.ascii "OQSize\000"
 4013 0025 4F 51 50 6F 		.4byte	0x696
 4013      70 44 61 74 
 4013      61 00 
 4014 002a 00 00 05 A5 		.ascii "OQIsEmpty\000"
 4015 002c 4F 51 54 72 		.4byte	0x6c4
 4015      61 6E 73 66 
 4015      65 72 44 61 
 4015      74 61 00 
 4016 0034 00 00 06 59 		.ascii "OQIsFull\000"
 4017 0036 4F 51 53 69 		.4byte	0x6f2
 4017      7A 65 00 
 4018 0039 00 00 06 96 		.ascii "OQCapacity\000"
 4019 003b 4F 51 49 73 		.4byte	0x72f
 4019      45 6D 70 74 
 4019      79 00 
 4020 0040 00 00 06 C4 		.ascii "OQSpace\000"
 4021 0042 4F 51 49 73 		.4byte	0x75d
 4021      46 75 6C 6C 
 4021      00 
 4022 0047 00 00 06 F2 		.ascii "OQClear\000"
 4023 0049 4F 51 43 61 		.4byte	0x787
 4023      70 61 63 69 
 4023      74 79 00 
 4024 004e 00 00 07 2F 		.ascii "OQSetFill\000"
 4025 0050 4F 51 53 70 		.4byte	0x7cf
 4025      61 63 65 00 
 4026 0054 00 00 07 5D 		.ascii "OQRollbackClear\000"
 4027 0056 4F 51 43 6C 		.4byte	0x7f9
 4027      65 61 72 00 
 4028 005a 00 00 07 87 		.ascii "OQSetSize\000"
 4029 005c 4F 51 53 65 		.4byte	0x85e
 4029      74 46 69 6C 
 4029      6C 00 
 4030 0061 00 00 07 CF 		.ascii "OQIncrementSize\000"
 4031 0063 4F 51 52 6F 		.4byte	0x8c3
 4031      6C 6C 62 61 
 4031      63 6B 43 6C 
 4031      65 61 72 00 
 4032 006b 00 00 07 F9 		.ascii "OQDecrementSize\000"
 4033 006d 4F 51 53 65 		.4byte	0x92d
 4033      74 53 69 7A 
 4033      65 00 
 4034 0072 00 00 08 5E 		.ascii "OQGetStartOffset\000"
 4035 0074 4F 51 49 6E 		.4byte	0x95b
 4035      63 72 65 6D 
 4035      65 6E 74 53 
 4035      69 7A 65 00 
 4036 007c 00 00 08 C3 		.ascii "OQGetEndOffset\000"
 4037 007e 4F 51 44 65 		.4byte	0x0
 4037      63 72 65 6D 
 4037      65 6E 74 53 
 4037      69 7A 65 00 
 4038 0086 00 00 09 2D 		.section	.debug_aranges,"",@progbits
 4039 0088 4F 51 47 65 		.4byte	0xbc
 4039      74 53 74 61 
 4039      72 74 4F 66 
 4039      66 73 65 74 
 4039      00 
 4040 0091 00 00 09 5B 		.2byte	0x2
 4041 0093 4F 51 47 65 		.4byte	.Ldebug_info0
 4041      74 45 6E 64 
 4041      4F 66 66 73 
 4041      65 74 00 
 4042 009a 00 00 00 00 		.1byte	0x4
 4043                 		.1byte	0x0
 4044 0000 00 00 00 BC 		.2byte	0x0
 4045 0002 00 02       		.2byte	0x0
 4046 0003 00 00 00 00 		.4byte	.LFB2
 4047 0005 04          		.4byte	.LFE2-.LFB2
 4048 0005 00          		.4byte	.LFB3
 4049 0006 00 00       		.4byte	.LFE3-.LFB3
 4050 0007 00 00       		.4byte	.LFB4
 4051 0008 00 00 00 00 		.4byte	.LFE4-.LFB4
 4052 000a 00 00 00 00 		.4byte	.LFB5
 4053 000c 00 00 00 00 		.4byte	.LFE5-.LFB5
 4054 000e 00 00 00 00 		.4byte	.LFB6
 4055 0010 00 00 00 00 		.4byte	.LFE6-.LFB6
 4056 0012 00 00 00 00 		.4byte	.LFB7
 4057 0014 00 00 00 00 		.4byte	.LFE7-.LFB7
 4058 0016 00 00 00 00 		.4byte	.LFB8
 4059 0018 00 00 00 00 		.4byte	.LFE8-.LFB8
 4060 001a 00 00 00 00 		.4byte	.LFB9
 4061 001c 00 00 00 00 		.4byte	.LFE9-.LFB9
 4062 001e 00 00 00 00 		.4byte	.LFB10
 4063 0020 00 00 00 00 		.4byte	.LFE10-.LFB10
 4064 0022 00 00 00 00 		.4byte	.LFB11
 4065 0024 00 00 00 00 		.4byte	.LFE11-.LFB11
 4066 0026 00 00 00 00 		.4byte	.LFB12
 4067 0028 00 00 00 00 		.4byte	.LFE12-.LFB12
 4068 002a 00 00 00 00 		.4byte	.LFB13
 4069 002c 00 00 00 00 		.4byte	.LFE13-.LFB13
 4070 002e 00 00 00 00 		.4byte	.LFB14
 4071 0030 00 00 00 00 		.4byte	.LFE14-.LFB14
 4072 0032 00 00 00 00 		.4byte	.LFB15
 4073 0034 00 00 00 00 		.4byte	.LFE15-.LFB15
 4074 0036 00 00 00 00 		.4byte	.LFB16
 4075 0038 00 00 00 00 		.4byte	.LFE16-.LFB16
 4076 003a 00 00 00 00 		.4byte	.LFB17
 4077 003c 00 00 00 00 		.4byte	.LFE17-.LFB17
 4078 003e 00 00 00 00 		.4byte	.LFB18
 4079 0040 00 00 00 00 		.4byte	.LFE18-.LFB18
 4080 0042 00 00 00 04 		.4byte	.LFB19
 4081 0044 00 00 00 00 		.4byte	.LFE19-.LFB19
 4082 0046 00 00 00 00 		.4byte	.LFB20
 4083 0048 00 00 00 00 		.4byte	.LFE20-.LFB20
 4084 004a 00 00 00 00 		.4byte	.LFB21
 4085 004c 00 00 00 00 		.4byte	.LFE21-.LFB21
 4086 004e 00 00 00 00 		.4byte	.LFB22
 4087 0050 00 00 00 00 		.4byte	.LFE22-.LFB22
 4088 0052 00 00 00 00 		.4byte	0x0
 4089 0054 00 00 00 00 		.4byte	0x0
 4090 0056 00 00 00 00 		.section	.debug_ranges,"",@progbits
 4091 0058 00 00 00 00 	.Ldebug_ranges0:
 4092 005a 00 00 00 00 		.4byte	.Ltext0
 4093 005c 00 00 00 00 		.4byte	.Letext0
 4094 005e 00 00 00 00 		.4byte	.LFB2
 4095                 		.4byte	.LFE2
 4096                 		.4byte	.LFB3
 4097 0000 00 00 00 00 		.4byte	.LFE3
 4098 0002 00 00 00 00 		.4byte	.LFB4
 4099 0004 00 00 00 00 		.4byte	.LFE4
 4100 0006 00 00 00 00 		.4byte	.LFB5
 4101 0008 00 00 00 00 		.4byte	.LFE5
 4102 000a 00 00 00 00 		.4byte	.LFB6
 4103 000c 00 00 00 00 		.4byte	.LFE6
 4104 000e 00 00 00 00 		.4byte	.LFB7
 4105 0010 00 00 00 00 		.4byte	.LFE7
 4106 0012 00 00 00 00 		.4byte	.LFB8
 4107 0014 00 00 00 00 		.4byte	.LFE8
 4108 0016 00 00 00 00 		.4byte	.LFB9
 4109 0018 00 00 00 00 		.4byte	.LFE9
 4110 001a 00 00 00 00 		.4byte	.LFB10
 4111 001c 00 00 00 00 		.4byte	.LFE10
 4112 001e 00 00 00 00 		.4byte	.LFB11
 4113 0020 00 00 00 00 		.4byte	.LFE11
 4114 0022 00 00 00 00 		.4byte	.LFB12
 4115 0024 00 00 00 00 		.4byte	.LFE12
 4116 0026 00 00 00 00 		.4byte	.LFB13
 4117 0028 00 00 00 00 		.4byte	.LFE13
 4118 002a 00 00 00 00 		.4byte	.LFB14
 4119 002c 00 00 00 00 		.4byte	.LFE14
 4120 002e 00 00 00 00 		.4byte	.LFB15
 4121 0030 00 00 00 00 		.4byte	.LFE15
 4122 0032 00 00 00 00 		.4byte	.LFB16
 4123 0034 00 00 00 00 		.4byte	.LFE16
 4124 0036 00 00 00 00 		.4byte	.LFB17
 4125 0038 00 00 00 00 		.4byte	.LFE17
 4126 003a 00 00 00 00 		.4byte	.LFB18
 4127 003c 00 00 00 00 		.4byte	.LFE18
 4128 003e 00 00 00 00 		.4byte	.LFB19
 4129 0040 00 00 00 00 		.4byte	.LFE19
 4130 0042 00 00 00 00 		.4byte	.LFB20
 4131 0044 00 00 00 00 		.4byte	.LFE20
 4132 0046 00 00 00 00 		.4byte	.LFB21
 4133 0048 00 00 00 00 		.4byte	.LFE21
 4134 004a 00 00 00 00 		.4byte	.LFB22
 4135 004c 00 00 00 00 		.4byte	.LFE22
 4136 004e 00 00 00 00 		.4byte	0x0
 4137 0050 00 00 00 00 		.4byte	0x0
 4138 0052 00 00 00 00 		.section	.debug_str,"MS",@progbits,1
 4139 0054 00 00 00 00 	.LASF60:
 4140 0056 00 00 00 00 		.ascii "OQDestroy\000"
 4141 0058 00 00 00 00 	.LASF25:
 4142 005a 00 00 00 00 		.ascii "src_starts_at_odd_octet\000"
 4143                 	.LASF21:
 4144                 		.ascii "OQ_HANDLE\000"
 4145 0000 4F 51 44 65 	.LASF62:
 4145      73 74 72 6F 
 4145      79 00 
 4146                 		.ascii "OQSetFill\000"
 4147 0005 73 72 63 5F 	.LASF77:
 4147      73 74 61 72 
 4147      74 73 5F 61 
 4147      74 5F 6F 64 
 4147      64 5F 6F 63 
 4148                 		.ascii "D:\\SVN\\Prj01051MigrosEtiketRepo\\trunk\\05_DetailedDesignProcess\\01_DetailedDesignDocum
 4149 0011 4F 51 5F 48 	.LASF75:
 4149      41 4E 44 4C 
 4149      45 00 
 4150                 		.ascii "GNU C 4.3.4 CSR version 22 for xap [1468380]\000"
 4151 0016 4F 51 53 65 	.LASF6:
 4151      74 46 69 6C 
 4151      6C 00 
 4152                 		.ascii "short int\000"
 4153 001b 44 3A 5C 53 	.LASF10:
 4153      56 4E 5C 50 
 4153      72 6A 30 31 
 4153      30 35 31 4D 
 4153      69 67 72 6F 
 4154                 		.ascii "OQDataMode_unpacked\000"
 4155 006e 47 4E 55 20 	.LASF14:
 4155      43 20 34 2E 
 4155      33 2E 34 20 
 4155      43 53 52 20 
 4155      76 65 72 73 
 4156                 		.ascii "p_buffer\000"
 4157 0085 73 68 6F 72 	.LASF50:
 4157      74 20 69 6E 
 4157      74 00 
 4158                 		.ascii "avlbl_space\000"
 4159 008a 4F 51 44 61 	.LASF42:
 4159      74 61 4D 6F 
 4159      64 65 5F 75 
 4159      6E 70 61 63 
 4159      6B 65 64 00 
 4160                 		.ascii "ret_val\000"
 4161 0094 70 5F 62 75 	.LASF54:
 4161      66 66 65 72 
 4161      00 
 4162                 		.ascii "OQSize\000"
 4163 0098 61 76 6C 62 	.LASF12:
 4163      6C 5F 73 70 
 4163      61 63 65 00 
 4164                 		.ascii "OQDataMode_INVALID\000"
 4165 009e 72 65 74 5F 	.LASF39:
 4165      76 61 6C 00 
 4166                 		.ascii "buffer_end\000"
 4167 00a2 4F 51 53 69 	.LASF18:
 4167      7A 65 00 
 4168                 		.ascii "empty\000"
 4169 00a6 4F 51 44 61 	.LASF53:
 4169      74 61 4D 6F 
 4169      64 65 5F 49 
 4169      4E 56 41 4C 
 4169      49 44 00 
 4170                 		.ascii "first_msb\000"
 4171 00af 62 75 66 66 	.LASF74:
 4171      65 72 5F 65 
 4171      6E 64 00 
 4172                 		.ascii "end_offset\000"
 4173 00b5 65 6D 70 74 	.LASF1:
 4173      79 00 
 4174                 		.ascii "uint16\000"
 4175 00b8 66 69 72 73 	.LASF37:
 4175      74 5F 6D 73 
 4175      62 00 
 4176                 		.ascii "octets_fetched\000"
 4177 00bd 65 6E 64 5F 	.LASF63:
 4177      6F 66 66 73 
 4177      65 74 00 
 4178                 		.ascii "enable\000"
 4179 00c2 75 69 6E 74 	.LASF11:
 4179      31 36 00 
 4180                 		.ascii "OQDataMode_packed\000"
 4181 00c6 6F 63 74 65 	.LASF0:
 4181      74 73 5F 66 
 4181      65 74 63 68 
 4181      65 64 00 
 4182                 		.ascii "uint8\000"
 4183 00cd 65 6E 61 62 	.LASF70:
 4183      6C 65 00 
 4184                 		.ascii "octets_removed\000"
 4185 00d1 4F 51 44 61 	.LASF35:
 4185      74 61 4D 6F 
 4185      64 65 5F 70 
 4185      61 63 6B 65 
 4185      64 00 
 4186                 		.ascii "popData\000"
 4187 00da 75 69 6E 74 	.LASF8:
 4187      38 00 
 4188                 		.ascii "bool\000"
 4189 00dd 6F 63 74 65 	.LASF67:
 4189      74 73 5F 72 
 4189      65 6D 6F 76 
 4189      65 64 00 
 4190                 		.ascii "current_size\000"
 4191 00e4 70 6F 70 44 	.LASF72:
 4191      61 74 61 00 
 4192                 		.ascii "OQGetStartOffset\000"
 4193 00e8 62 6F 6F 6C 	.LASF36:
 4193      00 
 4194                 		.ascii "avlbl_data\000"
 4195 00eb 63 75 72 72 	.LASF45:
 4195      65 6E 74 5F 
 4195      73 69 7A 65 
 4195      00 
 4196                 		.ascii "OQQueueData\000"
 4197 00f1 4F 51 47 65 	.LASF7:
 4197      74 53 74 61 
 4197      72 74 4F 66 
 4197      66 73 65 74 
 4197      00 
 4198                 		.ascii "long int\000"
 4199 00fa 61 76 6C 62 	.LASF73:
 4199      6C 5F 64 61 
 4199      74 61 00 
 4200                 		.ascii "OQGetEndOffset\000"
 4201 00ff 4F 51 51 75 	.LASF52:
 4201      65 75 65 44 
 4201      61 74 61 00 
 4202                 		.ascii "data_to_be_moved\000"
 4203 0105 6C 6F 6E 67 	.LASF38:
 4203      20 69 6E 74 
 4203      00 
 4204                 		.ascii "data_to_be_fetched\000"
 4205 010a 4F 51 47 65 	.LASF46:
 4205      74 45 6E 64 
 4205      4F 66 66 73 
 4205      65 74 00 
 4206                 		.ascii "octet_count\000"
 4207 0111 64 61 74 61 	.LASF55:
 4207      5F 74 6F 5F 
 4207      62 65 5F 6D 
 4207      6F 76 65 64 
 4207      00 
 4208                 		.ascii "data_size\000"
 4209 011a 64 61 74 61 	.LASF57:
 4209      5F 74 6F 5F 
 4209      62 65 5F 66 
 4209      65 74 63 68 
 4209      65 64 00 
 4210                 		.ascii "OQIsFull\000"
 4211 0123 6F 63 74 65 	.LASF69:
 4211      74 5F 63 6F 
 4211      75 6E 74 00 
 4212                 		.ascii "OQDecrementSize\000"
 4213 0129 64 61 74 61 	.LASF2:
 4213      5F 73 69 7A 
 4213      65 00 
 4214                 		.ascii "unsigned char\000"
 4215 012e 4F 51 49 73 	.LASF27:
 4215      46 75 6C 6C 
 4215      00 
 4216                 		.ascii "space\000"
 4217 0133 4F 51 44 65 	.LASF5:
 4217      63 72 65 6D 
 4217      65 6E 74 53 
 4217      69 7A 65 00 
 4218                 		.ascii "signed char\000"
 4219 013b 75 6E 73 69 	.LASF15:
 4219      67 6E 65 64 
 4219      20 63 68 61 
 4219      72 00 
 4220                 		.ascii "capacity\000"
 4221 0142 73 70 61 63 	.LASF51:
 4221      65 00 
 4222                 		.ascii "octets_moved\000"
 4223 0145 73 69 67 6E 	.LASF76:
 4223      65 64 20 63 
 4223      68 61 72 00 
 4224                 		.ascii "octet_queue.c\000"
 4225 014b 63 61 70 61 	.LASF34:
 4225      63 69 74 79 
 4225      00 
 4226                 		.ascii "queueData\000"
 4227 014f 6F 63 74 65 	.LASF68:
 4227      74 73 5F 6D 
 4227      6F 76 65 64 
 4227      00 
 4228                 		.ascii "OQIncrementSize\000"
 4229 0156 6F 63 74 65 	.LASF32:
 4229      74 5F 71 75 
 4229      65 75 65 2E 
 4229      63 00 
 4230                 		.ascii "src_octet\000"
 4231 015d 71 75 65 75 	.LASF78:
 4231      65 44 61 74 
 4231      61 00 
 4232                 		.ascii "_OQ_HANDLE_T\000"
 4233 0162 4F 51 49 6E 	.LASF16:
 4233      63 72 65 6D 
 4233      65 6E 74 53 
 4233      69 7A 65 00 
 4234                 		.ascii "start\000"
 4235 016a 73 72 63 5F 	.LASF3:
 4235      6F 63 74 65 
 4235      74 00 
 4236                 		.ascii "short unsigned int\000"
 4237 016f 5F 4F 51 5F 	.LASF58:
 4237      48 41 4E 44 
 4237      4C 45 5F 54 
 4237      00 
 4238                 		.ascii "OQCapacity\000"
 4239 0175 73 74 61 72 	.LASF66:
 4239      74 00 
 4240                 		.ascii "OQSetSize\000"
 4241 0178 73 68 6F 72 	.LASF56:
 4241      74 20 75 6E 
 4241      73 69 67 6E 
 4241      65 64 20 69 
 4241      6E 74 00 
 4242                 		.ascii "OQIsEmpty\000"
 4243 0182 4F 51 43 61 	.LASF19:
 4243      70 61 63 69 
 4243      74 79 00 
 4244                 		.ascii "mode\000"
 4245 0187 4F 51 53 65 	.LASF20:
 4245      74 53 69 7A 
 4245      65 00 
 4246                 		.ascii "OQ_HANDLE_T\000"
 4247 018c 4F 51 49 73 	.LASF31:
 4247      45 6D 70 74 
 4247      79 00 
 4248                 		.ascii "out_msb\000"
 4249 0191 6D 6F 64 65 	.LASF65:
 4249      00 
 4250                 		.ascii "OQRollbackClear\000"
 4251 0194 4F 51 5F 48 	.LASF41:
 4251      41 4E 44 4C 
 4251      45 5F 54 00 
 4252                 		.ascii "buffer_mode\000"
 4253 019a 6F 75 74 5F 	.LASF40:
 4253      6D 73 62 00 
 4254                 		.ascii "buffer_capacity\000"
 4255 019e 4F 51 52 6F 	.LASF29:
 4255      6C 6C 62 61 
 4255      63 6B 43 6C 
 4255      65 61 72 00 
 4256                 		.ascii "data_to_be_queued\000"
 4257 01a6 62 75 66 66 	.LASF4:
 4257      65 72 5F 6D 
 4257      6F 64 65 00 
 4258                 		.ascii "long unsigned int\000"
 4259 01ac 62 75 66 66 	.LASF24:
 4259      65 72 5F 63 
 4259      61 70 61 63 
 4259      69 74 79 00 
 4260                 		.ascii "data_size_in_octets\000"
 4261 01b4 64 61 74 61 	.LASF30:
 4261      5F 74 6F 5F 
 4261      62 65 5F 71 
 4261      75 65 75 65 
 4261      64 00 
 4262                 		.ascii "in_msb\000"
 4263 01bd 6C 6F 6E 67 	.LASF22:
 4263      20 75 6E 73 
 4263      69 67 6E 65 
 4263      64 20 69 6E 
 4263      74 00 
 4264                 		.ascii "handle\000"
 4265 01c6 64 61 74 61 	.LASF13:
 4265      5F 73 69 7A 
 4265      65 5F 69 6E 
 4265      5F 6F 63 74 
 4265      65 74 73 00 
 4266                 		.ascii "OQDataMode\000"
 4267 01d0 69 6E 5F 6D 	.LASF26:
 4267      73 62 00 
 4268                 		.ascii "src_data_mode\000"
 4269 01d3 68 61 6E 64 	.LASF44:
 4269      6C 65 00 
 4270                 		.ascii "OQIsValid\000"
 4271 01d7 4F 51 44 61 	.LASF33:
 4271      74 61 4D 6F 
 4271      64 65 00 
 4272                 		.ascii "remaining\000"
 4273 01dc 73 72 63 5F 	.LASF71:
 4273      64 61 74 61 
 4273      5F 6D 6F 64 
 4273      65 00 
 4274                 		.ascii "wrap_size\000"
 4275 01e3 4F 51 49 73 	.LASF64:
 4275      56 61 6C 69 
 4275      64 00 
 4276                 		.ascii "fill_octet\000"
 4277 01e8 72 65 6D 61 	.LASF48:
 4277      69 6E 69 6E 
 4277      67 00 
 4278                 		.ascii "OQTransferData\000"
 4279 01ed 77 72 61 70 	.LASF59:
 4279      5F 73 69 7A 
 4279      65 00 
 4280                 		.ascii "OQSpace\000"
 4281 01f2 66 69 6C 6C 	.LASF23:
 4281      5F 6F 63 74 
 4281      65 74 00 
 4282                 		.ascii "p_data\000"
 4283 01f8 4F 51 54 72 	.LASF43:
 4283      61 6E 73 66 
 4283      65 72 44 61 
 4283      74 61 00 
 4284                 		.ascii "OQCreate\000"
 4285 01ff 4F 51 53 70 	.LASF9:
 4285      61 63 65 00 
 4286                 		.ascii "unsigned int\000"
 4287 0203 70 5F 64 61 	.LASF17:
 4287      74 61 00 
 4288                 		.ascii "boundary\000"
 4289 0207 4F 51 43 72 	.LASF61:
 4289      65 61 74 65 
 4289      00 
 4290                 		.ascii "OQClear\000"
 4291 020b 75 6E 73 69 	.LASF47:
 4291      67 6E 65 64 
 4291      20 69 6E 74 
 4291      00 
 4292                 		.ascii "OQPopData\000"
 4293 0212 62 6F 75 6E 	.LASF49:
 4293      64 61 72 79 
 4293      00 
 4294                 		.ascii "from\000"
 4295 0216 4F 51 43 6C 	.LASF28:
 4295      65 61 72 00 
 4296                 		.ascii "octets_queued\000"
 4297 021a 4F 51 50 6F 		.ident	"GCC: (GNU) 4.3.4 CSR version 22 for xap [1468380]"
 4297      70 44 61 74 
 4297      61 00 
 4298                 	...
